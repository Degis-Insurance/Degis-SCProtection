{
  "language": "Solidity",
  "sources": {
    "src/core/Executor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport \"../util/OwnableWithoutContextUpgradeable.sol\";\nimport \"./interfaces/ExecutorDependencies.sol\";\nimport \"../voting/interfaces/VotingParameters.sol\";\nimport \"./interfaces/ExecutorEventError.sol\";\n\n/**\n * @title Executor Contract\n *\n * @author Eric Lee (ericlee@375labs.org) & Primata (primata@375labs.org)\n *\n * @notice This is the executor contract for degis Protocol Protection\n * \n *         The executor is responsible for the execution of the reports and pool proposals\n *         Both administrators or users can execute proposals and reports\n * \n *         Execute a report means:\n *             - Mark the report as executed\n *             - Reward the reported from the Treasury\n *             - Liquidate / Move the total payout amount out of the priority pool (to the payout pool) \n * \n *         Execute a proposal means:\n *             - Mark the proposal as executed\n *             - Create a new priority pool\n */\ncontract Executor is\n    VotingParameters,\n    ExecutorEventError,\n    OwnableWithoutContextUpgradeable,\n    ExecutorDependencies\n{\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Whether report already executed\n    mapping(uint256 => bool) public reportExecuted;\n\n    // Whether proposal already executed\n    mapping(uint256 => bool) public proposalExecuted;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize() public initializer {\n        __Ownable_init();\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function setPriorityPoolFactory(address _priorityPoolFactory)\n        external\n        onlyOwner\n    {\n        priorityPoolFactory = IPriorityPoolFactory(_priorityPoolFactory);\n    }\n\n    function setIncidentReport(address _incidentReport) external onlyOwner {\n        incidentReport = IIncidentReport(_incidentReport);\n    }\n\n    function setOnboardProposal(address _onboardProposal) external onlyOwner {\n        onboardProposal = IOnboardProposal(_onboardProposal);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        treasury = ITreasury(_treasury);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Execute a report\n     *         The report must already been settled and the result is PASSED\n     *         Execution means:\n     *             1) Give 10% of protocol income to reporter (USDC)\n     *             2) Move the total payout amount out of the priority pool (to payout pool)\n     *             3) Deploy new generations of CRTokens and PRI-LP tokens\n     *\n     *         Can not execute a report before the previous liquidation ended\n     *\n     * @param _reportId Id of the report to be executed\n     */\n    function executeReport(uint256 _reportId) public {\n        // Check and mark the report as \"executed\"\n        if (reportExecuted[_reportId]) revert Executor__AlreadyExecuted();\n        reportExecuted[_reportId] = true;\n\n        IIncidentReport.Report memory report = incidentReport.getReport(\n            _reportId\n        );\n\n        if (report.status != SETTLED_STATUS)\n            revert Executor__ReportNotSettled();\n        if (report.result != PASS_RESULT) revert Executor__ReportNotPassed();\n\n        // Executed callback function\n        incidentReport.executed(_reportId);\n\n        // Give 10% of treasury to the reporter\n        treasury.rewardReporter(report.poolId, report.reporter);\n\n        // Unpause the priority pool and protection pool\n        // factory.pausePriorityPool(report.poolId, false);\n\n        // Liquidate the pool\n        (, address poolAddress, , , ) = priorityPoolFactory.pools(\n            report.poolId\n        );\n        IPriorityPool(poolAddress).liquidatePool(report.payout);\n\n        emit ReportExecuted(poolAddress, report.poolId, _reportId);\n    }\n\n    /**\n     * @notice Execute the proposal\n     *         The proposal must already been settled and the result is PASSED\n     *         New priority pool will be deployed with parameters\n     *\n     * @param _proposalId Proposal id\n     */\n    function executeProposal(uint256 _proposalId)\n        external\n        returns (address newPriorityPool)\n    {\n        // Check and mark the proposal as \"executed\"\n        if (proposalExecuted[_proposalId]) revert Executor__AlreadyExecuted();\n        proposalExecuted[_proposalId] = true;\n\n        IOnboardProposal.Proposal memory proposal = onboardProposal.getProposal(\n            _proposalId\n        );\n\n        if (proposal.status != SETTLED_STATUS)\n            revert Executor__ProposalNotSettled();\n        if (proposal.result != PASS_RESULT)\n            revert Executor__ProposalNotPassed();\n\n        // Execute the proposal\n        newPriorityPool = priorityPoolFactory.deployPool(\n            proposal.name,\n            proposal.protocolToken,\n            proposal.maxCapacity,\n            proposal.basePremiumRatio\n        );\n\n        emit NewPoolExecuted(\n            newPriorityPool,\n            _proposalId,\n            proposal.protocolToken\n        );\n    }\n}\n"
    },
    "src/util/OwnableWithoutContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nabstract contract OwnableWithoutContextUpgradeable is Initializable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(msg.sender);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Only owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() external onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal {\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "src/core/interfaces/ExecutorDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\n// import \"../../interfaces/IPriorityPool.sol\";\nimport \"../../interfaces/IPriorityPoolFactory.sol\";\nimport \"../../interfaces/IOnboardProposal.sol\";\n\nimport \"../../interfaces/ITreasury.sol\";\n\ninterface IPriorityPool {\n    function liquidatePool(uint256 amount) external;\n}\n\ninterface IIncidentReport {\n    struct Report {\n        uint256 poolId; // Project pool id\n        uint256 reportTimestamp; // Time of starting report\n        address reporter; // Reporter address\n        uint256 voteTimestamp; // Voting start timestamp\n        uint256 numFor; // Votes voting for\n        uint256 numAgainst; // Votes voting against\n        uint256 round; // 0: Initial round 3 days, 1: Extended round 1 day, 2: Double extended 1 day\n        uint256 status; // 0: INIT, 1: PENDING, 2: VOTING, 3: SETTLED, 404: CLOSED\n        uint256 result; // 1: Pass, 2: Reject, 3: Tied\n        uint256 votingReward; // Voting reward per veDEG\n        uint256 payout; // Payout amount of this report (partial payout)\n    }\n\n    function getReport(uint256) external view returns (Report memory);\n\n    function executed(uint256 _reportId) external;\n}\n\nabstract contract ExecutorDependencies {\n    IPriorityPoolFactory public priorityPoolFactory;\n    IIncidentReport public incidentReport;\n    IOnboardProposal public onboardProposal;\n    ITreasury public treasury;\n}\n"
    },
    "src/voting/interfaces/VotingParameters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nabstract contract VotingParameters {\n    // Status parameters for a voting\n    uint256 internal constant INIT_STATUS = 0;\n    uint256 internal constant PENDING_STATUS = 1;\n    uint256 internal constant VOTING_STATUS = 2;\n    uint256 internal constant SETTLED_STATUS = 3;\n    uint256 internal constant CLOSE_STATUS = 404;\n\n    // Result parameters for a voting\n    uint256 internal constant INIT_RESULT = 0;\n    uint256 internal constant PASS_RESULT = 1;\n    uint256 internal constant REJECT_RESULT = 2;\n    uint256 internal constant TIED_RESULT = 3;\n    uint256 internal constant FAILED_RESULT = 4;\n\n    // Voting choices\n    uint256 internal constant VOTE_FOR = 1;\n    uint256 internal constant VOTE_AGAINST = 2;\n}\n"
    },
    "src/core/interfaces/ExecutorEventError.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface ExecutorEventError {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event ReportExecuted(address pool, uint256 poolId, uint256 reportId);\n\n    event NewPoolExecuted(\n        address poolAddress,\n        uint256 proposalId,\n        address protocol\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error Executor__ReportNotSettled();\n    error Executor__ReportNotPassed();\n    error Executor__ProposalNotSettled();\n    error Executor__ProposalNotPassed();\n    error Executor__AlreadyExecuted();\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "src/interfaces/IPriorityPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IPriorityPoolFactory {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event PoolCreated(\n        address poolAddress,\n        uint256 poolId,\n        string protocolName,\n        address protocolToken,\n        uint256 maxCapacity,\n        uint256 policyPricePerUSDC\n    );\n\n    struct PoolInfo {\n        string a;\n        address b;\n        address c;\n        uint256 d;\n        uint256 e;\n    }\n\n    function deg() external view returns (address);\n\n    function deployPool(\n        string memory _name,\n        address _protocolToken,\n        uint256 _maxCapacity,\n        uint256 _policyPricePerToken\n    ) external returns (address);\n\n    function executor() external view returns (address);\n\n    function getPoolAddressList() external view returns (address[] memory);\n\n    function getPoolInfo(uint256 _id) external view returns (PoolInfo memory);\n\n    function incidentReport() external view returns (address);\n\n    function priorityPoolFactory() external view returns (address);\n\n    function maxCapacity() external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function policyCenter() external view returns (address);\n\n    function poolCounter() external view returns (uint256);\n\n    function poolInfoById(uint256)\n        external\n        view\n        returns (\n            string memory protocolName,\n            address poolAddress,\n            address protocolToken,\n            uint256 maxCapacity,\n            uint256 policyPricePerUSDC\n        );\n\n    function poolRegistered(address) external view returns (bool);\n\n    function protectionPool() external view returns (address);\n\n    function setProtectionPool(address _protectionPool) external;\n\n    function updateMaxCapacity(bool _isUp, uint256 _maxCapacity) external;\n\n    function tokenRegistered(address) external view returns (bool);\n\n    function totalMaxCapacity() external view returns (uint256);\n\n    function transferOwnership(address newOwner) external;\n\n    function veDeg() external view returns (address);\n\n    function updateDynamicPool(uint256 _poolId) external;\n\n    function dynamicPoolCounter() external view returns (uint256);\n\n    function dynamic(address _pool) external view returns (bool);\n\n    function pools(uint256 _poolId)\n        external\n        view\n        returns (\n            string memory name,\n            address poolAddress,\n            address protocolToken,\n            uint256 maxCapacity,\n            uint256 basePremiumRatio\n        );\n\n    function payoutPool() external view returns (address);\n\n    function pausePriorityPool(uint256 _poolId, bool _paused) external;\n\n   \n}\n"
    },
    "src/interfaces/IOnboardProposal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IOnboardProposal {\n    struct Proposal {\n        string name; // Pool name (\"JOE\", \"GMX\")\n        address protocolToken; // Protocol native token address\n        address proposer; // Proposer address\n        uint256 proposeTimestamp; // Timestamp when proposing\n        uint256 voteTimestamp; // Timestamp when start voting\n        uint256 numFor; // Votes voting for\n        uint256 numAgainst; // Votes voting against\n        uint256 maxCapacity; // Max capacity ratio\n        uint256 basePremiumRatio; // Base annual premium ratio\n        uint256 poolId; // Priority pool id\n        uint256 status; // Current status (PENDING, VOTING, SETTLED, CLOSED)\n        uint256 result; // Final result (PASSED, REJECTED, TIED)\n    }\n\n    struct UserVote {\n        uint256 choice; // 1: vote for, 2: vote against\n        uint256 amount; // veDEG amount for voting\n        bool claimed; // Voting reward already claimed\n    }\n\n    event NewProposal(\n        string name,\n        address token,\n        uint256 maxCapacity,\n        uint256 priceRatio\n    );\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event ProposalSettled(uint256 proposalId, uint256 result);\n    event ProposalVoted(\n        uint256 proposalId,\n        address indexed user,\n        uint256 voteFor,\n        uint256 amount\n    );\n\n    function claim(uint256 _proposalId, address _user) external;\n\n    function closeProposal(uint256 _proposalId) external;\n\n    function deg() external view returns (address);\n\n    function executor() external view returns (address);\n\n    function getProposal(uint256 _proposalId)\n        external\n        view\n        returns (Proposal memory);\n\n    function incidentReport() external view returns (address);\n\n    function priorityPoolFactory() external view returns (address);\n\n    function onboardProposal() external view returns (address);\n\n    function owner() external view returns (address);\n\n    function policyCenter() external view returns (address);\n\n    function poolProposed(address) external view returns (bool);\n\n    function proposalCounter() external view returns (uint256);\n\n    function proposals(uint256)\n        external\n        view\n        returns (\n            string memory name,\n            address protocolToken,\n            address proposer,\n            uint256 proposeTimestamp,\n            uint256 numFor,\n            uint256 numAgainst,\n            uint256 maxCapacity,\n            uint256 priceRatio,\n            uint256 poolId,\n            uint256 status,\n            uint256 result\n        );\n\n    function propose(\n        string memory _name,\n        address _token,\n        uint256 _maxCapacity,\n        uint256 _priceRatio,\n        address _user\n    ) external;\n\n    function protectionPool() external view returns (address);\n\n    function renounceOwnership() external;\n\n    function setExecutor(address _executor) external;\n\n    function setIncidentReport(address _incidentReport) external;\n\n    function setPriorityPoolFactory(address _priorityPoolFactory) external;\n\n    function setOnboardProposal(address _onboardProposal) external;\n\n    function setPolicyCenter(address _policyCenter) external;\n\n    function setProtectionPool(address _protectionPool) external;\n\n    function settle(uint256 _proposalId) external;\n\n    function startVoting(uint256 _proposalId) external;\n\n    function transferOwnership(address newOwner) external;\n\n    function getUserProposalVote(address user, uint256 proposalId)\n        external\n        view\n        returns (UserVote memory);\n\n    function veDeg() external view returns (address);\n\n    function vote(\n        uint256 _reportId,\n        uint256 _isFor,\n        uint256 _amount,\n        address _user\n    ) external;\n}\n"
    },
    "src/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface ITreasury {\n    function rewardReporter(uint256 _poolId, address _reporter) external;\n\n    function premiumIncome(uint256 _poolId, uint256 _amount) external;\n}\n"
    },
    "src/voting/onboardProposal/OnboardProposalParameters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../interfaces/VotingParameters.sol\";\n\nabstract contract OnboardProposalParameters is VotingParameters {\n    // TODO: Parameters for test\n    //       2 hours for fujiInternal, 18 hours for fuji\n    uint256 public constant PROPOSAL_VOTING_PERIOD = 72 hours;\n\n    // DEG threshold for starting a report\n    // TODO: Different threshold for test and mainnet\n    uint256 public constant PROPOSE_THRESHOLD = 0;\n\n    // 10000 = 100%\n    uint256 public constant MAX_CAPACITY_RATIO = 10000;\n}\n"
    },
    "src/voting/onboardProposal/OnboardProposal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport \"../../util/OwnableWithoutContextUpgradeable.sol\";\n\nimport \"./OnboardProposalParameters.sol\";\nimport \"./OnboardProposalDependencies.sol\";\nimport \"./OnboardProposalEventError.sol\";\n\nimport \"../../interfaces/ExternalTokenDependencies.sol\";\n\n/**\n * @notice Onboard Proposal\n */\ncontract OnboardProposal is\n    OnboardProposalParameters,\n    OnboardProposalEventError,\n    OwnableWithoutContextUpgradeable,\n    ExternalTokenDependencies,\n    OnboardProposalDependencies\n{\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Total number of reports\n    uint256 public proposalCounter;\n\n    // Proposal quorum ratio\n    uint256 public quorumRatio;\n\n    struct Proposal {\n        string name; // Pool name (\"JOE\", \"GMX\")\n        address protocolToken; // Protocol native token address\n        address proposer; // Proposer address\n        uint256 proposeTimestamp; // Timestamp when proposing\n        uint256 voteTimestamp; // Timestamp when start voting\n        uint256 numFor; // Votes voting for\n        uint256 numAgainst; // Votes voting against\n        uint256 maxCapacity; // Max capacity ratio\n        uint256 basePremiumRatio; // Base annual premium ratio\n        uint256 poolId; // Priority pool id\n        uint256 status; // Current status (PENDING, VOTING, SETTLED, CLOSED)\n        uint256 result; // Final result (PASSED, REJECTED, TIED)\n    }\n    // Proposal ID => Proposal\n    mapping(uint256 => Proposal) public proposals;\n\n    // Protocol token => Whether proposed\n    // A protocol can only have one pool\n    mapping(address => bool) public proposed;\n\n    struct UserVote {\n        uint256 choice; // 1: vote for, 2: vote against\n        uint256 amount; // veDEG amount for voting\n        bool claimed; // Voting reward already claimed\n    }\n    // User address => report id => user's voting info\n    mapping(address => mapping(uint256 => UserVote)) public votes;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(\n        address _deg,\n        address _veDeg\n    ) public initializer {\n        __Ownable_init();\n        __ExternalToken__Init(_deg, _veDeg);\n\n        // Initial quorum 30%\n        quorumRatio = 30;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function getProposal(uint256 _proposalId)\n        external\n        view\n        returns (Proposal memory)\n    {\n        return proposals[_proposalId];\n    }\n\n    function getUserProposalVote(address _user, uint256 _proposalId)\n        external\n        view\n        returns (UserVote memory)\n    {\n        return votes[_user][_proposalId];\n    }\n\n    function getAllProposals()\n        external\n        view\n        returns (Proposal[] memory allProposals)\n    {\n        uint256 totalProposal = proposalCounter;\n\n        allProposals = new Proposal[](totalProposal);\n\n        for (uint256 i; i < totalProposal; ) {\n            allProposals[i] = proposals[i + 1];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function setPriorityPoolFactory(address _priorityPoolFactory)\n        external\n        onlyOwner\n    {\n        priorityPoolFactory = IPriorityPoolFactory(_priorityPoolFactory);\n    }\n\n    function setQuorumRatio(uint256 _quorumRatio) external onlyOwner {\n        quorumRatio = _quorumRatio;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Start a new proposal\n     *\n     * @param _name             New project name\n     * @param _token            Native token address\n     * @param _maxCapacity      Max capacity ratio for the project pool\n     * @param _basePremiumRatio Base annual ratio of the premium\n     */\n    function propose(\n        string calldata _name,\n        address _token,\n        uint256 _maxCapacity,\n        uint256 _basePremiumRatio // 10000 == 100% premium annual cost\n    ) external onlyOwner {\n        _propose(_name, _token, _maxCapacity, _basePremiumRatio, msg.sender);\n    }\n\n    /**\n     * @notice Start the voting process\n     *         Need the approval of dev team (onlyOwner)\n     *\n     * @param _id Proposal id to start voting\n     */\n    function startVoting(uint256 _id) external onlyOwner {\n        Proposal storage proposal = proposals[_id];\n\n        if (proposal.status != PENDING_STATUS)\n            revert OnboardProposal__WrongStatus();\n\n        proposal.status = VOTING_STATUS;\n        proposal.voteTimestamp = block.timestamp;\n\n        emit ProposalVotingStart(_id, block.timestamp);\n    }\n\n    /**\n     * @notice Close a pending proposal\n     *         Need the approval of dev team (onlyOwner)\n     *\n     * @param _id Proposal id\n     */\n    function closeProposal(uint256 _id) external onlyOwner {\n        Proposal storage proposal = proposals[_id];\n\n        // require current proposal to be settled\n        if (proposal.status != PENDING_STATUS)\n            revert OnboardProposal__WrongStatus();\n\n        proposal.status = CLOSE_STATUS;\n\n        proposed[proposal.protocolToken] = false;\n\n        emit ProposalClosed(_id, block.timestamp);\n    }\n\n    /**\n     * @notice Vote for a proposal\n     *\n     *         Voting power is decided by the (unlocked) balance of veDEG\n     *         Once voted, those veDEG will be locked\n     *\n     * @param _id     Proposal id\n     * @param _isFor  Voting choice\n     * @param _amount Amount of veDEG to vote\n     */\n    function vote(\n        uint256 _id,\n        uint256 _isFor,\n        uint256 _amount\n    ) external {\n        _vote(_id, _isFor, _amount, msg.sender);\n    }\n\n    /**\n     * @notice Settle the proposal result\n     *\n     * @param _id Proposal id\n     */\n    function settle(uint256 _id) external {\n        Proposal storage proposal = proposals[_id];\n\n        if (proposal.status != VOTING_STATUS)\n            revert OnboardProposal__WrongStatus();\n\n        if (!_passedVotingPeriod(proposal.voteTimestamp))\n            revert OnboardProposal__WrongPeriod();\n\n        // If reached quorum, settle the result\n        if (_checkQuorum(proposal.numFor + proposal.numAgainst)) {\n            uint256 res = _getVotingResult(\n                proposal.numFor,\n                proposal.numAgainst\n            );\n\n            // If this proposal not passed, allow new proposals for the same project\n            // If it passed, not allow the same proposals\n            if (res != PASS_RESULT) {\n                // Allow for new proposals to be proposed for this protocol\n                proposed[proposal.protocolToken] = false;\n            }\n\n            proposal.result = res;\n            proposal.status = SETTLED_STATUS;\n\n            emit ProposalSettled(_id, res);\n        }\n        // Else, set the result as \"FAILED\"\n        else {\n            proposal.result = FAILED_RESULT;\n            proposal.status = SETTLED_STATUS;\n\n            // Allow for new proposals to be proposed for this protocol\n            proposed[proposal.protocolToken] = false;\n\n            emit ProposalFailed(_id);\n        }\n    }\n\n    /**\n     * @notice Claim back veDEG after voting result settled\n     *\n     * @param _id Proposal id\n     */\n    function claim(uint256 _id) external {\n        _claim(_id, msg.sender);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Start a new proposal\n     *\n     * @param _name             New project name\n     * @param _token            Native token address\n     * @param _maxCapacity      Max capacity ratio for the project pool\n     * @param _basePremiumRatio Base annual ratio of the premium\n     */\n    function _propose(\n        string calldata _name,\n        address _token,\n        uint256 _maxCapacity,\n        uint256 _basePremiumRatio, // 10000 == 100% premium annual cost\n        address _user\n    ) internal {\n        if (priorityPoolFactory.tokenRegistered(_token))\n            revert OnboardProposal__AlreadyProtected();\n\n        if (_maxCapacity == 0 || _maxCapacity > MAX_CAPACITY_RATIO)\n            revert OnboardProposal__WrongCapacity();\n\n        if (_basePremiumRatio >= 10000 || _basePremiumRatio == 0)\n            revert OnboardProposal__WrongPremium();\n\n        if (proposed[_token]) revert OnboardProposal__AlreadyProposed();\n\n        // Burn degis tokens to start a proposal\n        // deg.burnDegis(_user, PROPOSE_THRESHOLD);\n\n        proposed[_token] = true;\n\n        uint256 currentCounter = ++proposalCounter;\n        // Record the proposal info\n        Proposal storage proposal = proposals[currentCounter];\n        proposal.name = _name;\n        proposal.protocolToken = _token;\n        proposal.proposer = _user;\n        proposal.proposeTimestamp = block.timestamp;\n        proposal.status = PENDING_STATUS;\n        proposal.maxCapacity = _maxCapacity;\n        proposal.basePremiumRatio = _basePremiumRatio;\n\n        emit NewProposal(_name, _token, _user, _maxCapacity, _basePremiumRatio);\n    }\n\n    /**\n     * @notice Vote for a proposal\n     *\n     * @param _id     Proposal id\n     * @param _isFor  Voting choice\n     * @param _amount Amount of veDEG to vote\n     */\n    function _vote(\n        uint256 _id,\n        uint256 _isFor,\n        uint256 _amount,\n        address _user\n    ) internal {\n        Proposal storage proposal = proposals[_id];\n\n        // Should be manually switched on the voting process\n        if (proposal.status != VOTING_STATUS)\n            revert OnboardProposal__WrongStatus();\n        if (_isFor != 1 && _isFor != 2) revert OnboardProposal__WrongChoice();\n        if (_passedVotingPeriod(proposal.voteTimestamp))\n            revert OnboardProposal__WrongPeriod();\n        if (_amount == 0) revert OnboardProposal__ZeroAmount();\n\n        _enoughVeDEG(_user, _amount);\n\n        // Lock vedeg until this report is settled\n        veDeg.lockVeDEG(_user, _amount);\n\n        // Record the user's choice\n        UserVote storage userVote = votes[_user][_id];\n        if (userVote.amount > 0) {\n            if (userVote.choice != _isFor)\n                revert OnboardProposal__ChooseBothSides();\n        } else {\n            userVote.choice = _isFor;\n        }\n        userVote.amount += _amount;\n\n        // Record the vote for this report\n        if (_isFor == 1) {\n            proposal.numFor += _amount;\n        } else {\n            proposal.numAgainst += _amount;\n        }\n\n        emit ProposalVoted(_id, _user, _isFor, _amount);\n    }\n\n    /**\n     * @notice Claim back veDEG after voting result settled\n     *\n     * @param _id Proposal id\n     */\n    function _claim(uint256 _id, address _user) internal {\n        Proposal storage proposal = proposals[_id];\n\n        if (proposal.status != SETTLED_STATUS)\n            revert OnboardProposal__WrongStatus();\n\n        UserVote storage userVote = votes[_user][_id];\n\n        // @audit Add claimed check\n        if (userVote.claimed) revert OnboardProposal__AlreadyClaimed();\n\n        // Unlock the veDEG used for voting\n        // No reward / punishment\n        veDeg.unlockVeDEG(_user, userVote.amount);\n\n        userVote.claimed = true;\n\n        emit Claimed(_id, _user, userVote.amount);\n    }\n\n    /**\n     * @notice Get the final voting result\n     *\n     * @param _numFor     Votes for\n     * @param _numAgainst Votes against\n     *\n     * @return result Pass, reject or tied\n     */\n    function _getVotingResult(uint256 _numFor, uint256 _numAgainst)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        if (_numFor > _numAgainst) result = PASS_RESULT;\n        else if (_numFor < _numAgainst) result = REJECT_RESULT;\n        else result = TIED_RESULT;\n    }\n\n    /**\n     * @notice Check whether has passed the voting time period\n     *\n     * @param _voteTimestamp Start timestamp of the voting\n     *\n     * @return hasPassed True for passing\n     */\n    function _passedVotingPeriod(uint256 _voteTimestamp)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 endTime = _voteTimestamp + PROPOSAL_VOTING_PERIOD;\n        return block.timestamp > endTime;\n    }\n\n    /**\n     * @notice Check quorum requirement\n     *         30% of totalSupply is the minimum requirement for participation\n     *\n     * @param _totalVotes Total vote numbers\n     */\n    function _checkQuorum(uint256 _totalVotes) internal view returns (bool) {\n        return _totalVotes >= (veDeg.totalSupply() * quorumRatio) / 100;\n    }\n\n    /**\n     * @notice Check veDEG to be enough\n     *         Only unlocked veDEG will be counted\n     *\n     * @param _user   User address\n     * @param _amount Amount to fulfill\n     */\n    function _enoughVeDEG(address _user, uint256 _amount) internal view {\n        uint256 unlockedBalance = veDeg.balanceOf(_user) - veDeg.locked(_user);\n        if (unlockedBalance < _amount) revert OnboardProposal__NotEnoughVeDEG();\n    }\n}\n"
    },
    "src/voting/onboardProposal/OnboardProposalDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IPriorityPoolFactory.sol\";\n\nabstract contract OnboardProposalDependencies {\n    IPriorityPoolFactory public priorityPoolFactory;\n}\n"
    },
    "src/voting/onboardProposal/OnboardProposalEventError.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface OnboardProposalEventError {\n    event NewProposal(\n        string name,\n        address token,\n        address proposer,\n        uint256 maxCapacity,\n        uint256 priceRatio\n    );\n\n    event ProposalVotingStart(uint256 proposalId, uint256 timestamp);\n\n    event ProposalClosed(uint256 proposalId, uint256 timestamp);\n\n    event ProposalVoted(\n        uint256 proposalId,\n        address indexed user,\n        uint256 voteFor,\n        uint256 amount\n    );\n\n    event ProposalSettled(uint256 proposalId, uint256 result);\n\n    event ProposalFailed(uint256 proposalId);\n\n    event Claimed(uint256 proposalId, address user, uint256 amount);\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error OnboardProposal__WrongStatus();\n    error OnboardProposal__WrongPeriod();\n    error OnboardProposal__WrongChoice();\n    error OnboardProposal__ChooseBothSides();\n    error OnboardProposal__NotEnoughVeDEG();\n    error OnboardProposal__NotSettled();\n    error OnboardProposal__NotWrongChoice();\n    error OnboardProposal__AlreadyClaimed();\n    error OnboardProposal__ProposeNotExist();\n    error OnboardProposal__AlreadyProposed();\n    error OnboardProposal__AlreadyProtected();\n    error OnboardProposal__WrongCapacity();\n    error OnboardProposal__WrongPremium();\n    error OnboardProposal__ZeroAmount();\n}\n"
    },
    "src/interfaces/ExternalTokenDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"./IVeDEG.sol\";\nimport \"./IDegisToken.sol\";\nimport \"./CommonDependencies.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @notice External token dependencies\n *         Include the tokens that are not deployed by this repo\n *         DEG, veDEG\n *         They are set as immutable\n */\nabstract contract ExternalTokenDependencies is\n    CommonDependencies,\n    Initializable\n{\n    IDegisToken internal deg;\n    IVeDEG internal veDeg;\n\n    function __ExternalToken__Init(address _deg, address _veDeg)\n        internal\n        onlyInitializing\n    {\n        deg = IDegisToken(_deg);\n        veDeg = IVeDEG(_veDeg);\n    }\n}\n"
    },
    "src/interfaces/IVeDEG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../util/SimpleIERC20.sol\";\n\n/**\n * @dev Interface of the VeDEG\n */\ninterface IVeDEG is SimpleIERC20 {\n    // Get the locked amount of a user's veDeg\n    function locked(address _user) external view returns (uint256);\n\n    // Lock veDEG\n    function lockVeDEG(address _to, uint256 _amount) external;\n\n    // Unlock veDEG\n    function unlockVeDEG(address _to, uint256 _amount) external;\n}\n"
    },
    "src/interfaces/IDegisToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../util/SimpleIERC20.sol\";\n\ninterface IDegisToken is SimpleIERC20 {\n    // Mint degis token\n    function mintDegis(address _account, uint256 _amount) external;\n\n    // Burn degis token\n    function burnDegis(address _account, uint256 _amount) external;\n}\n"
    },
    "src/interfaces/CommonDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nabstract contract CommonDependencies {\n    uint256 internal constant SCALE = 1e12;\n}\n"
    },
    "src/util/SimpleIERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface SimpleIERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n"
    },
    "src/voting/incidentReport/IncidentReport.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport \"../../util/OwnableWithoutContextUpgradeable.sol\";\n\nimport \"./IncidentReportParameters.sol\";\nimport \"./IncidentReportDependencies.sol\";\nimport \"./IncidentReportEventError.sol\";\n\nimport \"../../interfaces/ExternalTokenDependencies.sol\";\n\n/**\n * @notice Incident Report Contract\n *\n *         New reports for project hacks are handled inside this contract\n *\n *         Timeline for a report is:\n *\n *         |-----------------------|----------------------|-------|-------|\n *               Pending Period         Voting Period       Extend Period\n *\n *         When a new report is proposed, it start with PENDING_STATUS.\n *         The person who start the report need to deposit REPORT_THRESHOLD DEG tokens.\n *         During PENDING_STATUS, users & security companies can look at the report event.\n *\n *         After PENDING_PERIOD, the voting can be started and status transfer to VOTING_STATUS.\n *         Users can vote for or against the report with veDeg tokens.\n *         VeDeg tokens used for voting will be tentatively locked until the voting is settled.\n *\n *         After VOTING_PERIOD, the voting can be settled and status transfer to SETTLED_STATUS.\n *         Depending on the votes of each side, the result can be PASSED, REJECTED or TIED.\n *         Different results for their veDeg tokens will be set depending on the result.\n *\n *         If the result has changes during the last 24 hours of voting, the voting will be extended.\n *         The time can only be extended twice.\n *\n *         For voters:\n *              PASSED: Who vote for will get all veDeg tokens from the opposite side\n *              REJECTED: Who vote against will get all veDeg tokens from the opposite side\n *              TIED: Users can unlock their veDeg tokens\n *         For reporter:\n *              PASSED: Get back REPORT_THRESHOLD and get extra REPORT_REWARD & 10% of total treasury income\n *              REJECTED: Lose REPORT_THRESHOLD to whom vote against\n *              TIED: Lose REPORT_THRESHOLD\n *\n *         When an incident report has passed and been executed\n *         The corresponding priority pool will be liquidated which means:\n *             - Move out some assets for users to claim\n *             - Deploy new generation of crTokens and PRI-LP tokens\n *             - Update the farming weights for the priority farming pool\n *\n */\ncontract IncidentReport is\n    IncidentReportParameters,\n    IncidentReportEventError,\n    OwnableWithoutContextUpgradeable,\n    ExternalTokenDependencies,\n    IncidentReportDependencies\n{\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Total number of reports\n    uint256 public reportCounter;\n\n    // Report quorum ratio\n    uint256 public quorumRatio;\n\n    struct Report {\n        uint256 poolId; // Project pool id\n        uint256 reportTimestamp; // Time of starting report\n        address reporter; // Reporter address\n        uint256 voteTimestamp; // Voting start timestamp\n        uint256 numFor; // Votes voting for\n        uint256 numAgainst; // Votes voting against\n        uint256 round; // 0: Initial round 3 days, 1: Extended round 1 day, 2: Double extended 1 day\n        uint256 status; // 0: INIT, 1: PENDING, 2: VOTING, 3: SETTLED, 404: CLOSED\n        uint256 result; // 1: Pass, 2: Reject, 3: Tied\n        uint256 votingReward; // Voting reward per veDEG\n        uint256 payout; // Payout amount of this report (partial payout)\n    }\n    // Report id => Report\n    mapping(uint256 => Report) public reports;\n\n    // Pool id => All related reports\n    mapping(uint256 => uint256[]) public poolReports;\n\n    struct TempResult {\n        uint256 result;\n        uint256 sampleTimestamp;\n        bool hasChanged;\n    }\n    mapping(uint256 => TempResult) public tempResults;\n\n    struct UserVote {\n        uint256 choice; // 1: vote for, 2: vote against\n        uint256 amount; // total veDEG amount for voting\n        bool claimed; // whether has claimed the reward\n        bool paid; // whether has paid the debt   // @audit Add paid status\n    }\n    // User address => report id => user's voting info\n    mapping(address => mapping(uint256 => UserVote)) public votes;\n\n    // Pool id => whether the pool is being reported\n    mapping(uint256 => bool) public reported;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(\n        address _deg,\n        address _veDeg\n    ) public initializer {\n        __Ownable_init();\n        __ExternalToken__Init(_deg, _veDeg);\n\n        // Initial quorum 50%\n        quorumRatio = 50;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function getUserVote(address _user, uint256 _poolId)\n        external\n        view\n        returns (UserVote memory)\n    {\n        return votes[_user][_poolId];\n    }\n\n    function getTempResult(uint256 _poolId)\n        external\n        view\n        returns (TempResult memory)\n    {\n        return tempResults[_poolId];\n    }\n\n    function getReport(uint256 _id) public view returns (Report memory) {\n        return reports[_id];\n    }\n\n    function getPoolReports(uint256 _poolId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return poolReports[_poolId];\n    }\n\n    function getPoolReportsAmount(uint256 _poolId)\n        external\n        view\n        returns (uint256)\n    {\n        return poolReports[_poolId].length;\n    }\n\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function setPriorityPoolFactory(address _priorityPoolFactory)\n        external\n        onlyOwner\n    {\n        priorityPoolFactory = IPriorityPoolFactory(_priorityPoolFactory);\n    }\n\n    function setExecutor(address _executor) external onlyOwner {\n        executor = _executor;\n    }\n\n    function setQuorumRatio(uint256 _ratio) external onlyOwner {\n        if (_ratio >= 100) revert IncidentReport__QuorumRatioTooBig();\n        quorumRatio = _ratio;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Start a new incident report\n     *\n     *         1000 DEG tokens are staked to start a report\n     *         If the report is correct, reporter gets back 1000DEG + 10% usdc income + extra 1000DEG\n     *         If the report is wrong, reporter loses 1000DEG to those who vote against\n     *         Only callable through proposal center\n     *\n     * @param _poolId Pool id to report incident\n     * @param _payout Payout amount of this report\n     */\n    function report(uint256 _poolId, uint256 _payout) external onlyOwner {\n        _report(_poolId, _payout, msg.sender);\n    }\n\n    /**\n     * @notice Start the voting process\n     *\n     *         Can only be started after the pending period\n     *         Will change the status from PENDING to VOTING\n     *\n     * @param _id Report id\n     */\n    function startVoting(uint256 _id) external {\n        Report storage currentReport = reports[_id];\n        if (currentReport.status != PENDING_STATUS)\n            revert IncidentReport__WrongStatus();\n\n        // Can only start the voting after pending period\n        if (!_passedPendingPeriod(currentReport.reportTimestamp))\n            revert IncidentReport__WrongPeriod();\n\n        currentReport.status = VOTING_STATUS;\n        currentReport.voteTimestamp = block.timestamp;\n\n        // @audit Pause pools when report rather than start voting\n        // // Pause insurance pool and reinsurance pool\n        // _pausePools(currentReport.poolId);\n\n        emit ReportVotingStart(_id, block.timestamp);\n    }\n\n    /**\n     * @notice Close a pending report\n     *\n     *         Only owner can close a pending report\n     *         Can only be closed before the pending period ends\n     *         Will change the status from PENDING to CLOSED\n     *\n     * @param _id Report id\n     */\n    function closeReport(uint256 _id) external onlyOwner {\n        Report storage currentReport = reports[_id];\n        if (currentReport.status != PENDING_STATUS)\n            revert IncidentReport__WrongStatus();\n\n        // Must close the report before pending period ends\n        if (_passedPendingPeriod(currentReport.reportTimestamp))\n            revert IncidentReport__WrongPeriod();\n\n        currentReport.status = CLOSE_STATUS;\n\n        _setReportedStatus(_id, false);\n\n        poolReports[currentReport.poolId].pop();\n\n        _unpausePools(currentReport.poolId);\n\n        emit ReportClosed(_id, block.timestamp);\n    }\n\n    /**\n     * @notice Vote on current reports\n     *\n     *         Voting power is decided by the (unlocked) balance of veDEG\n     *         Once voted, those veDEG will be locked\n     *         Rewarded if votes with majority\n     *         Punished if votes against majority\n     *\n     * @param _id     Id of the report to be voted on\n     * @param _isFor  The user's choice (1: vote for, 2: vote against)\n     * @param _amount Amount of veDEG used for this vote\n     */\n    function vote(\n        uint256 _id,\n        uint256 _isFor,\n        uint256 _amount\n    ) external {\n        _vote(_id, _isFor, _amount, msg.sender);\n    }\n\n    /**\n     * @notice Settle the final result for a report\n     *\n     * @param _id Report id\n     */\n    function settle(uint256 _id) external {\n        Report storage currentReport = reports[_id];\n\n        if (currentReport.status != VOTING_STATUS)\n            revert IncidentReport__WrongStatus();\n\n        // Check has passed the voting period\n        if (\n            !_passedVotingPeriod(\n                currentReport.round,\n                currentReport.voteTimestamp\n            )\n        ) revert IncidentReport__WrongPeriod();\n\n        if (currentReport.result > 0) revert IncidentReport__AlreadySettled();\n\n        uint256 res = _checkRoundExtended(_id, currentReport.round);\n\n        if (res > 0) {\n            currentReport.status = SETTLED_STATUS;\n            if (_checkQuorum(currentReport.numFor + currentReport.numAgainst)) {\n                // REJECT or TIED: unlock the priority pool & protection pool immediately\n                //                 mark the report as not reported\n                if (res != PASS_RESULT) {\n                    uint256 poolId = currentReport.poolId;\n                    _unpausePools(poolId);\n                    _setReportedStatus(poolId, false);\n\n                    poolReports[poolId].pop();\n                }\n\n                currentReport.result = res;\n\n                _settleVotingReward(_id, res);\n                emit ReportSettled(_id, res);\n            } else {\n                currentReport.result = FAILED_RESULT;\n                uint256 poolId = currentReport.poolId;\n\n                // FAILED: unlock the priority pool & protection pool immediately\n                _unpausePools(poolId);\n                _setReportedStatus(poolId, false);\n\n                emit ReportFailed(_id);\n            }\n        } else {\n            tempResults[_id].hasChanged = false;\n\n            emit ReportExtended(_id, currentReport.round);\n        }\n    }\n\n    /**\n     * @notice Claim the voting reward\n     *         Only callable through proposal center\n     *\n     * @param _id Report id\n     */\n    function claimReward(uint256 _id) external {\n        _claimReward(_id, msg.sender);\n    }\n\n    /**\n     * @notice Pay debt to get back veDEG\n     *\n     *         For those who made a wrong voting choice\n     *         The paid DEG will be burned and the veDEG will be unlocked\n     *\n     *         Can not call this function when result is TIED or choose the correct side\n     *\n     * @param _id   Report id\n     * @param _user User address (can pay debt for another user)\n     */\n    function payDebt(uint256 _id, address _user) external {\n        UserVote memory userVote = votes[_user][_id];\n        uint256 finalResult = reports[_id].result;\n\n        if (finalResult == 0) revert IncidentReport__NotSettled();\n        if (\n            userVote.choice == finalResult ||\n            finalResult == TIED_RESULT ||\n            finalResult == FAILED_RESULT\n        ) revert IncidentReport__NotWrongChoice();\n        // @audit Add paid status\n        if (userVote.paid) revert IncidentReport__AlreadyPaid();\n\n        uint256 debt = (userVote.amount * DEBT_RATIO) / 10000;\n\n        // Pay the debt in DEG\n        deg.burnDegis(msg.sender, debt);\n\n        // Unlock the user's veDEG\n        veDeg.unlockVeDEG(_user, userVote.amount);\n\n        // @audit Add paid status\n        votes[_user][_id].paid = true;\n\n        emit DebtPaid(msg.sender, _user, debt, userVote.amount);\n    }\n\n    function unpausePools(uint256 _poolId) external onlyOwner {\n        _unpausePools(_poolId);\n    }\n\n    /**\n     * @notice Update status after execution\n     *         Only callable by executor\n     *\n     * @param _reportId Report id\n     */\n    function executed(uint256 _reportId) external {\n        if (msg.sender != executor) revert IncidentReport__OnlyExecutor();\n\n        uint256 poolId = reports[_reportId].poolId;\n        _setReportedStatus(poolId, false);\n        _unpausePools(poolId);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Start a new incident report\n     *\n     *         1000 DEG tokens are staked to start a report\n     *         If the report is correct, reporter gets back 1000DEG + 10% usdc income + extra 1000DEG\n     *         If the report is wrong, reporter loses 1000DEG to those who vote against\n     *\n     * @param _poolId Pool id to report incident\n     * @param _payout Payout amount of this report\n     * @param _user   Reporter\n     */\n    function _report(\n        uint256 _poolId,\n        uint256 _payout,\n        address _user\n    ) internal {\n        // Check whether the pool can be reported\n        _checkPoolStatus(_poolId, _payout);\n\n        // Mark as already reported\n        _setReportedStatus(_poolId, true);\n\n        uint256 currentId = ++reportCounter;\n        // Record the new report\n        Report storage newReport = reports[currentId];\n        newReport.poolId = _poolId;\n        newReport.reportTimestamp = block.timestamp;\n        newReport.reporter = _user;\n        newReport.status = PENDING_STATUS;\n        newReport.payout = _payout;\n\n        // Burn degis tokens to start a report\n        // Need to add this smart contract to burner list\n        // deg.burnDegis(_user, REPORT_THRESHOLD);\n\n        // Record this report id to this pool's all reports list\n        poolReports[_poolId].push(currentId);\n\n        // Pause pools immediately when report\n        _pausePools(_poolId);\n\n        emit ReportCreated(currentId, _poolId, block.timestamp, _user, _payout);\n    }\n\n    /**\n     * @notice Vote on current reports\n     *\n     *         Voting power is decided by the (unlocked) balance of veDEG\n     *         Once voted, those veDEG will be locked\n     *         Rewarded if votes with majority\n     *         Punished if votes against majority\n     *\n     * @param _id       Id of the report to be voted on\n     * @param _isFor    The user's choice (1: vote for, 2: vote against)\n     * @param _amount   Amount of veDEG used for this vote\n     * @param _user     The user who votes on the incidnet\n     */\n    function _vote(\n        uint256 _id,\n        uint256 _isFor,\n        uint256 _amount,\n        address _user\n    ) internal {\n        // Should be manually switched on the voting process\n        if (reports[_id].status != VOTING_STATUS)\n            revert IncidentReport__WrongStatus();\n        if (_amount == 0) revert IncidentReport__ZeroAmount();\n        if (_isFor != VOTE_FOR && _isFor != VOTE_AGAINST)\n            revert IncidentReport__WrongChoice();\n\n        _enoughVeDEG(_user, _amount);\n\n        // Lock vedeg until this report is settled\n        _lockVeDEG(_user, _amount);\n\n        // Record the user's choice\n        UserVote storage userVote = votes[_user][_id];\n        if (userVote.amount > 0) {\n            if (userVote.choice != _isFor)\n                revert IncidentReport__ChooseBothSides();\n        } else {\n            userVote.choice = _isFor;\n        }\n        userVote.amount += _amount;\n\n        Report storage currentReport = reports[_id];\n        // Record the vote for this report\n        if (_isFor == VOTE_FOR) {\n            currentReport.numFor += _amount;\n        } else {\n            currentReport.numAgainst += _amount;\n        }\n\n        // Record a temporary result\n        // If the hasChanged already been true, no need for further update\n        // If not reached the last day, no need for update\n        if (\n            !tempResults[_id].hasChanged &&\n            _withinSamplePeriod(\n                currentReport.voteTimestamp,\n                currentReport.round\n            )\n        ) {\n            _recordTempResult(\n                _id,\n                currentReport.numFor,\n                currentReport.numAgainst\n            );\n        }\n\n        emit ReportVoted(_id, _user, _isFor, _amount);\n    }\n\n    /**\n     * @notice Claim the voting reward\n     *\n     *         Only called when:\n     *         - Result is TIED or FAILED\n     *         - Result is PASS or REJECT and you have the correct choice\n     *\n     *         If the result is TIED or FAILED, only unlock veDEG\n     *         If the result is the same as your choice, get the reward\n     *\n     * @param _id   Report id\n     * @param _user User address\n     */\n    function _claimReward(uint256 _id, address _user) internal {\n        UserVote memory userVote = votes[_user][_id];\n        uint256 finalResult = reports[_id].result;\n\n        if (finalResult == INIT_RESULT) revert IncidentReport__NotSettled();\n        if (userVote.claimed) revert IncidentReport__AlreadyClaimed();\n\n        // Correct choice\n        if (userVote.choice == finalResult) {\n            uint256 reward = reports[_id].votingReward * userVote.amount;\n            deg.mintDegis(_user, reward / SCALE);\n\n            _unlockVeDEG(_user, userVote.amount);\n        }\n        // Tied result, give back user's veDEG\n        else if (finalResult == TIED_RESULT || finalResult == FAILED_RESULT) {\n            _unlockVeDEG(_user, userVote.amount);\n        }\n        // Wrong choice, no reward\n        else revert IncidentReport__NoReward();\n\n        votes[_user][_id].claimed = true;\n    }\n\n    /**\n     * @notice Settle voting reward depending on the result\n     *\n     * @param _id     Report id\n     * @param _result Settle result\n     */\n    function _settleVotingReward(uint256 _id, uint256 _result) internal {\n        Report storage currentReport = reports[_id];\n\n        uint256 numFor = currentReport.numFor;\n        uint256 numAgainst = currentReport.numAgainst;\n\n        uint256 totalRewardToVoters;\n\n        if (_result == PASS_RESULT) {\n            // Get back REPORT_THRESHOLD and get extra REPORTER_REWARD deg tokens\n            deg.mintDegis(\n                currentReport.reporter,\n                REPORTER_REWARD + REPORT_THRESHOLD\n            );\n\n            // 40% of total deg reward to the opposite (deg amount)\n            // REWARD_RATIO is 100 max\n            // veDEG => DEG also divided by 100\n            totalRewardToVoters = (numAgainst * REWARD_RATIO) / 10000;\n\n            // Update deg reward for those who vote for\n            currentReport.votingReward = (totalRewardToVoters * SCALE) / numFor;\n        } else if (_result == REJECT_RESULT) {\n            // Total deg reward = reporter's DEG + those who vote for\n            totalRewardToVoters =\n                REPORT_THRESHOLD +\n                (numFor * REWARD_RATIO) /\n                10000;\n\n            // Update deg reward for those who vote against\n            currentReport.votingReward =\n                (totalRewardToVoters * SCALE) /\n                numAgainst;\n        }\n\n        emit VotingRewardSettled(_id, totalRewardToVoters);\n    }\n\n    /**\n     * @notice Check quorum requirement\n     *         30% of totalSupply is the minimum requirement for participation\n     *\n     * @param _totalVotes Total vote numbers\n     */\n    function _checkQuorum(uint256 _totalVotes) internal view returns (bool) {\n        return\n            _totalVotes >=\n            (SimpleIERC20(veDeg).totalSupply() * quorumRatio) / 100;\n    }\n\n    /**\n     * @notice Check veDEG to be enough\n     *\n     * @param _user   User address\n     * @param _amount Amount to fulfill\n     */\n    function _enoughVeDEG(address _user, uint256 _amount) internal view {\n        uint256 unlockedBalance = veDeg.balanceOf(_user) - veDeg.locked(_user);\n        if (unlockedBalance < _amount) revert IncidentReport__NotEnoughVeDEG();\n    }\n\n    /**\n     * @notice Check whether has passed the pending time period\n     *\n     * @param _reportTimestamp Start timestamp of the report\n     *\n     * @return hasPassed True for passing\n     */\n    function _passedPendingPeriod(uint256 _reportTimestamp)\n        internal\n        view\n        returns (bool)\n    {\n        return block.timestamp >= _reportTimestamp + PENDING_PERIOD;\n    }\n\n    /**\n     * @notice Check whether has passed the voting time period\n     *\n     * @param _round         Current round\n     * @param _voteTimestamp Start timestamp of the report voting\n     *\n     * @return hasPassed True for passing\n     */\n    function _passedVotingPeriod(uint256 _round, uint256 _voteTimestamp)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 endTime = _voteTimestamp +\n            INCIDENT_VOTING_PERIOD +\n            _round *\n            EXTEND_PERIOD;\n        return block.timestamp >= endTime;\n    }\n\n    /**\n     * @notice Check whether this round need extend\n     *\n     * @param _id    Report id\n     * @param _round Current round\n     *\n     * @return result 0 for extending, 1/2/3 for final result\n     */\n    function _checkRoundExtended(uint256 _id, uint256 _round)\n        internal\n        returns (uint256 result)\n    {\n        bool hasChanged = tempResults[_id].hasChanged;\n\n        if (hasChanged && _round < MAX_EXTEND_ROUND) {\n            _extendRound(_id);\n        } else {\n            result = _getVotingResult(\n                reports[_id].numFor,\n                reports[_id].numAgainst\n            );\n        }\n    }\n\n    /**\n     * @notice Extend the current round\n     *\n     * @param _id Report id\n     */\n    function _extendRound(uint256 _id) internal {\n        unchecked {\n            ++reports[_id].round;\n        }\n    }\n\n    /**\n     * @notice Record a temporary result when goes in the sampling period\n     *\n     *         Temporary result use 1 for \"pass\" and 2 for \"reject\"\n     *\n     * @param _id         Report id\n     * @param _numFor     Vote numbers for\n     * @param _numAgainst Vote numbers against\n     */\n    function _recordTempResult(\n        uint256 _id,\n        uint256 _numFor,\n        uint256 _numAgainst\n    ) internal {\n        TempResult storage temp = tempResults[_id];\n\n        uint256 currentResult = _getVotingResult(_numFor, _numAgainst);\n\n        // If this is the first time for sampling, not record hasChange state\n        if (temp.result > 0) {\n            temp.hasChanged = currentResult != temp.result;\n        }\n\n        // Store the current result and sample time\n        temp.result = currentResult;\n        temp.sampleTimestamp = block.timestamp;\n    }\n\n    /**\n     * @notice Check time is within sample period\n     *\n     * @param _voteTimestamp Vote start timestamp\n     * @param _round         Current round\n     */\n    function _withinSamplePeriod(uint256 _voteTimestamp, uint256 _round)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 endTime = _voteTimestamp +\n            INCIDENT_VOTING_PERIOD +\n            _extendTime(_round);\n\n        uint256 lastDayStart = _voteTimestamp +\n            INCIDENT_VOTING_PERIOD +\n            _extendTime(_round) -\n            SAMPLE_PERIOD;\n\n        return block.timestamp > lastDayStart && block.timestamp < endTime;\n    }\n\n    /**\n     * @notice Get the final voting result\n     *\n     * @param _numFor     Votes for\n     * @param _numAgainst Votes against\n     *\n     * @return result PASS(1), REJECT(2) or TIED(3)reported\n     */\n    function _getVotingResult(uint256 _numFor, uint256 _numAgainst)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        if (_numFor > _numAgainst) result = PASS_RESULT;\n        else if (_numFor < _numAgainst) result = REJECT_RESULT;\n        else result = TIED_RESULT;\n    }\n\n    /**\n     * @notice Check pool status and return address\n     *         Ensure the pool:\n     *             1) Exists\n     *             2) Has not been reported'\n     *             3) The payout is less than the active covered amount\n     *\n     * @param _poolId Pool id\n     * @param _payout Payout amount\n     *\n     */\n    function _checkPoolStatus(uint256 _poolId, uint256 _payout) internal view {\n        (, address pool, , , ) = priorityPoolFactory.pools(_poolId);\n\n        if (pool == address(0)) revert IncidentReport__PoolNotExist();\n        if (reported[_poolId]) revert IncidentReport__AlreadyReported();\n\n        if (_payout > ISimplePriorityPool(pool).activeCovered())\n            revert IncidentReport__PayoutExceedCovered();\n    }\n\n    /**\n     * @notice Pause the related priority pool and protection pool\n     *         Once there is an incident reported and voting start\n     *\n     * @param _poolId Priority pool id\n     */\n    function _pausePools(uint256 _poolId) internal {\n        IPriorityPoolFactory(priorityPoolFactory).pausePriorityPool(\n            _poolId,\n            true\n        );\n    }\n\n    /**\n     * @notice Unpause the related project pool and the re-insurance pool\n     *         When the report was REJECTED / TIED / FAILED, unlock immediately\n     *         When the report was PASSED, unlock when executor execute it\n     *\n     * @param _poolId Priority pool id\n     */\n    function _unpausePools(uint256 _poolId) internal {\n        IPriorityPoolFactory(priorityPoolFactory).pausePriorityPool(\n            _poolId,\n            false\n        );\n    }\n\n    /**\n     * @notice Calculate the extend time\n     *\n     * @param _round Rounds to extend\n     *\n     * @return extendTime Extend time length\n     */\n    function _extendTime(uint256 _round) internal pure returns (uint256) {\n        return _round * EXTEND_PERIOD;\n    }\n\n    /**\n     * @notice Unlock veDEG\n     *\n     * @param _user   User address\n     * @param _amount Amount to unlock\n     */\n    function _unlockVeDEG(address _user, uint256 _amount) internal {\n        veDeg.unlockVeDEG(_user, _amount);\n    }\n\n    /**\n     * @notice Lock veDEG\n     *\n     * @param _user   User address\n     * @param _amount Amount to lock\n     */\n    function _lockVeDEG(address _user, uint256 _amount) internal {\n        veDeg.lockVeDEG(_user, _amount);\n    }\n\n    /**\n     * @notice Set reported status for a pool\n     *\n     * @param _poolId   Pool id\n     * @param _reported Whether already reported\n     */\n    function _setReportedStatus(uint256 _poolId, bool _reported) internal {\n        reported[_poolId] = _reported;\n    }\n}\n"
    },
    "src/voting/incidentReport/IncidentReportParameters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../interfaces/VotingParameters.sol\";\n\nabstract contract IncidentReportParameters is VotingParameters {\n    // Cool down time parameter\n    // If you submitted a wrong report, you cannot start another within cooldown period\n    uint256 public constant COOLDOWN_WRONG_REPORT = 7 days;\n\n    //  Pending period before start voting\n    uint256 public constant PENDING_PERIOD = 1 days;\n\n    // 16 hours for fuji, 2 hours for fujiInternal\n    uint256 public constant INCIDENT_VOTING_PERIOD = 3 days;\n\n    // Extend time length\n    uint256 public constant EXTEND_PERIOD = 1 days;\n\n    // Sample period for checking whether extend the round\n    uint256 public constant SAMPLE_PERIOD = 1 days;\n\n    // DEG threshold for starting a report\n    uint256 public constant REPORT_THRESHOLD = 10000 ether;\n\n    // DEG reward for correct reporter\n    uint256 public constant REPORTER_REWARD = 10000 ether;\n\n    // Reward & Punishment ratios\n    uint256 public constant REWARD_RATIO = 40; // 40% go to winners, 40% reserve\n    uint256 public constant RESERVE_RATIO = 40;\n    uint256 public constant DEBT_RATIO = 80; // 80% as the debt to unlock veDEG\n\n    // 2 extra rounds at most\n    uint256 public constant MAX_EXTEND_ROUND = 2;\n}\n"
    },
    "src/voting/incidentReport/IncidentReportDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IPriorityPoolFactory.sol\";\n\ninterface ISimplePriorityPool {\n    function activeCovered() external view returns (uint256);\n}\n\nabstract contract IncidentReportDependencies {\n    IPriorityPoolFactory public priorityPoolFactory;\n\n    address public executor;\n}\n"
    },
    "src/voting/incidentReport/IncidentReportEventError.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IncidentReportEventError {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event ReportCreated(\n        uint256 reportId,\n        uint256 indexed poolId,\n        uint256 reportTimestamp,\n        address indexed reporter,\n        uint256 payout\n    );\n\n    event ReportVotingStart(uint256 reportId, uint256 startTimestamp);\n\n    event ReportClosed(uint256 reportId, uint256 closeTimestamp);\n\n    event ReportVoted(\n        uint256 reportId,\n        address indexed user,\n        uint256 voteFor,\n        uint256 amount\n    );\n\n    event ReportSettled(uint256 reportId, uint256 result);\n\n    event ReportExtended(uint256 reportId, uint256 round);\n\n    event ReportFailed(uint256 reportId);\n\n    event DebtPaid(\n        address payer,\n        address user,\n        uint256 debt,\n        uint256 unlockAmount\n    );\n\n    event VotingRewardSettled(uint256 reportId, uint256 totalRewardToVoters);\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error IncidentReport__WrongStatus();\n    error IncidentReport__WrongPeriod();\n    error IncidentReport__WrongChoice();\n    error IncidentReport__ChooseBothSides();\n    error IncidentReport__NotEnoughVeDEG();\n    error IncidentReport__AlreadySettled();\n    error IncidentReport__NotSettled();\n    error IncidentReport__NotWrongChoice();\n    error IncidentReport__AlreadyClaimed();\n    error IncidentReport__PoolNotExist();\n    error IncidentReport__AlreadyReported();\n    error IncidentReport__ZeroAmount();\n    error IncidentReport__NoReward();\n    error IncidentReport__PayoutExceedCovered();\n    error IncidentReport__AlreadyPaid();\n    error IncidentReport__OnlyExecutor();\n    error IncidentReport__QuorumRatioTooBig();\n}\n"
    },
    "src/reward/farming/WeightedFarmingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../util/OwnableWithoutContextUpgradeable.sol\";\n\nimport \"../../libraries/DateTime.sol\";\nimport \"../../interfaces/IPriorityPoolFactory.sol\";\n\nimport \"./WeightedFarmingPoolEventError.sol\";\nimport \"./WeightedFarmingPoolDependencies.sol\";\n\n/**\n * @notice Weighted Farming Pool\n *\n *         Weighted farming pool support multiple tokens to earn the same reward\n *         Different tokens will have different weights when calculating rewards\n *\n *\n *         Native token premiums will be transferred to this pool\n *         The distribution is in the way of \"farming\" but with multiple tokens\n *\n *         Different generations of PRI-LP-1-JOE-G1\n *\n *         About the scales of variables:\n *         - weight            SCALE\n *         - share             SCALE\n *         - accRewardPerShare SCALE * SCALE / SCALE = SCALE\n *         - rewardDebt        SCALE * SCALE / SCALE = SCALE\n *         So pendingReward = ((share * acc) / SCALE - debt) / SCALE\n */\ncontract WeightedFarmingPool is\n    WeightedFarmingPoolEventError,\n    OwnableWithoutContextUpgradeable,\n    WeightedFarmingPoolDependencies\n{\n    using DateTimeLibrary for uint256;\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    uint256 public constant SCALE = 1e12;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    uint256 public counter;\n\n    struct PoolInfo {\n        address[] tokens; // Token addresses (PRI-LP)\n        uint256[] amount; // Token amounts\n        uint256[] weight; // Weight for each token\n        uint256 shares; // Total shares (share = amount * weight)\n        address rewardToken; // Reward token address\n        uint256 lastRewardTimestamp; // Last reward timestamp\n        uint256 accRewardPerShare; // Accumulated reward per share (not per token)\n    }\n    // Pool id => Pool info\n    mapping(uint256 => PoolInfo) public pools;\n\n    // Pool id => Year => Month => Speed\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256)))\n        public speed;\n\n    struct UserInfo {\n        uint256[] amount; // Amount of each token\n        uint256 shares; // Total shares (share = amount * weight)\n        uint256 rewardDebt; // Reward debt\n    }\n    // Pool Id => User address => User Info\n    mapping(uint256 => mapping(address => UserInfo)) public users;\n\n    // Keccak256(poolId, token) => Whether supported\n    // Ensure one token not be added for multiple times\n    mapping(bytes32 => bool) public supported;\n\n    // Pool id => Token address => Token index in the tokens array\n    mapping(uint256 => mapping(address => uint256)) public tokenIndex;\n\n    // Pool id => User address => Index => Previous Weight\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256)))\n        public preWeight;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(address _policyCenter, address _priorityPoolFactory)\n        public\n        initializer\n    {\n        if (_policyCenter == address(0) || _priorityPoolFactory == address(0)) {\n            revert WeightedFarmingPool_ZeroAddress();\n        }\n\n        __Ownable_init();\n\n        policyCenter = _policyCenter;\n        priorityPoolFactory = _priorityPoolFactory;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    modifier isPriorityPool() {\n        require(\n            IPriorityPoolFactory(priorityPoolFactory).poolRegistered(\n                msg.sender\n            ),\n            \"Only Priority Pool\"\n        );\n        _;\n    }\n\n    modifier onlyFactory() {\n        require(\n            msg.sender == priorityPoolFactory,\n            \"Only Priority Pool Factory\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get a user's LP amount\n     *\n     * @param _poolId Pool id\n     * @param _user   User address\n     *\n     * @return amounts Amount array of user's lp in each generation of lp token\n     */\n    function getUserLPAmount(uint256 _poolId, address _user)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return users[_poolId][_user].amount;\n    }\n\n    /**\n     * @notice Get pool information arrays\n     *\n     * @param _poolId Pool id\n     *\n     * @return tokens  Token addresses array\n     * @return amounts Token amounts array\n     * @return weights Token weights array\n     */\n    function getPoolArrays(uint256 _poolId)\n        external\n        view\n        returns (\n            address[] memory,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        PoolInfo storage pool = pools[_poolId];\n        return (pool.tokens, pool.amount, pool.weight);\n    }\n\n    /**\n     * @notice Check whether a token is supported in a certain pool\n     *\n     * @param _poolId Pool id\n     * @param _token  PRI-LP token address\n     *\n     * @return isSupported Whether supported\n     */\n    function supportedToken(uint256 _poolId, address _token)\n        public\n        view\n        returns (bool isSupported)\n    {\n        bytes32 key = keccak256(abi.encodePacked(_poolId, _token));\n        return supported[key];\n    }\n\n    /**\n     * @notice Pending reward\n     *\n     * @param _id   Pool id\n     * @param _user User's address\n     *\n     * @return pending Pending reward in native token\n     */\n    function pendingReward(uint256 _id, address _user)\n        external\n        view\n        returns (uint256 pending)\n    {\n        PoolInfo storage pool = pools[_id];\n        UserInfo storage user = users[_id][_user];\n\n        // accRewardPerShare has 1 * SCALE\n        uint256 accReward = pool.accRewardPerShare;\n        uint256 totalReward;\n\n        uint256 currentTime = block.timestamp;\n        uint256 lastRewardTime = pool.lastRewardTimestamp;\n\n        if (user.shares > 0) {\n            if (\n                lastRewardTime > 0 && block.timestamp > pool.lastRewardTimestamp\n            ) {\n                (uint256 lastY, uint256 lastM, uint256 lastD) = lastRewardTime\n                    .timestampToDate();\n\n                (uint256 currentY, uint256 currentM, ) = currentTime\n                    .timestampToDate();\n\n                uint256 monthPassed = currentM - lastM;\n\n                // In the same month, use current month speed\n                if (monthPassed == 0) {\n                    totalReward +=\n                        (currentTime - lastRewardTime) *\n                        speed[_id][currentY][currentM];\n                }\n                // Across months, use different months' speed\n                else {\n                    for (uint256 i; i < monthPassed + 1; ) {\n                        // First month reward\n                        if (i == 0) {\n                            // End timestamp of the first month\n                            uint256 endTimestamp = DateTimeLibrary\n                                .timestampFromDateTime(\n                                    lastY,\n                                    lastM,\n                                    lastD,\n                                    23,\n                                    59,\n                                    59\n                                );\n                            totalReward +=\n                                (endTimestamp - lastRewardTime) *\n                                speed[_id][lastY][lastM];\n                        }\n                        // Last month reward\n                        else if (i == monthPassed) {\n                            uint256 startTimestamp = DateTimeLibrary\n                                .timestampFromDateTime(\n                                    lastY,\n                                    lastM,\n                                    1,\n                                    0,\n                                    0,\n                                    0\n                                );\n\n                            totalReward +=\n                                (currentTime - startTimestamp) *\n                                speed[_id][lastY][lastM];\n                        }\n                        // Middle month reward\n                        else {\n                            uint256 daysInMonth = DateTimeLibrary\n                                ._getDaysInMonth(lastY, lastM);\n\n                            totalReward +=\n                                (DateTimeLibrary.SECONDS_PER_DAY *\n                                    daysInMonth) *\n                                speed[_id][lastY][lastM];\n                        }\n\n                        unchecked {\n                            if (++lastM > 12) {\n                                ++lastY;\n                                lastM = 1;\n                            }\n\n                            ++i;\n                        }\n                    }\n                }\n            }\n\n            accReward += (totalReward * SCALE) / pool.shares;\n\n            pending =\n                ((user.shares * accReward) / SCALE - user.rewardDebt) /\n                SCALE;\n        }\n    }\n\n    /**\n     * @notice Register a new famring pool for priority pool\n     *\n     * @param _rewardToken Reward token address (protocol native token)\n     */\n    function addPool(address _rewardToken) external onlyFactory {\n        uint256 currentId = ++counter;\n\n        PoolInfo storage pool = pools[currentId];\n        pool.rewardToken = _rewardToken;\n\n        emit PoolAdded(currentId, _rewardToken);\n    }\n\n    /**\n     * @notice Register Pri-LP token\n     *\n     *         Called when new generation of PRI-LP tokens are deployed\n     *         Only called from a priority pool\n     *\n     * @param _id     Pool Id\n     * @param _token  Priority pool lp token address\n     * @param _weight Weight of the token in the pool\n     */\n    function addToken(\n        uint256 _id,\n        address _token,\n        uint256 _weight\n    ) external isPriorityPool {\n        bytes32 key = keccak256(abi.encodePacked(_id, _token));\n        if (supported[key]) revert WeightedFarmingPool__AlreadySupported();\n\n        // Record as supported\n        supported[key] = true;\n\n        pools[_id].tokens.push(_token);\n        pools[_id].weight.push(_weight);\n\n        uint256 index = pools[_id].tokens.length - 1;\n\n        // Store the token index for later check\n        tokenIndex[_id][_token] = index;\n\n        emit NewTokenAdded(_id, _token, index, _weight);\n    }\n\n    /**\n     * @notice Update the weight of a token in a given pool\n     *\n     *         Only called from a priority pool\n     *\n     * @param _id        Pool Id\n     * @param _token     Token address\n     * @param _newWeight New weight of the token in the pool\n     */\n    function updateWeight(\n        uint256 _id,\n        address _token,\n        uint256 _newWeight\n    ) external isPriorityPool {\n        // First update the reward till now\n        // Then update the index to be the new one\n        updatePool(_id);\n\n        uint256 index = _getIndex(_id, _token);\n\n        PoolInfo storage pool = pools[_id];\n\n        uint256 previousWeight = pool.weight[index];\n        pool.weight[index] = _newWeight;\n\n        // Update the pool's shares immediately\n        // When user interaction, update each user's share first\n        pool.shares -= pool.amount[index] * (previousWeight - _newWeight);\n\n        emit PoolWeightUpdated(_id, index, _newWeight);\n    }\n\n    /**\n     * @notice Update reward speed when new premium income\n     *\n     *         Only called from a priority pool\n     *\n     * @param _id       Pool id\n     * @param _newSpeed New speed (SCALED)\n     * @param _years    Years to be updated\n     * @param _months   Months to be updated\n     */\n    function updateRewardSpeed(\n        uint256 _id,\n        uint256 _newSpeed,\n        uint256[] memory _years,\n        uint256[] memory _months\n    ) external isPriorityPool {\n        if (_years.length != _months.length)\n            revert WeightedFarmingPool__WrongDateLength();\n\n        uint256 length = _years.length;\n        for (uint256 i; i < length; ) {\n            speed[_id][_years[i]][_months[i]] += _newSpeed;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit RewardSpeedUpdated(_id, _newSpeed, _years, _months);\n    }\n\n    /**\n     * @notice Deposit from Policy Center\n     *\n     *         No need for approval\n     *         Only called from policy center\n     *\n     * @param _id     Pool id\n     * @param _token  PRI-LP token address\n     * @param _amount Amount to deposit\n     * @param _user   User address\n     */\n    function depositFromPolicyCenter(\n        uint256 _id,\n        address _token,\n        uint256 _amount,\n        address _user\n    ) external {\n        if (msg.sender != policyCenter)\n            revert WeightedFarmingPool__OnlyPolicyCenter();\n\n        _deposit(_id, _token, _amount, _user);\n    }\n\n    /**\n     * @notice Directly deposit (need approval)\n     */\n    function deposit(\n        uint256 _id,\n        address _token,\n        uint256 _amount\n    ) external {\n        _deposit(_id, _token, _amount, msg.sender);\n\n        IERC20(_token).transferFrom(msg.sender, address(this), _amount);\n    }\n\n    function withdrawFromPolicyCenter(\n        uint256 _id,\n        address _token,\n        uint256 _amount,\n        address _user\n    ) external {\n        if (msg.sender != policyCenter)\n            revert WeightedFarmingPool__OnlyPolicyCenter();\n\n        _withdraw(_id, _token, _amount, _user);\n    }\n\n    function withdraw(\n        uint256 _id,\n        address _token,\n        uint256 _amount\n    ) external {\n        _withdraw(_id, _token, _amount, msg.sender);\n    }\n\n    /**\n     * @notice Deposit PRI-LP tokens\n     *\n     * @param _id     Farming pool id\n     * @param _token  PRI-LP token address\n     * @param _amount PRI-LP token amount\n     * @param _user   Real user address\n     */\n    function _deposit(\n        uint256 _id,\n        address _token,\n        uint256 _amount,\n        address _user\n    ) internal {\n        if (_amount == 0) revert WeightedFarmingPool__ZeroAmount();\n        if (_id > counter) revert WeightedFarmingPool__InexistentPool();\n\n        updatePool(_id);\n\n        uint256 index = _getIndex(_id, _token);\n\n        _updateUserWeight(_id, _user, index);\n\n        PoolInfo storage pool = pools[_id];\n        UserInfo storage user = users[_id][_user];\n\n        if (user.shares > 0) {\n            uint256 pending = ((user.shares * pool.accRewardPerShare) /\n                SCALE -\n                user.rewardDebt) / SCALE;\n\n            uint256 actualReward = _safeRewardTransfer(\n                pool.rewardToken,\n                _user,\n                pending\n            );\n\n            emit Harvest(_id, _user, _user, actualReward);\n        }\n\n        // check if current index exists for user\n        // index is 0, push\n        // length <= index\n        uint256 userLength = user.amount.length;\n        if (userLength < index + 1) {\n            // If user amount length is 0, index is 1 => Push 2 zeros\n            // If user amount length is 1, index is 1 => Push 1 zero\n            // If user amount length is 1, index is 2 => Push 2 zeros\n            for (uint256 i = userLength; i < index + 1; ) {\n                user.amount.push(0);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        uint256 poolLength = pool.amount.length;\n        if (poolLength < index + 1) {\n            for (uint256 i = poolLength; i < index + 1; ) {\n                pool.amount.push(0);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        uint256 currentWeight = pool.weight[index];\n\n        // Update user amount for this gen lp token\n        user.amount[index] += _amount;\n        user.shares += _amount * currentWeight;\n\n        // Record this user's previous weight for this token index\n        preWeight[_id][_user][index] = currentWeight;\n\n        // Update pool amount for this gen lp token\n        pool.amount[index] += _amount;\n        pool.shares += _amount * currentWeight;\n\n        user.rewardDebt = (user.shares * pool.accRewardPerShare) / SCALE;\n    }\n\n    /**\n     * @notice Update a user's weight\n     *\n     * @param _id    Pool id\n     * @param _user  User address\n     * @param _index Token index in this pool\n     */\n    function _updateUserWeight(\n        uint256 _id,\n        address _user,\n        uint256 _index\n    ) internal {\n        PoolInfo storage pool = pools[_id];\n        UserInfo storage user = users[_id][_user];\n\n        if (pool.weight.length > 0) {\n            uint256 weight = pool.weight[_index];\n            uint256 previousWeight = preWeight[_id][_user][_index];\n\n            if (previousWeight != 0) {\n                // Only update when weight changes\n                if (weight != previousWeight) {\n                    uint256 amount = user.amount[_index];\n\n                    // Weight is always decreasing\n                    // Ensure: previousWeight - weight > 0\n                    user.shares -= amount * (previousWeight - weight);\n                }\n            }\n        }\n    }\n\n    function _withdraw(\n        uint256 _id,\n        address _token,\n        uint256 _amount,\n        address _user\n    ) internal {\n        if (_amount == 0) revert WeightedFarmingPool__ZeroAmount();\n        if (_id > counter) revert WeightedFarmingPool__InexistentPool();\n        if (!supportedToken(_id, _token))\n            revert WeightedFarmingPool__NotSupported();\n\n        updatePool(_id);\n\n        uint256 index = _getIndex(_id, _token);\n\n        _updateUserWeight(_id, _user, index);\n\n        PoolInfo storage pool = pools[_id];\n        UserInfo storage user = users[_id][_user];\n\n        if (_amount > user.amount[index])\n            revert WeightedFarmingPool__NotEnoughAmount();\n\n        if (user.shares > 0) {\n            uint256 pending = ((user.shares * pool.accRewardPerShare) /\n                SCALE -\n                user.rewardDebt) / SCALE;\n\n            uint256 actualReward = _safeRewardTransfer(\n                pool.rewardToken,\n                _user,\n                pending\n            );\n\n            emit Harvest(_id, _user, _user, actualReward);\n        }\n\n        IERC20(_token).transfer(_user, _amount);\n\n        user.amount[index] -= _amount;\n        user.shares -= _amount * pool.weight[index];\n\n        pool.amount[index] -= _amount;\n        pool.shares -= _amount * pool.weight[index];\n\n        user.rewardDebt = (user.shares * pool.accRewardPerShare) / SCALE;\n    }\n\n    function updatePool(uint256 _id) public {\n        PoolInfo storage pool = pools[_id];\n\n        if (block.timestamp <= pool.lastRewardTimestamp) {\n            return;\n        }\n\n        if (pool.shares > 0) {\n            uint256 newReward = _updateReward(_id);\n\n            // accRewardPerShare has 1 * SCALE\n            pool.accRewardPerShare += (newReward * SCALE) / pool.shares;\n\n            pool.lastRewardTimestamp = block.timestamp;\n\n            emit PoolUpdated(_id, pool.accRewardPerShare);\n        } else {\n            pool.lastRewardTimestamp = block.timestamp;\n            return;\n        }\n    }\n\n    function harvest(uint256 _id, address _to) external {\n        if (_id > counter) revert WeightedFarmingPool__InexistentPool();\n\n        updatePool(_id);\n\n        PoolInfo storage pool = pools[_id];\n        UserInfo storage user = users[_id][msg.sender];\n\n        if (user.shares > 0) {\n            uint256 pending = ((user.shares * pool.accRewardPerShare) /\n                SCALE -\n                user.rewardDebt) / SCALE;\n\n            uint256 actualReward = _safeRewardTransfer(\n                pool.rewardToken,\n                _to,\n                pending\n            );\n\n            emit Harvest(_id, msg.sender, _to, actualReward);\n\n            user.rewardDebt = (user.shares * pool.accRewardPerShare) / SCALE;\n        }\n    }\n\n    /**\n     * @notice Update reward for a pool\n     *\n     * @param _id Pool id\n     */\n    function _updateReward(uint256 _id)\n        internal\n        view\n        returns (uint256 totalReward)\n    {\n        PoolInfo storage pool = pools[_id];\n\n        uint256 currentTime = block.timestamp;\n        uint256 lastRewardTime = pool.lastRewardTimestamp;\n\n        (uint256 lastY, uint256 lastM, ) = lastRewardTime.timestampToDate();\n\n        (uint256 currentY, uint256 currentM, ) = currentTime.timestampToDate();\n\n        // If time goes across years\n        // Change the calculation of months passed\n        uint256 monthPassed;\n        if (currentY > lastY) {\n            monthPassed = currentM + 12 * (currentY - lastY) - lastM;\n        } else {\n            monthPassed = currentM - lastM;\n        }\n\n        // In the same month, use current month speed\n        if (monthPassed == 0) {\n            totalReward +=\n                (currentTime - lastRewardTime) *\n                speed[_id][currentY][currentM];\n        }\n        // Across months, use different months' speed\n        else {\n            for (uint256 i; i < monthPassed + 1; ) {\n                // First month reward\n                if (i == 0) {\n                    uint256 daysInMonth = DateTimeLibrary._getDaysInMonth(\n                        lastY,\n                        lastM\n                    );\n                    // End timestamp of the first month\n                    uint256 endTimestamp = DateTimeLibrary\n                        .timestampFromDateTime(\n                            lastY,\n                            lastM,\n                            daysInMonth,\n                            23,\n                            59,\n                            59\n                        );\n                    totalReward +=\n                        (endTimestamp - lastRewardTime) *\n                        speed[_id][lastY][lastM];\n                }\n                // Last month reward\n                else if (i == monthPassed) {\n                    uint256 startTimestamp = DateTimeLibrary\n                        .timestampFromDateTime(lastY, lastM, 1, 0, 0, 0);\n\n                    totalReward +=\n                        (currentTime - startTimestamp) *\n                        speed[_id][lastY][lastM];\n                }\n                // Middle month reward\n                else {\n                    uint256 daysInMonth = DateTimeLibrary._getDaysInMonth(\n                        lastY,\n                        lastM\n                    );\n\n                    totalReward +=\n                        (DateTimeLibrary.SECONDS_PER_DAY * daysInMonth) *\n                        speed[_id][lastY][lastM];\n                }\n\n                unchecked {\n                    if (++lastM > 12) {\n                        ++lastY;\n                        lastM = 1;\n                    }\n\n                    ++i;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely transfers reward to a user address\n     *\n     * @param _token  Reward token address\n     * @param _to     Address to send reward to\n     * @param _amount Amount to send\n     */\n    function _safeRewardTransfer(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n\n        if (_amount > balance) {\n            actualAmount = balance;\n        } else {\n            actualAmount = _amount;\n        }\n\n        // Check the balance before and after the transfer\n        // to check the final actual amount\n        uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(_to, actualAmount);\n        uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\n\n        actualAmount = balanceBefore - balanceAfter;\n    }\n\n    /**\n     * @notice Returns the index of Cover Right token given a pool id and crtoken address\n     *\n     *         If the token is not supported, revert with an error (to avoid return default value as 0)\n     *\n     * @param _id    Pool id\n     * @param _token LP token address\n     *\n     * @return index Index of the token in the pool\n     */\n    function _getIndex(uint256 _id, address _token)\n        internal\n        view\n        returns (uint256 index)\n    {\n        if (!supportedToken(_id, _token))\n            revert WeightedFarmingPool__NotSupported();\n\n        index = tokenIndex[_id][_token];\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "src/libraries/DateTime.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary DateTimeLibrary {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 constant SECONDS_PER_MINUTE = 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    uint256 constant DOW_MON = 1;\n    uint256 constant DOW_TUE = 2;\n    uint256 constant DOW_WED = 3;\n    uint256 constant DOW_THU = 4;\n    uint256 constant DOW_FRI = 5;\n    uint256 constant DOW_SAT = 6;\n    uint256 constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   https://aa.usno.navy.mil/faq/JD_formula.html\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 _days) {\n        require(year >= 1970);\n        int256 _year = int256(year);\n        int256 _month = int256(month);\n        int256 _day = int256(day);\n\n        int256 __days = _day -\n            32075 +\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\n            4 +\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\n            12 -\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\n            4 -\n            OFFSET19700101;\n\n        _days = uint256(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n\n    function timestampFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n\n    function timestampFromDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 timestamp) {\n        timestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            hour *\n            SECONDS_PER_HOUR +\n            minute *\n            SECONDS_PER_MINUTE +\n            second;\n    }\n\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isLeapYear(uint256 timestamp)\n        internal\n        pure\n        returns (bool leapYear)\n    {\n        (uint256 year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n\n    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n\n    function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n\n    function getDaysInMonth(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 daysInMonth)\n    {\n        (uint256 year, uint256 month, ) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n\n    function _getDaysInMonth(uint256 year, uint256 month)\n        internal\n        pure\n        returns (uint256 daysInMonth)\n    {\n        if (\n            month == 1 ||\n            month == 3 ||\n            month == 5 ||\n            month == 7 ||\n            month == 8 ||\n            month == 10 ||\n            month == 12\n        ) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 dayOfWeek)\n    {\n        uint256 _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = ((_days + 3) % 7) + 1;\n    }\n\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getDay(uint256 timestamp) internal pure returns (uint256 day) {\n        (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getHour(uint256 timestamp) internal pure returns (uint256 hour) {\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n\n    function getMinute(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 minute)\n    {\n        uint256 secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n\n    function getSecond(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 second)\n    {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint256 timestamp, uint256 _years)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        year += _years;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp >= timestamp);\n    }\n\n    function addMonths(uint256 timestamp, uint256 _months)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        month += _months;\n        year += (month - 1) / 12;\n        month = ((month - 1) % 12) + 1;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp >= timestamp);\n    }\n\n    function addDays(uint256 timestamp, uint256 _days)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addHours(uint256 timestamp, uint256 _hours)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addMinutes(uint256 timestamp, uint256 _minutes)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addSeconds(uint256 timestamp, uint256 _seconds)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    /**\n     * @notice Get the expiry timestamp based on cover duration\n     *\n     * @param _now           Current timestamp\n     * @param _coverDuration Months to cover: 1-3\n     */\n    function _getExpiry(uint256 _now, uint256 _coverDuration)\n        internal\n        pure\n        returns (\n            uint256 endTimestamp,\n            uint256 year,\n            uint256 month\n        )\n    {\n        // Get the day of the month\n        (, , uint256 day) = timestampToDate(_now);\n\n        // Cover duration of 1 month means current month\n        // unless today is the 25th calendar day or later\n        uint256 monthsToAdd = _coverDuration - 1;\n\n        // TODO: whether need this auto-extending feature\n        if (day >= 25) {\n            // Add one month\n            monthsToAdd += 1;\n        }\n\n        return _getFutureMonthEndTime(_now, monthsToAdd);\n    }\n\n    /**\n     * @notice Get the end timestamp of a future month\n     *\n     * @param _timestamp   Current timestamp\n     * @param _monthsToAdd Months to be added\n     *\n     * @return endTimestamp End timestamp of a future month\n     */\n    function _getFutureMonthEndTime(uint256 _timestamp, uint256 _monthsToAdd)\n        private\n        pure\n        returns (\n            uint256 endTimestamp,\n            uint256 year,\n            uint256 month\n        )\n    {\n        uint256 futureTimestamp = addMonths(_timestamp, _monthsToAdd);\n\n        return _getMonthEndTimestamp(futureTimestamp);\n    }\n\n    /**\n     * @notice Get the last second of a month\n     *\n     * @param _timestamp Timestamp to be calculated\n     *\n     * @return endTimestamp End timestamp of the month\n     */\n    function _getMonthEndTimestamp(uint256 _timestamp)\n        private\n        pure\n        returns (\n            uint256 endTimestamp,\n            uint256 year,\n            uint256 month\n        )\n    {\n        // Get the year and month from the date\n        (year, month, ) = timestampToDate(_timestamp);\n\n        // Count the total number of days of that month and year\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n\n        // Get the month end timestamp\n        endTimestamp = timestampFromDateTime(\n            year,\n            month,\n            daysInMonth,\n            23,\n            59,\n            59\n        );\n    }\n}\n"
    },
    "src/reward/farming/WeightedFarmingPoolEventError.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nabstract contract WeightedFarmingPoolEventError {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event PoolAdded(uint256 poolId, address token);\n    event NewTokenAdded(\n        uint256 indexed poolId,\n        address token,\n        uint256 index,\n        uint256 weight\n    );\n    event PoolUpdated(uint256 indexed poolId, uint256 accRewardPerShare);\n    event Harvest(\n        uint256 indexed poolId,\n        address indexed user,\n        address indexed receiver,\n        uint256 reward\n    );\n    event PoolWeightUpdated(\n        uint256 indexed poolId,\n        uint256 index,\n        uint256 newWeight\n    );\n    event RewardSpeedUpdated(\n        uint256 indexed poolId,\n        uint256 newSpeed,\n        uint256[] yearsUpdated,\n        uint256[] monthsUpdateed\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error WeightedFarmingPool_ZeroAddress();\n    error WeightedFarmingPool__AlreadySupported();\n    error WeightedFarmingPool__WrongDateLength();\n    error WeightedFarmingPool__ZeroAmount();\n    error WeightedFarmingPool__InexistentPool();\n    error WeightedFarmingPool__OnlyPolicyCenter();\n    error WeightedFarmingPool__NotInPool();\n    error WeightedFarmingPool__NotEnoughAmount();\n    error WeightedFarmingPool__NotSupported();\n}\n"
    },
    "src/reward/farming/WeightedFarmingPoolDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nabstract contract WeightedFarmingPoolDependencies {\n    address public policyCenter;\n\n    address public priorityPoolFactory;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "src/pools/protectionPool/ProtectionPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"./ProtectionPoolDependencies.sol\";\nimport \"./ProtectionPoolEventError.sol\";\nimport \"../../interfaces/ExternalTokenDependencies.sol\";\n\nimport \"../../util/OwnableWithoutContextUpgradeable.sol\";\nimport \"../../util/PausableWithoutContextUpgradeable.sol\";\nimport \"../../util/FlashLoanPool.sol\";\n\nimport \"../../libraries/DateTime.sol\";\n\n/**\n * @title Protection Pool\n *\n * @author Eric Lee (ylikp.ust@gmail.com) & Primata (primata@375labs.org)\n *\n * @notice This is the protection pool contract for Degis Protocol Protection\n *\n *         Users can provide liquidity to protection pool and get PRO-LP token\n *\n *         If the priority pool is unable to fulfil the cover amount,\n *         Protection Pool will be able to provide the remaining part\n */\n\ncontract ProtectionPool is\n    ProtectionPoolEventError,\n    ERC20Upgradeable,\n    FlashLoanPool,\n    OwnableWithoutContextUpgradeable,\n    PausableWithoutContextUpgradeable,\n    ExternalTokenDependencies,\n    ProtectionPoolDependencies\n{\n    using DateTimeLibrary for uint256;\n\n    address public constant USDC = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Pool start time\n    uint256 public startTime;\n\n    // Last pool reward distribution\n    uint256 public lastRewardTimestamp;\n\n    // PRO_LP token price\n    uint256 public price;\n\n    // Total amount staked\n    uint256 public stakedSupply;\n\n    // Year => Month => Speed\n    mapping(uint256 => mapping(uint256 => uint256)) public rewardSpeed;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(\n        address _deg,\n        address _veDeg\n    ) public initializer {\n        __ERC20_init(\"ProtectionPool\", \"PRO-LP\");\n        __FlashLoan__Init(USDC);\n        __Ownable_init();\n        __Pausable_init();\n        __ExternalToken__Init(_deg, _veDeg);\n\n        // Register time that pool was deployed\n        startTime = block.timestamp;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    modifier onlyPolicyCenter() {\n        if (msg.sender != policyCenter)\n            revert ProtectionPool__OnlyPolicyCenter();\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get total active cover amount of all pools\n     *         Only calculate those \"already dynamic\" pools\n     *\n     * @return activeCovered Covered amount\n     */\n    function getTotalActiveCovered()\n        public\n        view\n        returns (uint256 activeCovered)\n    {\n        IPriorityPoolFactory factory = IPriorityPoolFactory(\n            priorityPoolFactory\n        );\n\n        uint256 poolAmount = factory.poolCounter();\n\n        for (uint256 i; i < poolAmount; ) {\n            (, address poolAddress, , , ) = factory.pools(i + 1);\n\n            if (factory.dynamic(poolAddress)) {\n                activeCovered += IPriorityPool(poolAddress).activeCovered();\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function getTotalCovered() public view returns (uint256 totalCovered) {\n        IPriorityPoolFactory factory = IPriorityPoolFactory(\n            priorityPoolFactory\n        );\n\n        uint256 poolAmount = factory.poolCounter();\n\n        for (uint256 i; i < poolAmount; ) {\n            (, address poolAddress, , , ) = factory.pools(i + 1);\n\n            totalCovered += IPriorityPool(poolAddress).activeCovered();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // @audit change decimal\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function setIncidentReport(address _incidentReport) external onlyOwner {\n        incidentReport = _incidentReport;\n    }\n\n    function setPolicyCenter(address _policyCenter) external onlyOwner {\n        policyCenter = _policyCenter;\n    }\n\n    function setPriorityPoolFactory(address _priorityPoolFactory)\n        external\n        onlyOwner\n    {\n        priorityPoolFactory = _priorityPoolFactory;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Update index cut when claim happened\n     */\n    function updateIndexCut() public {\n        IPriorityPoolFactory factory = IPriorityPoolFactory(\n            priorityPoolFactory\n        );\n\n        uint256 poolAmount = factory.poolCounter();\n\n        uint256 currentReserved = SimpleIERC20(USDC).balanceOf(address(this));\n\n        uint256 indexToCut;\n        uint256 minRequirement;\n\n        for (uint256 i; i < poolAmount; ) {\n            (, address poolAddress, , , ) = factory.pools(i + 1);\n\n            minRequirement = IPriorityPool(poolAddress).minAssetRequirement();\n\n            if (minRequirement > currentReserved) {\n                indexToCut = (currentReserved * 10000) / minRequirement;\n                IPriorityPool(poolAddress).setCoverIndex(indexToCut);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Updates and retrieves latest price to provide liquidity to Protection Pool\n     */\n    function getLatestPrice() external returns (uint256) {\n        _updatePrice();\n        return price;\n    }\n\n    /**\n     * @notice Finish providing liquidity\n     *         Only callable through policyCenter\n     *\n     * @param _amount   Liquidity amount (usdc)\n     * @param _provider Provider address\n     */\n    function providedLiquidity(uint256 _amount, address _provider)\n        external\n        onlyPolicyCenter\n    {\n        _updatePrice();\n\n        // Mint PRO_LP tokens to the user\n        uint256 amountToMint = (_amount * SCALE) / price;\n        _mint(_provider, amountToMint);\n        emit LiquidityProvided(_amount, amountToMint, _provider);\n    }\n\n    /**\n     * @notice Finish removing liquidity\n     *         Only callable through \n     *         1) policyCenter (by user removing liquidity)\n     *         2) \n     *         \n     *\n     * @param _amount   Liquidity to remove (LP token amount)\n     * @param _provider Provider address\n     */\n    function removedLiquidity(uint256 _amount, address _provider)\n        external\n        whenNotPaused\n        returns (uint256 usdcToTransfer)\n    {\n        if (\n            msg.sender != policyCenter &&\n            !IPriorityPoolFactory(priorityPoolFactory).poolRegistered(\n                msg.sender\n            )\n        ) revert ProtectionPool__OnlyPriorityPoolOrPolicyCenter();\n\n        if (_amount > totalSupply())\n            revert ProtectionPool__ExceededTotalSupply();\n\n        _updatePrice();\n\n        // Burn PRO_LP tokens to the user\n        usdcToTransfer = (_amount * price) / SCALE;\n\n        if (msg.sender == policyCenter) {\n            checkEnoughLiquidity(usdcToTransfer);\n        }\n\n        // @audit Change path\n        // If sent from policyCenter => this is a user action\n        // If sent from priority pool => this is a payout action\n        address realPayer = msg.sender == policyCenter ? _provider : msg.sender;\n\n        _burn(realPayer, _amount);\n        SimpleIERC20(USDC).transfer(_provider, usdcToTransfer);\n\n        emit LiquidityRemoved(_amount, usdcToTransfer, _provider);\n    }\n\n    function checkEnoughLiquidity(uint256 _amountToRemove) public view {\n        // Minimum usdc requirement\n        uint256 minRequirement = minAssetRequirement();\n\n        uint256 currentReserved = SimpleIERC20(USDC).balanceOf(address(this));\n\n        if (currentReserved < minRequirement + _amountToRemove)\n            revert ProtectionPool__NotEnoughLiquidity();\n    }\n\n    function minAssetRequirement()\n        public\n        view\n        returns (uint256 minRequirement)\n    {\n        IPriorityPoolFactory factory = IPriorityPoolFactory(\n            priorityPoolFactory\n        );\n\n        uint256 poolAmount = factory.poolCounter();\n        uint256 minRequirementForPool;\n\n        for (uint256 i; i < poolAmount; ) {\n            (, address poolAddress, , , ) = factory.pools(i + 1);\n\n            minRequirementForPool = IPriorityPool(poolAddress)\n                .minAssetRequirement();\n\n            minRequirement = minRequirementForPool > minRequirement\n                ? minRequirementForPool\n                : minRequirement;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Removes liquidity when a claim is made\n     *\n     * @param _amount Amount of liquidity to remove\n     * @param _to     Address to transfer the liquidity to\n     */\n    function removedLiquidityWhenClaimed(uint256 _amount, address _to)\n        external\n    {\n        if (\n            !IPriorityPoolFactory(priorityPoolFactory).poolRegistered(\n                msg.sender\n            )\n        ) revert ProtectionPool__OnlyPriorityPool();\n\n        if (_amount > SimpleIERC20(USDC).balanceOf(address(this)))\n            revert ProtectionPool__NotEnoughBalance();\n\n        SimpleIERC20(USDC).transfer(_to, _amount);\n\n        _updatePrice();\n\n        emit LiquidityRemovedWhenClaimed(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Update when new cover is bought\n     */\n    function updateWhenBuy() external onlyPolicyCenter {\n        _updatePrice();\n    }\n\n    /**\n     * @notice Set paused state of the protection pool\n     *         Only callable by owner, incidentReport, or priorityPoolFactory\n     *\n     * @param _paused True for pause, false for unpause\n     */\n    function pauseProtectionPool(bool _paused) external {\n        if (\n            (msg.sender != owner()) &&\n            (msg.sender != incidentReport) &&\n            (msg.sender != priorityPoolFactory)\n        ) revert ProtectionPool__NotAllowedToPause();\n        _pause(_paused);\n    }\n\n    function updateStakedSupply(bool _isStake, uint256 _amount)\n        external\n        onlyPolicyCenter\n    {\n        if (_isStake) {\n            stakedSupply += _amount;\n        } else stakedSupply -= _amount;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Update the price of PRO_LP token\n     */\n    function _updatePrice() internal {\n        if (totalSupply() == 0) {\n            price = SCALE;\n            return;\n        }\n        price =\n            ((SimpleIERC20(USDC).balanceOf(address(this))) * SCALE) /\n            totalSupply();\n\n        emit PriceUpdated(price);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "src/pools/protectionPool/ProtectionPoolDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/CommonDependencies.sol\";\n\ninterface IPriorityPoolFactory {\n    function poolCounter() external view returns (uint256);\n\n    function pools(uint256 _poolId)\n        external\n        view\n        returns (\n            string memory name,\n            address poolAddress,\n            address protocolToken,\n            uint256 maxCapacity,\n            uint256 basePremiumRatio\n        );\n\n    function poolRegistered(address) external view returns (bool);\n\n    function dynamic(address) external view returns (bool);\n}\n\ninterface IPriorityPool {\n    function setCoverIndex(uint256 _newIndex) external;\n\n    function minAssetRequirement() external view returns (uint256);\n\n    function activeCovered() external view returns (uint256);\n}\n\nabstract contract ProtectionPoolDependencies {\n    address public priorityPoolFactory;\n    address public policyCenter;\n    address public incidentReport;\n}\n"
    },
    "src/pools/protectionPool/ProtectionPoolEventError.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface ProtectionPoolEventError {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event LiquidityProvided(\n        uint256 usdcAmount,\n        uint256 lpAmount,\n        address sender\n    );\n    event LiquidityRemoved(\n        uint256 lpAmount,\n        uint256 usdcAmount,\n        address sender\n    );\n\n    event LiquidityRemovedWhenClaimed(address pool, uint256 amount);\n\n    event RewardUpdated(uint256 totalReward);\n\n    event PriceUpdated(uint256 price);\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error ProtectionPool__OnlyPolicyCenter();\n    error ProtectionPool__ExceededTotalSupply();\n    error ProtectionPool__OnlyPriorityPool();\n    error ProtectionPool__NotEnoughLiquidity();\n    error ProtectionPool__OnlyPriorityPoolOrPolicyCenter();\n    error ProtectionPool__NotEnoughBalance();\n    error ProtectionPool__NotAllowedToPause();\n\n}"
    },
    "src/util/PausableWithoutContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nabstract contract PausableWithoutContextUpgradeable is Initializable {\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Paused\");\n        _;\n    }\n\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    function _pause(bool _p) internal virtual {\n        _paused = _p;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "src/util/FlashLoanPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\n\nabstract contract FlashLoanPool is IERC3156FlashLender, Initializable {\n    address public token;\n\n    // 10000 = 100%\n    uint256 public constant FEE = 10;\n\n    event FlashLoanBorrowed(\n        address indexed lender,\n        address indexed borrower,\n        address indexed stablecoin,\n        uint256 amount,\n        uint256 fee\n    );\n\n    function __FlashLoan__Init(address _usdc) internal onlyInitializing {\n        token = _usdc;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_amount > 0, \"Zero amount\");\n\n        uint256 fee = flashFee(_token, _amount);\n\n        uint256 previousBalance = IERC20(_token).balanceOf(address(this));\n\n        IERC20(_token).transfer(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                keccak256(\"ERC3156FlashBorrower.onFlashLoan\"),\n            \"IERC3156: Callback failed\"\n        );\n        IERC20(_token).transferFrom(\n            address(_receiver),\n            address(this),\n            _amount + fee\n        );\n\n        uint256 finalBalance = IERC20(_token).balanceOf(address(this));\n        require(finalBalance >= previousBalance + fee, \"Not enough pay back\");\n\n        emit FlashLoanBorrowed(\n            address(this),\n            address(_receiver),\n            _token,\n            _amount,\n            fee\n        );\n\n        return true;\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == token, \"Only usdc\");\n        return (_amount * FEE) / 10000;\n    }\n\n    function maxFlashLoan(address _token) external view returns (uint256) {\n        require(_token == token, \"only usdc\");\n        return IERC20(token).balanceOf(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"IERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "src/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation()\n        external\n        ifAdmin\n        returns (address implementation_)\n    {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        external\n        payable\n        ifAdmin\n    {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(\n            msg.sender != _getAdmin(),\n            \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\"\n        );\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "src/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    constructor() Ownable() {}\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy)\n        public\n        view\n        virtual\n        returns (address)\n    {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\n            hex\"5c60da1b\"\n        );\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy)\n        public\n        view\n        virtual\n        returns (address)\n    {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\n            hex\"f851a440\"\n        );\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(\n        TransparentUpgradeableProxy proxy,\n        address newAdmin\n    ) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation)\n        public\n        virtual\n        onlyOwner\n    {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/mock/MockVeDEG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockVeDEG is ERC20 {\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n\n    uint8 public _decimals; //How many decimals to show.\n\n    mapping(address => uint256) public locked;\n\n    mapping(address => bool) public alreadyMinted;\n\n    address public owner;\n\n    constructor(\n        uint256 _initialAmount,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol\n    ) ERC20(_tokenName, _tokenSymbol) {\n        require(_decimalUnits == 18);\n\n        _mint(msg.sender, _initialAmount);\n\n        _decimals = _decimalUnits; // Amount of decimals for display purposes\n\n        owner = msg.sender;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function mint(address _user, uint256 _amount) public {\n        if (msg.sender != owner) {\n            require(_amount == 10000 ether, \"Wrong amount\");\n            require(!alreadyMinted[_user], \"Already minted\");\n        }\n        alreadyMinted[_user] = true;\n        _mint(_user, _amount);\n    }\n\n    function lockVeDEG(address _owner, uint256 _value) public {\n        locked[_owner] += _value;\n    }\n\n    function unlockVeDEG(address _owner, uint256 _value) public {\n        locked[_owner] -= _value;\n    }\n}\n"
    },
    "src/mock/MockUSDC.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockUSDC is ERC20 {\n    uint8 private _decimals;\n\n    address public owner;\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _decimal\n    ) ERC20(_name, _symbol) {\n        require(_decimal == 6);\n\n        owner = msg.sender;\n\n        _decimals = uint8(_decimal);\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        require(msg.sender == owner);\n\n        _mint(_to, _amount);\n    }\n\n    function burn(address _to, uint256 _amount) external {\n        require(msg.sender == owner);\n\n        _burn(_to, _amount);\n    }\n}\n"
    },
    "src/mock/MockSHIELD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockSHIELD is ERC20 {\n    event Deposit(address indexed _from, uint256 _value);\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n\n    uint8 public _decimals; //How many decimals to show.\n\n    mapping(address => bool) public alreadyMinted;\n\n    address public owner;\n\n    constructor(\n        uint256 _initialAmount,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol\n    ) ERC20(_tokenName, _tokenSymbol) {\n        require(_decimalUnits == 6);\n\n        _mint(msg.sender, _initialAmount);\n\n        owner = msg.sender;\n\n        _decimals = _decimalUnits; // Amount of decimals for display purposes\n    }\n\n    function mint(address _to, uint256 _amount) public {\n        if (msg.sender != owner) {\n            require(_amount == 10000 * 10**6, \"Wrong amount\");\n            require(!alreadyMinted[_to], \"Already minted\");\n        }\n\n        alreadyMinted[_to] = true;\n        _mint(_to, _amount);\n    }\n\n    function burn(address _to, uint256 _amount) public {\n        require(msg.sender == owner, \"Only owner\");\n\n        _burn(_to, _amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function deposit(\n        uint256 _type,\n        address _token,\n        uint256 _transfer,\n        uint256 _minReceive\n    ) public {\n        if (_type == 1) {\n            _mint(msg.sender, _minReceive);\n            IERC20(_token).transferFrom(msg.sender, address(this), _transfer);\n        } else revert(\"Wrong type\");\n    }\n}\n"
    },
    "src/mock/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    uint256 public constant MAX_HOLD = 10000 ether;\n\n    uint8 private _decimals;\n\n    address public owner;\n\n    mapping(address => uint256) alreadyMinted;\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _decimal\n    ) ERC20(_name, _symbol) {\n        _decimals = uint8(_decimal);\n\n        owner = msg.sender;\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        if (msg.sender != owner) {\n            require(alreadyMinted[_to] + _amount <= MAX_HOLD);\n        }\n\n        alreadyMinted[_to] += _amount;\n        _mint(_to, _amount);\n    }\n\n    function burn(address _to, uint256 _amount) external {\n        require(msg.sender == owner);\n        alreadyMinted[_to] -= _amount;\n        _burn(_to, _amount);\n    }\n}\n"
    },
    "src/mock/MockDEG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockDEG is ERC20 {\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n\n    uint8 public _decimals; //How many decimals to show\n\n    mapping(address => bool) public alreadyMinted;\n\n    address public owner;\n\n    constructor(\n        uint256 _initialAmount,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol\n    ) ERC20(_tokenName, _tokenSymbol) {\n        require(_decimalUnits == 18);\n\n        _mint(msg.sender, _initialAmount);\n\n        owner = msg.sender;\n\n        _decimals = _decimalUnits; // Amount of decimals for display purposes\n    }\n\n    /**\n     * @notice Free mint\n     */\n    function mintDegis(address _account, uint256 _amount) external {\n        _mint(_account, _amount);\n    }\n\n    /**\n     * @notice This is for frontend mint\n     */\n    function mint(address _account, uint256 _amount) external {\n        if (msg.sender != owner) {\n            require(_amount == 100 ether, \"Wrong amount\");\n            require(!alreadyMinted[_account], \"Already minted\");\n        }\n\n        alreadyMinted[_account] = true;\n        _mint(_account, _amount);\n    }\n\n    function burnDegis(address _account, uint256 _amount) external {\n        _burn(_account, _amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "src/crTokens/CoverRightToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../util/OwnableWithoutContext.sol\";\n\nimport \"../interfaces/IIncidentReport.sol\";\n\nimport \"../libraries/DateTime.sol\";\n\n/**\n * @notice Cover Right Tokens\n *\n *         ERC20 tokens that represent the cover you bought\n *         It is a special token:\n *             1) Can not be transferred to other addresses\n *             2) Has an expiry date\n *\n *         A new crToken will be deployed for each month's policies for a pool\n *         Each crToken will ended at the end timestamp of each month\n *\n *         To calculate a user's balance, we use coverFrom to record it.\n *         E.g.  CRToken CR-JOE-2022-8\n *               You bought X amount at timestamp t1 (in 2022-6 ~ 2022-8)\n *               coverStartFrom[yourAddress][t1] += X\n *\n *         When used for claiming, check your crTokens\n *             1) Not expired\n *             2) Not bought too close to the report timestamp\n *\n */\ncontract CoverRightToken is ERC20, ReentrancyGuard {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Generation of crToken\n    // Same as the generation of the priority pool (when this token was deployed)\n    uint256 public immutable generation;\n\n    // Expiry date (always the last timestamp of a month)\n    uint256 public immutable expiry;\n\n    // Pool id for this crToken\n    uint256 public immutable poolId;\n\n    // Those covers bought within 2 days will be excluded\n    // TODO: test will set it as 0\n    uint256 public constant EXCLUDE_DAYS = 2;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Policy center address\n    address public policyCenter;\n\n    // Incident report address\n    address public incidentReport;\n\n    // Payout pool address\n    address public payoutPool;\n\n    // Pool name for this crToken\n    string public poolName;\n\n    // User address => start timestamp => cover amount\n    mapping(address => mapping(uint256 => uint256)) public coverStartFrom;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(\n        string memory _poolName,\n        uint256 _poolId,\n        string memory _name,\n        uint256 _expiry,\n        uint256 _generation,\n        address _policyCenter,\n        address _incidentReport,\n        address _payoutPool\n    ) ERC20(_name, \"crToken\") {\n        expiry = _expiry;\n\n        poolName = _poolName;\n        poolId = _poolId;\n        generation = _generation;\n\n        policyCenter = _policyCenter;\n        incidentReport = _incidentReport;\n        payoutPool = _payoutPool;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Only called from permitted addresses\n     *\n     *         Permitted addresses:\n     *            1) Policy center\n     *            2) Payout pool\n     *\n     *         For policyCenter, when deploying new crTokens, the policyCenter address is still not initialized,\n     *         so we only skip the test when policyCenter is address(0)\n     */\n    modifier onlyPermitted() {\n        if (policyCenter != address(0)) {\n            require(\n                msg.sender == policyCenter || msg.sender == payoutPool,\n                \"Not permitted\"\n            );\n        }\n        _;\n    }\n\n    /**\n     * @notice Override the decimals funciton\n     *\n     *         Cover right token is minted with reference to the cover amount he bought\n     *         So keep the decimals the same with USDC\n     */\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint new crTokens when buying covers\n     *\n     * @param _poolId Pool id\n     * @param _user   User address\n     * @param _amount Amount to mint\n     */\n    function mint(\n        uint256 _poolId,\n        address _user,\n        uint256 _amount\n    ) external onlyPermitted nonReentrant {\n        require(_amount > 0, \"Zero Amount\");\n        require(_poolId == poolId, \"Wrong pool id\");\n\n        // uint256 effectiveFrom = _getEOD(\n        //     block.timestamp + EXCLUDE_DAYS * 1 days\n        // );\n\n        // Start from today's last timestamp\n        uint256 effectiveFrom = _getEOD(block.timestamp);\n\n        coverStartFrom[_user][effectiveFrom] += _amount;\n\n        _mint(_user, _amount);\n    }\n\n    /**\n     * @notice Burn crTokens to claim\n     *         Only callable from policyCenter\n     *\n     * @param _poolId Pool id\n     * @param _user   User address\n     * @param _amount Amount to burn\n     */\n    function burn(\n        uint256 _poolId,\n        address _user,\n        uint256 _amount\n    ) external onlyPermitted nonReentrant {\n        require(_amount > 0, \"Zero Amount\");\n        require(_poolId == poolId, \"Wrong pool id\");\n\n        _burn(_user, _amount);\n    }\n\n    /**\n     * @notice Get the claimable amount of a user\n     *         Claimable means \"without those has passed the expiry date\"\n     *\n     * @param _user User address\n     *\n     * @return claimable Claimable balance\n     */\n    function getClaimableOf(address _user) external view returns (uint256) {\n        uint256 exclusion = getExcludedCoverageOf(_user);\n        uint256 balance = balanceOf(_user);\n\n        if (exclusion > balance) return 0;\n        else return balance - exclusion;\n    }\n\n    /**\n     * @notice Get the excluded amount of a user\n     *         Excluded means \"without those are bought within a short time before voteTimestamp\"\n     *\n     *         Only count the corresponding one report (voteTimestamp)\n     *         Each crToken & priorityPool has a generation\n     *         And should get the correct report with this \"Generation\"\n     *             - poolReports(poolId, generation)\n     *\n     * @param _user User address\n     *\n     * @return exclusion Amount not able to claim because cover period has ended\n     */\n    function getExcludedCoverageOf(address _user)\n        public\n        view\n        returns (uint256 exclusion)\n    {\n        IIncidentReport incident = IIncidentReport(incidentReport);\n\n        // Get the report amount for this pool\n        // If report amount is 0, generation should be 1 and no excluded amount\n        // If report amount > 0, the effective report should be amount - 1\n        uint256 reportAmount = incident.getPoolReportsAmount(poolId);\n\n        if (reportAmount > 0 && generation <= reportAmount) {\n            // Only count for the valid report\n            // E.g. Current report amount is 3, then for generation 1 crToken,\n            //      its corresponding report index (in the array) is 0\n            uint256 validReportId = incident.poolReports(\n                poolId,\n                generation - 1\n            );\n\n            (, , , uint256 voteTimestamp, , , , , uint256 result, , ) = incident\n                .reports(validReportId);\n\n            // If the result is not PASS, the voteTimestamp should not be counted\n            if (result == 1) {\n                // Check those bought within 2 days\n                for (uint256 i; i < EXCLUDE_DAYS; ) {\n                    if (voteTimestamp > i * 1 days) {\n                        // * For local test EXCLUDE_DAYS can be set as 0 to avoid underflow\n                        // * For mainnet or testnet, will never underflow\n                        uint256 date = _getEOD(voteTimestamp - (i * 1 days));\n\n                        exclusion += coverStartFrom[_user][date];\n                    }\n                    unchecked {\n                        ++i;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Get the timestamp at the end of the day\n     *\n     * @param _timestamp Timestamp to be transformed\n     *\n     * @return endTimestamp End timestamp of that day\n     */\n    function _getEOD(uint256 _timestamp) private pure returns (uint256) {\n        (uint256 year, uint256 month, uint256 day) = DateTimeLibrary\n            .timestampToDate(_timestamp);\n        return\n            DateTimeLibrary.timestampFromDateTime(year, month, day, 23, 59, 59);\n    }\n\n    /**\n     * @notice Hooks before token transfer\n     *         - Can burn expired crTokens (send to zero address)\n     *         - Can be minted or used for claim\n     *         Other transfers are banned\n     *\n     * @param from From address\n     * @param to   To address\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256\n    ) internal view override {\n        if (block.timestamp > expiry) {\n            require(to == address(0), \"Expired crToken\");\n        }\n\n        // crTokens can only be used for claim\n        if (from != address(0) && to != address(0)) {\n            require(to == policyCenter, \"Only to policyCenter\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "src/util/OwnableWithoutContext.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nabstract contract OwnableWithoutContext {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting a customized initial owner.\n     */\n    constructor(address _initOwner) {\n        _owner = _initOwner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Only owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() external onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal {\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "src/interfaces/IIncidentReport.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IIncidentReport {\n    struct Report {\n        uint256 poolId; // Project pool id\n        uint256 reportTimestamp; // Time of starting report\n        address reporter; // Reporter address\n        uint256 voteTimestamp; // Voting start timestamp\n        uint256 numFor; // Votes voting for\n        uint256 numAgainst; // Votes voting against\n        uint256 round; // 0: Initial round 3 days, 1: Extended round 1 day, 2: Double extended 1 day\n        uint256 status; // 0: INIT, 1: PENDING, 2: VOTING, 3: SETTLED, 404: CLOSED\n        uint256 result; // 1: Pass, 2: Reject, 3: Tied\n        uint256 votingReward; // Voting reward per veDEG\n        uint256 payout; // Payout amount of this report (partial payout)\n    }\n\n    struct TempResult {\n        uint256 a;\n        uint256 b;\n        bool c;\n    }\n    struct UserVote {\n        uint256 choice;\n        uint256 amount;\n        bool claimed;\n    }\n\n    /**\n     * @notice Cool down period when you submit a wrong report\n     *         Wrong Report: Closed by the Admin team\n     *\n     * @return COOLDOWN_WRONG_REPORT Cooldown time in second (before you can submit another report)\n     */\n    function COOLDOWN_WRONG_REPORT() external view returns (uint256);\n\n    /**\n     * @notice Claim reward\n     *         Users can claim reward when they vote correctly\n     *\n     * @param _reportId Report id\n     */\n    function claimReward(uint256 _reportId) external;\n\n    /**\n     * @notice Close a report\n     *         Only callable by the owner\n     *\n     * @param _reportId Report id\n     */\n    function closeReport(uint256 _reportId) external;\n\n    function deg() external view returns (address);\n\n    function executor() external view returns (address);\n\n    function getReport(uint256 _id) external view returns (Report memory);\n\n    function getTempResult(uint256 _id)\n        external\n        view\n        returns (TempResult memory);\n\n    function getUserVote(address _user, uint256 _id)\n        external\n        view\n        returns (UserVote memory);\n\n    function incidentReport() external view returns (address);\n\n    function priorityPoolFactory() external view returns (address);\n\n    function onboardProposal() external view returns (address);\n\n    function owner() external view returns (address);\n\n    function payDebt(uint256 _reportId, address _user) external;\n\n    function policyCenter() external view returns (address);\n\n    function poolReported(address) external view returns (bool);\n\n    function protectionPool() external view returns (address);\n\n    function renounceOwnership() external;\n\n    function report(\n        uint256 _poolId,\n        uint256 _payout,\n        address _user\n    ) external;\n\n    function reportCounter() external view returns (uint256);\n\n    function reportTempResults(uint256)\n        external\n        view\n        returns (\n            uint256 result,\n            uint256 sampleTimestamp,\n            bool hasChanged\n        );\n\n    function reports(uint256)\n        external\n        view\n        returns (\n            uint256 poolId,\n            uint256 reportTimestamp,\n            address reporter,\n            uint256 voteTimestamp,\n            uint256 numFor,\n            uint256 numAgainst,\n            uint256 round,\n            uint256 status,\n            uint256 result,\n            uint256 votingReward,\n            uint256 payout\n        );\n\n    function setExecutor(address _executor) external;\n\n    function setIncidentReport(address _incidentReport) external;\n\n    function setPriorityPoolFactory(address _priorityPoolFactory) external;\n\n    function setOnboardProposal(address _onboardProposal) external;\n\n    function setPolicyCenter(address _policyCenter) external;\n\n    function setProtectionPool(address _protectionPool) external;\n\n    function settle(uint256 _reportId) external;\n\n    function startVoting(uint256 _reportId) external;\n\n    function transferOwnership(address newOwner) external;\n\n    function unpausePools(uint256 _poolId) external;\n\n    function userCoolDownUntil(address) external view returns (uint256);\n\n    function votes(address, uint256)\n        external\n        view\n        returns (\n            uint256 choice,\n            uint256 amount,\n            bool claimed\n        );\n\n    function veDeg() external view returns (address);\n\n    function vote(\n        uint256 _reportId,\n        uint256 _isFor,\n        uint256 _amount,\n        address _user\n    ) external;\n\n    function poolReports(uint256 _poolId, uint256 _index)\n        external\n        view\n        returns (uint256);\n\n    function getPoolReportsAmount(uint256 _poolId)\n        external\n        view\n        returns (uint256);\n\n    function executed(uint256 _reportId) external;\n}\n"
    },
    "src/crTokens/CoverRightTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"./CoverRightToken.sol\";\nimport \"../util/OwnableWithoutContextUpgradeable.sol\";\n\n/**\n * @notice Factory for deploying crTokens\n *\n *         Salt as index for cover right tokens:\n *             salt = keccak256(poolId, expiry, genration)\n *\n *         Factory will record whether a crToken has been deployed\n *         Also record the generation of a specific crToken\n *         And find the address of the crToken with its salt\n *\n */\ncontract CoverRightTokenFactory is OwnableWithoutContextUpgradeable {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    address public policyCenter;\n\n    address public incidentReport;\n\n    address public payoutPool;\n\n    // Salt => Already deployed\n    mapping(bytes32 => bool) public deployed;\n\n    // Salt => CR token address\n    mapping(bytes32 => address) public saltToAddress;\n\n    // Salt => Generation\n    mapping(bytes32 => uint256) public generation;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event NewCRTokenDeployed(\n        uint256 poolId,\n        string tokenName,\n        uint256 expiry,\n        uint256 generation,\n        address tokenAddress\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(address _policyCenter, address _incidentReport)\n        public\n        initializer\n    {\n        __Ownable_init();\n\n        policyCenter = _policyCenter;\n        incidentReport = _incidentReport;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get crToken address\n     *\n     * @param _poolId     Pool id\n     * @param _expiry     Expiry timestamp\n     * @param _generation Generation of the crToken\n     *\n     * @return crToken CRToken address\n     */\n    function getCRTokenAddress(\n        uint256 _poolId,\n        uint256 _expiry,\n        uint256 _generation\n    ) external view returns (address crToken) {\n        crToken = saltToAddress[\n            keccak256(abi.encodePacked(_poolId, _expiry, _generation))\n        ];\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function setPayoutPool(address _payoutPool) external onlyOwner {\n        require(_payoutPool != address(0), \"Zero Address\");\n        payoutPool = _payoutPool;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Deploy Cover Right Token for a given pool\n     *\n     * @param _poolName   Name of Priority Pool\n     * @param _poolId     Pool Id\n     * @param _tokenName  Name of insured token (e.g. DEG)\n     * @param _expiry     Expiry date of cover right token\n     * @param _generation Generation of priority pool & crToken (1 if no liquidations occurred)\n     *\n     * @return newCRToken New deployed crToken address\n     */\n    function deployCRToken(\n        string calldata _poolName,\n        uint256 _poolId,\n        string calldata _tokenName,\n        uint256 _expiry,\n        uint256 _generation\n    ) external returns (address newCRToken) {\n        require(msg.sender == policyCenter, \"Only policy center\");\n        require(_expiry > 0, \"Zero expiry date\");\n\n        bytes32 salt = keccak256(\n            abi.encodePacked(_poolId, _expiry, _generation)\n        );\n\n        require(!deployed[salt], \"Already deployed\");\n        deployed[salt] = true;\n\n        bytes memory bytecode = _getCRTokenBytecode(\n            _poolName,\n            _poolId,\n            _tokenName,\n            _expiry,\n            _generation\n        );\n\n        newCRToken = _deploy(bytecode, salt);\n        saltToAddress[salt] = newCRToken;\n\n        emit NewCRTokenDeployed(\n            _poolId,\n            _tokenName,\n            _expiry,\n            _generation,\n            newCRToken\n        );\n    }\n\n    /**\n     * @notice Get cover right token deployment bytecode (with parameters)\n     *\n     * @param _poolName   Name of Priority Pool\n     * @param _poolId     Pool Id\n     * @param _tokenName  Name of insured token (e.g. DEG)\n     * @param _expiry     Expiry date of cover right token\n     * @param _generation Generation of priority pool (1 if no liquidations occurred)\n     */\n    function _getCRTokenBytecode(\n        string memory _poolName,\n        uint256 _poolId,\n        string memory _tokenName,\n        uint256 _expiry,\n        uint256 _generation\n    ) internal view returns (bytes memory code) {\n        bytes memory bytecode = type(CoverRightToken).creationCode;\n\n        require(policyCenter != address(0), \"Zero Address\");\n        require(incidentReport != address(0), \"Zero Address\");\n        require(payoutPool != address(0), \"Zero Address\");\n\n        code = abi.encodePacked(\n            bytecode,\n            abi.encode(\n                _tokenName,\n                _poolId,\n                _poolName,\n                _expiry,\n                _generation,\n                policyCenter,\n                incidentReport,\n                payoutPool\n            )\n        );\n    }\n\n    /**\n     * @notice Deploy function with create2\n     *\n     * @param code Byte code of the contract (creation code)\n     * @param salt Salt for the deployment\n     *\n     * @return addr The deployed contract address\n     */\n    function _deploy(bytes memory code, bytes32 salt)\n        internal\n        returns (address addr)\n    {\n        assembly {\n            addr := create2(0, add(code, 0x20), mload(code), salt)\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "src/reward/treasury/Treasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../../util/OwnableWithoutContextUpgradeable.sol\";\n\nimport \"../../util/SimpleIERC20.sol\";\n\nimport \"./TreasuryDependencies.sol\";\nimport \"./TreasuryEventError.sol\";\n\n/**\n * @notice Treasury Contract\n *\n *         Treasury will receive 5% of the premium income (usdc) from policyCenter.\n *         They are counted as different pools.\n *\n *         When a reporter gives a correct report (passed voting and executed),\n *         he will get 10% of the income of that project pool.\n *\n */\ncontract Treasury is\n    TreasuryEventError,\n    OwnableWithoutContextUpgradeable,\n    TreasuryDependencies\n{\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    uint256 public constant REPORTER_REWARD = 1000; // 10%\n\n    address public constant USDC = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    mapping(uint256 => uint256) public poolIncome;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(\n        address _executor,\n        address _policyCenter\n    ) public initializer {\n        __Ownable_init();\n\n        executor = _executor;\n        policyCenter = _policyCenter;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Reward the correct reporter\n     *\n     *         Part of the priority pool income will be given to the reporter\n     *         Only called from executor when executing a report\n     *\n     * @param _poolId   Pool id\n     * @param _reporter Reporter address\n     */\n    function rewardReporter(uint256 _poolId, address _reporter) external {\n        if (msg.sender != executor) revert Treasury__OnlyExecutor();\n\n        uint256 amount = (poolIncome[_poolId] * REPORTER_REWARD) / 10000;\n\n        poolIncome[_poolId] -= amount;\n        SimpleIERC20(USDC).transfer(_reporter, amount);\n\n        emit ReporterRewarded(_reporter, amount);\n    }\n\n    /**\n     * @notice Record when receiving new premium income\n     *\n     *         Only called from policy center\n     *\n     * @param _poolId Pool id\n     * @param _amount Premium amount (usdc)\n     */\n    function premiumIncome(uint256 _poolId, uint256 _amount) external {\n        if (msg.sender != policyCenter) revert Treasury__OnlyPolicyCenter();\n\n        poolIncome[_poolId] += _amount;\n\n        emit NewIncomeToTreasury(_poolId, _amount);\n    }\n\n    /**\n     * @notice Claim usdc by the owner\n     *\n     * @param _amount Amount to claim\n     */\n    function claim(uint256 _amount) external onlyOwner {\n        SimpleIERC20(USDC).transfer(owner(), _amount);\n\n        emit ClaimedByOwner(_amount);\n    }\n}\n"
    },
    "src/reward/treasury/TreasuryDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nabstract contract TreasuryDependencies {\n    address public executor;\n\n    address public policyCenter;\n}\n"
    },
    "src/reward/treasury/TreasuryEventError.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nabstract contract TreasuryEventError {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event ReporterRewarded(address indexed reporter, uint256 amount);\n\n    event NewIncomeToTreasury(uint256 indexed poolId, uint256 amount);\n\n    event ClaimedByOwner(uint256 amount);\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error Treasury__OnlyExecutor();\n\n    error Treasury__OnlyPolicyCenter();\n\n    error Treasury__OnlyOwner();\n}\n"
    },
    "src/pools/payoutPool/PayoutPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../../interfaces/ICoverRightTokenFactory.sol\";\nimport \"../../interfaces/ICoverRightToken.sol\";\nimport \"../../interfaces/IPriorityPool.sol\";\nimport \"../../interfaces/IPriorityPoolFactory.sol\";\n\nimport \"../../util/SimpleIERC20.sol\";\n\n/**\n * @notice Payout Pool\n *\n *         Every time there is a report passed, some assets will be moved to this pool\n *         It is stored as a Payout struct\n *         - amount       Total amount of this payout\n *         - remaining    Remaining amount\n *         - endTimestamp After this timestamp, no more claims\n *         - ratio        Max ratio of a user's crToken\n */\ncontract PayoutPool is Initializable {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    uint256 public constant SCALE = 1e12;\n\n    uint256 public constant CLAIM_PERIOD = 30 days;\n\n    address public constant USDC = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Cover Right Token Factory\n    address public crFactory;\n\n    // Policy Center\n    address public policyCenter;\n\n    // Priority Pool Factory\n    address public priorityPoolFactory;\n\n    // About \"ratio\" and \"coverIndex\"\n    // E.g. You have 1000 available crTokens\n    //      There is a payout with ratio 1e11 and coverIndex 1000\n    //      That means:\n    //        - 10% of your crTokens can be used for claim (100 crTokens)\n    //        - 1 crToken can be used to claim 0.1 USDC (get 10 USDC back)\n    struct Payout {\n        uint256 amount; // Total amount of this payment\n        uint256 remaining; // Remaining amount\n        uint256 endTiemstamp; // Claim period end timestamp\n        uint256 ratio; // Ratio of your crTokens that can be claimed (SCALE = 1e12 = 100%)\n        uint256 coverIndex;  // Index of the cover (ratio of the crTokens to USDC) (10000 = 100%)\n        address priorityPool; // Which priority pool this payout belongs to\n    }\n    // Pool id => Generation => Payout\n    // One pool & one generation has only one payout\n    mapping(uint256 => mapping(uint256 => Payout)) public payouts;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event NewPayout(\n        uint256 indexed _poolId,\n        uint256 _generation,\n        uint256 _amount,\n        uint256 _ratio\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error PayoutPool__OnlyPriorityPool();\n    error PayoutPool__NotPolicyCenter();\n    error PayoutPool__WrongCRToken();\n    error PayoutPool__NoPayout();\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(\n        address _policyCenter,\n        address _crFactory,\n        address _priorityPoolFactory\n    ) public initializer {\n        policyCenter = _policyCenter;\n        crFactory = _crFactory;\n        priorityPoolFactory = _priorityPoolFactory;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Only be called from one of the priority pools\n    modifier onlyPriorityPool(uint256 _poolId) {\n        (, address poolAddress, , , ) = IPriorityPoolFactory(\n            priorityPoolFactory\n        ).pools(_poolId);\n        if (poolAddress != msg.sender) revert PayoutPool__OnlyPriorityPool();\n        _;\n    }\n\n    // Only be called from policy center\n    modifier onlyPolicyCenter() {\n        if (msg.sender != policyCenter) revert PayoutPool__NotPolicyCenter();\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice New payout comes in\n     *\n     *         Only callable from one of the priority pools\n     *\n     *         After the pool's report is passed and executed,\n     *         part of the assets will be moved to this pool.\n     *\n     *\n     * @param _poolId       Pool Id\n     * @param _generation   Generation of priority pool (start at 1)\n     * @param _amount       Total amount to be claimed\n     * @param _ratio        Payout ratio of this payout (users can only use part of their crTokens to claim)\n     * @param _poolAddress  Address of priority pool\n     */\n    function newPayout(\n        uint256 _poolId,\n        uint256 _generation,\n        uint256 _amount,\n        uint256 _ratio,\n        uint256 _coverIndex,\n        address _poolAddress\n    ) external onlyPriorityPool(_poolId) {\n        Payout storage payout = payouts[_poolId][_generation];\n\n        // Store the information\n        payout.amount = _amount;\n        payout.endTiemstamp = block.timestamp + CLAIM_PERIOD;\n        payout.ratio = _ratio;\n        payout.coverIndex = _coverIndex;\n        payout.priorityPool = _poolAddress;\n\n        emit NewPayout(_poolId, _generation, _amount, _ratio);\n    }\n\n    /**\n     * @notice Claim payout for a user\n     *\n     *         Only callable from policy center\n     *         Need provide certain crToken address and generation\n     *\n     * @param _user       User address\n     * @param _crToken    Cover right token address\n     * @param _poolId     Pool Id\n     * @param _generation Generation of priority pool (started at 1)\n     *\n     * @return claimed               The actual amount transferred to the user\n     * @return newGenerationCRAmount New generation crToken minted to the user\n     */\n    function claim(\n        address _user,\n        address _crToken,\n        uint256 _poolId,\n        uint256 _generation\n    )\n        external\n        onlyPolicyCenter\n        returns (uint256 claimed, uint256 newGenerationCRAmount)\n    {\n        Payout storage payout = payouts[_poolId][_generation];\n\n        uint256 expiry = ICoverRightToken(_crToken).expiry();\n\n        // Check the crToken address and generation matched\n        bytes32 salt = keccak256(\n            abi.encodePacked(_poolId, expiry, _generation)\n        );\n        if (ICoverRightTokenFactory(crFactory).saltToAddress(salt) != _crToken)\n            revert PayoutPool__WrongCRToken();\n\n        // Get claimable amount of crToken\n        uint256 claimableBalance = ICoverRightToken(_crToken).getClaimableOf(\n            _user\n        );\n        // Only part of the crToken can be used for claim\n        uint256 claimable = (claimableBalance * payout.ratio) / SCALE;\n\n        if (claimable == 0) revert PayoutPool__NoPayout();\n\n        // Actual amount given to the user\n        claimed = (claimable * payout.coverIndex) / 10000;\n\n        // Reduce the active cover amount in priority pool\n        (, address poolAddress, , , ) = IPriorityPoolFactory(\n            priorityPoolFactory\n        ).pools(_poolId);\n        IPriorityPool(poolAddress).updateWhenClaimed(expiry, claimed);\n\n        // Burn current crToken\n        ICoverRightToken(_crToken).burn(\n            _poolId,\n            _user,\n            // burns the users' crToken balance, not the payout amount,\n            // since rest of the payout will be minted as a new generation token\n            claimableBalance\n        );\n\n        SimpleIERC20(USDC).transfer(_user, claimed);\n\n        // Amount of new generation cr token to be minted\n        newGenerationCRAmount = claimableBalance - claimable;\n    }\n}\n"
    },
    "src/interfaces/ICoverRightTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface ICoverRightTokenFactory {\n    function deployCRToken(\n        string calldata _poolName,\n        uint256 _poolId,\n        string calldata _tokenName,\n        uint256 _expiry,\n        uint256 _generation\n    ) external returns (address newCRTokenAddress);\n\n    function deployed(bytes32 _salt) external view returns (bool);\n\n    function saltToAddress(bytes32 _salt) external view returns (address);\n}\n"
    },
    "src/interfaces/ICoverRightToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface ICoverRightToken {\n    function expiry() external view returns (uint256);\n\n    function getClaimableOf(address _user) external view returns (uint256);\n\n    function mint(\n        uint256 _poolId,\n        address _user,\n        uint256 _amount\n    ) external;\n\n    function burn(\n        uint256 _poolId,\n        address _user,\n        uint256 _amount\n    ) external;\n\n    function generation() external view returns (uint256);\n}\n"
    },
    "src/interfaces/IPriorityPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IPriorityPool {\n    //\n\n    function lpTokenAddress(uint256 _generation)\n        external\n        view\n        returns (address);\n\n    function insuredToken() external view returns (address);\n\n    function pausePriorityPool(bool _paused) external;\n\n    function setCoverIndex(uint256 _newIndex) external;\n\n    function minAssetRequirement() external view returns (uint256);\n\n    function activeCovered() external view returns (uint256);\n\n    function currentLPAddress() external view returns (address);\n\n    function liquidatePool(uint256 amount) external;\n\n    function generation() external view returns (uint256);\n\n    function crTokenAddress(uint256 generation) external view returns (address);\n\n    function poolInfo()\n        external\n        view\n        returns (\n            bool,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function updateWhenBuy(\n        uint256 _amount,\n        uint256 _premium,\n        uint256 _length,\n        uint256 _timestampLength\n    ) external;\n\n    function stakedLiquidity(uint256 _amount, address _provider)\n        external\n        returns (address);\n\n    function unstakedLiquidity(\n        address _lpToken,\n        uint256 _amount,\n        address _provider\n    ) external;\n\n    function coverPrice(uint256 _amount, uint256 _length)\n        external\n        view\n        returns (uint256, uint256);\n\n    function maxCapacity() external view returns (uint256);\n\n    function coverIndex() external view returns (uint256);\n\n    function paused() external view returns (bool);\n\n    function basePremiumRatio() external view returns (uint256);\n\n    function updateWhenClaimed(uint256 expiry, uint256 amount) external;\n}\n"
    },
    "src/pools/priorityPool/PriorityPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport \"./PriorityPoolFactoryDependencies.sol\";\n\nimport \"../../util/OwnableWithoutContextUpgradeable.sol\";\nimport \"../../interfaces/ExternalTokenDependencies.sol\";\nimport \"./PriorityPoolFactoryEventError.sol\";\n\n// import \"./PriorityPool.sol\";\n\nimport \"../../interfaces/IPriorityPool.sol\";\n\n/**\n * @title Insurance Pool Factory\n *\n * @author Eric Lee (ylikp.ust@gmail.com)\n *\n * @notice This is the factory contract for deploying new insurance pools\n *         Each pool represents a project that has joined Degis Protocol Protection\n *\n *         Liquidity providers of Protection Pool can stake their LP tokens into priority pools\n *         Benefit:\n *             - Share the 45% part of the premium income (in native token form)\n *         Risk:\n *             - Will be liquidated first to pay for the claim amount\n *\n *\n */\ncontract PriorityPoolFactory is\n    PriorityPoolFactoryEventError,\n    OwnableWithoutContextUpgradeable,\n    ExternalTokenDependencies,\n    PriorityPoolFactoryDependencies\n{\n    address public constant USDC = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    struct PoolInfo {\n        string protocolName;\n        address poolAddress;\n        address protocolToken;\n        uint256 maxCapacity; // max capacity ratio\n        uint256 basePremiumRatio;\n    }\n    // poolId => Pool Information\n    mapping(uint256 => PoolInfo) public pools;\n\n    mapping(address => uint256) public poolAddressToId;\n\n    uint256 public poolCounter;\n\n    // Total max capacity\n    uint256 public totalMaxCapacity;\n\n    // Whether a pool is already dynamic\n    mapping(address => bool) public dynamic;\n\n    // Total dynamic pools\n    uint256 public dynamicPoolCounter;\n\n    // Record whether a protocol token or pool address has been registered\n    mapping(address => bool) public poolRegistered;\n    mapping(address => bool) public tokenRegistered;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(\n        address _deg,\n        address _veDeg,\n        address _protectionPool\n    ) public initializer {\n        __ExternalToken__Init(_deg, _veDeg);\n        __Ownable_init();\n\n        protectionPool = _protectionPool;\n\n        poolRegistered[_protectionPool] = true;\n        tokenRegistered[USDC] = true;\n\n        // Protection pool as pool 0\n        pools[0] = PoolInfo(\"ProtectionPool\", _protectionPool, USDC, 0, 0);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    modifier onlyPriorityPool() {\n        if (!poolRegistered[msg.sender])\n            revert PriorityPoolFactory__OnlyPriorityPool();\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the pool address list\n     *\n     * @return List of pool addresses\n     */\n    function getPoolAddressList() external view returns (address[] memory) {\n        uint256 poolAmount = poolCounter + 1;\n\n        address[] memory list = new address[](poolAmount);\n\n        for (uint256 i; i < poolAmount; ) {\n            list[i] = pools[i].poolAddress;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return list;\n    }\n\n    /**\n     * @notice Get the pool information by pool id\n     *\n     * @param _poolId Pool id\n     */\n    function getPoolInfo(uint256 _poolId)\n        public\n        view\n        returns (PoolInfo memory)\n    {\n        return pools[_poolId];\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function setPolicyCenter(address _policyCenter) external onlyOwner {\n        policyCenter = _policyCenter;\n    }\n\n    function setWeightedFarmingPool(address _weightedFarmingPool)\n        external\n        onlyOwner\n    {\n        weightedFarmingPool = _weightedFarmingPool;\n    }\n\n    function setProtectionPool(address _protectionPool) external onlyOwner {\n        protectionPool = _protectionPool;\n    }\n\n    function setExecutor(address _executor) external onlyOwner {\n        executor = _executor;\n    }\n\n    function setIncidentReport(address _incidentReport) external onlyOwner {\n        incidentReport = _incidentReport;\n    }\n\n    function setPriorityPoolDeployer(address _priorityPoolDeployer)\n        external\n        onlyOwner\n    {\n        priorityPoolDeployer = _priorityPoolDeployer;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Create a new priority pool\n     *         Called by executor when an onboard proposal has passed\n     *\n     * @param _name             Name of the protocol\n     * @param _protocolToken    Address of the token used for the protocol\n     * @param _maxCapacity      Maximum capacity of the pool\n     * @param _basePremiumRatio Initial policy price per usdc\n     *\n     * @return address Address of the new insurance pool\n     */\n    function deployPool(\n        string calldata _name,\n        address _protocolToken,\n        uint256 _maxCapacity,\n        uint256 _basePremiumRatio\n    ) public returns (address) {\n        if (msg.sender != owner() && msg.sender != executor)\n            revert PriorityPoolFactory__OnlyOwnerOrExecutor();\n        if (tokenRegistered[_protocolToken])\n            revert PriorityPoolFactory__TokenAlreadyRegistered();\n\n        // Add new pool max capacity to sum of max capacities\n        totalMaxCapacity += _maxCapacity;\n\n        uint256 currentPoolId = ++poolCounter;\n\n        address newAddress = IPriorityPoolDeployer(priorityPoolDeployer)\n            .getPoolAddress(\n                currentPoolId,\n                _name,\n                _protocolToken,\n                _maxCapacity,\n                _basePremiumRatio\n            );\n        poolRegistered[newAddress] = true;\n\n        address newPoolAddress = IPriorityPoolDeployer(priorityPoolDeployer)\n            .deployPool(\n                currentPoolId,\n                _name,\n                _protocolToken,\n                _maxCapacity,\n                _basePremiumRatio\n            );\n\n        pools[currentPoolId] = PoolInfo(\n            _name,\n            newPoolAddress,\n            _protocolToken,\n            _maxCapacity,\n            _basePremiumRatio\n        );\n\n        tokenRegistered[_protocolToken] = true;\n        poolAddressToId[newPoolAddress] = currentPoolId;\n\n        // Store pool information in Policy Center\n        IPolicyCenter(policyCenter).storePoolInformation(\n            newPoolAddress,\n            _protocolToken,\n            currentPoolId\n        );\n\n        // Add reward token in farming pool\n        IWeightedFarmingPool(weightedFarmingPool).addPool(_protocolToken);\n\n        emit PoolCreated(\n            currentPoolId,\n            newPoolAddress,\n            _name,\n            _protocolToken,\n            _maxCapacity,\n            _basePremiumRatio\n        );\n\n        return newPoolAddress;\n    }\n\n    /**\n     * @notice Update a priority pool status to dynamic\n     *         Only sent from priority pool\n     *         \"Dynamic\" means:\n     *                  The priority pool will be counted in the dynamic premium formula\n     *\n     * @param _poolId Pool id\n     */\n    function updateDynamicPool(uint256 _poolId) external onlyPriorityPool {\n        address poolAddress = pools[_poolId].poolAddress;\n        if (dynamic[poolAddress])\n            revert PriorityPoolFactory__AlreadyDynamicPool();\n\n        dynamic[poolAddress] = true;\n\n        unchecked {\n            ++dynamicPoolCounter;\n        }\n\n        emit DynamicPoolUpdate(_poolId, poolAddress, dynamicPoolCounter);\n    }\n\n    /**\n     * @notice Update max capacity from a priority pool\n     */\n    function updateMaxCapacity(bool _isUp, uint256 _diff)\n        external\n        onlyPriorityPool\n    {\n        if (_isUp) {\n            totalMaxCapacity += _diff;\n        } else totalMaxCapacity -= _diff;\n\n        emit MaxCapacityUpdated(totalMaxCapacity);\n    }\n\n    function pausePriorityPool(uint256 _poolId, bool _paused) external {\n        if (msg.sender != incidentReport && msg.sender != executor)\n            revert PriorityPoolFactory__OnlyIncidentReportOrExecutor();\n\n        IPriorityPool(pools[_poolId].poolAddress).pausePriorityPool(_paused);\n\n        IProtectionPool(protectionPool).pauseProtectionPool(_paused);\n    }\n}\n"
    },
    "src/pools/priorityPool/PriorityPoolFactoryDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IPolicyCenter {\n    function storePoolInformation(\n        address _pool,\n        address _token,\n        uint256 _poolId\n    ) external;\n}\n\ninterface IWeightedFarmingPool {\n    function addPool(address _token) external;\n\n    function addToken(\n        uint256 _id,\n        address _token,\n        uint256 _weight\n    ) external;\n\n    function updateRewardSpeed(\n        uint256 _id,\n        uint256 _newSpeed,\n        uint256[] memory _years,\n        uint256[] memory _months\n    ) external;\n\n    function updateWeight(\n        uint256 _id,\n        address _token,\n        uint256 _newWeight\n    ) external;\n}\n\ninterface IProtectionPool {\n    function getTotalActiveCovered() external view returns (uint256);\n\n    function getLatestPrice() external returns (uint256);\n\n    function removedLiquidity(uint256 _amount, address _provider)\n        external\n        returns (uint256);\n\n    function removedLiquidityWhenClaimed(uint256 _amount, address _to) external;\n\n    function pauseProtectionPool(bool _paused) external;\n\n    function stakedSupply() external view returns (uint256);\n}\n\ninterface IPriorityPoolDeployer {\n    function deployPool(\n        uint256 poolId,\n        string calldata _name,\n        address _protocolToken,\n        uint256 _maxCapacity,\n        uint256 _basePremiumRatio\n    ) external returns (address);\n\n    function getPoolAddress(\n        uint256 poolId,\n        string calldata _name,\n        address _protocolToken,\n        uint256 _maxCapacity,\n        uint256 _basePremiumRatio\n    ) external view returns (address);\n}\n\nabstract contract PriorityPoolFactoryDependencies {\n    // Priority Pools need access to executor address\n    address public executor;\n    address public policyCenter;\n    address public protectionPool;\n    address public incidentReport;\n    address public weightedFarmingPool;\n\n    address public priorityPoolDeployer;\n}\n"
    },
    "src/pools/priorityPool/PriorityPoolFactoryEventError.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface PriorityPoolFactoryEventError {\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event PoolCreated(\n        uint256 poolId,\n        address poolAddress,\n        string protocolName,\n        address protocolToken,\n        uint256 maxCapacity,\n        uint256 basePremiumRatio\n    );\n\n    event DynamicPoolUpdate(\n        uint256 poolId,\n        address pool,\n        uint256 dynamicPoolCounter\n    );\n\n    event MaxCapacityUpdated(uint256 totalMaxCapacity);\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error PriorityPoolFactory__OnlyExecutor();\n    error PriorityPoolFactory__OnlyPolicyCenter();\n    error PriorityPoolFactory__OnlyOwnerOrExecutor();\n    error PriorityPoolFactory__OnlyPriorityPool();\n    error PriorityPoolFactory__OnlyIncidentReportOrExecutor();\n    error PriorityPoolFactory__PoolNotRegistered();\n    error PriorityPoolFactory__TokenAlreadyRegistered();\n    error PriorityPoolFactory__AlreadyDynamicPool();\n    error PriorityPoolFactory__NotOwnerOrFactory();\n    error PriorityPoolFactory__WrongLPToken();\n}\n"
    },
    "src/core/interfaces/PolicyCenterDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IPriorityPool.sol\";\nimport \"../../interfaces/IProtectionPool.sol\";\nimport \"../../interfaces/IPriorityPoolFactory.sol\";\nimport \"../../interfaces/ICoverRightToken.sol\";\nimport \"../../interfaces/ICoverRightTokenFactory.sol\";\nimport \"../../interfaces/IPayoutPool.sol\";\nimport \"../../interfaces/IWeightedFarmingPool.sol\";\nimport \"../../interfaces/ITreasury.sol\";\nimport \"../../interfaces/IExchange.sol\";\nimport \"../../interfaces/IERC20Decimals.sol\";\n\nabstract contract PolicyCenterDependencies {\n    // Max cover length\n    // Different priority pools have different max lengths\n    // This max length is the maximum of all pools\n    // There will also be a check in each pool\n    uint256 internal constant MAX_COVER_LENGTH = 3;\n\n    // 10000 = 100%\n    // Priority pool 45%\n    uint256 internal constant PREMIUM_TO_PRIORITY = 4500;\n    // Protection pool 50%\n    uint256 internal constant PREMIUM_TO_PROTECTION = 5000;\n    // Treasury 5%\n    uint256 internal constant PREMIUM_TO_TREASURY = 500;\n\n    // Swap slippage\n    // TODO: Slippage tolerance parameter 10000 as 100%\n    uint256 internal constant SLIPPAGE = 100;\n\n    address public protectionPool;\n    address public priceGetter;\n    address public priorityPoolFactory;\n    address public coverRightTokenFactory;\n    address public weightedFarmingPool;\n    address public exchange;\n    address public payoutPool;\n    address public treasury;\n\n    address public dexPriceGetter;\n}\n"
    },
    "src/interfaces/IProtectionPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IProtectionPool {\n    function pauseProtectionPool(bool _paused) external;\n\n    function providedLiquidity(uint256 _amount, address _provider) external;\n\n    function removedLiquidity(uint256 _amount, address _provider)\n        external\n        returns (uint256);\n\n    function getTotalCovered() external view returns (uint256);\n\n    function getTotalActiveCovered() external view returns (uint256);\n\n    function updateWhenBuy() external;\n\n    function removedLiquidityWhenClaimed(uint256 _amount, address _to) external;\n\n    function getLatestPrice() external returns (uint256);\n\n    function updateStakedSupply(bool isStake, uint256 amount) external;\n\n    function stakedSupply() external view returns (uint256);\n}\n"
    },
    "src/interfaces/IPayoutPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IPayoutPool {\n    function CLAIM_PERIOD() external view returns (uint256);\n\n    function SCALE() external view returns (uint256);\n\n    function claim(\n        address _user,\n        address _crToken,\n        uint256 _poolId,\n        uint256 _generation\n    ) external returns (uint256 claimed, uint256 newGenerationCRAmount);\n\n    function crFactory() external view returns (address);\n\n    function newPayout(\n        uint256 _poolId,\n        uint256 _generation,\n        uint256 _amount,\n        uint256 _ratio,\n        address _poolAddress\n    ) external;\n\n    function payoutCounter() external view returns (uint256);\n\n    function payouts(uint256)\n        external\n        view\n        returns (\n            uint256 amount,\n            uint256 remaining,\n            uint256 endTiemstamp,\n            uint256 ratio,\n            address priorityPoolAddress\n        );\n\n    function policyCenter() external view returns (address);\n}\n"
    },
    "src/interfaces/IWeightedFarmingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IWeightedFarmingPool {\n    function addPool(address _token) external;\n\n    function addToken(\n        uint256 _id,\n        address _token,\n        uint256 _weight\n    ) external;\n\n    function updateRewardSpeed(\n        uint256 _id,\n        uint256 _newSpeed,\n        uint256[] memory _years,\n        uint256[] memory _months\n    ) external;\n\n    function depositFromPolicyCenter(\n        uint256 _id,\n        address _token,\n        uint256 _amount,\n        address _user\n    ) external;\n\n    function withdrawFromPolicyCenter(\n        uint256 _id,\n        address _token,\n        uint256 _amount,\n        address _user\n    ) external;\n\n    function updateWeight(\n        uint256 _id,\n        address _token,\n        uint256 _newWeight\n    ) external;\n}\n"
    },
    "src/interfaces/IExchange.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IExchange {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function getAmountsOut(uint256 amountIn, address[] memory path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n"
    },
    "src/interfaces/IERC20Decimals.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IERC20Decimals {\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/core/PolicyCenter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport \"../interfaces/ExternalTokenDependencies.sol\";\nimport \"./interfaces/PolicyCenterEventError.sol\";\nimport \"./interfaces/PolicyCenterDependencies.sol\";\n\nimport \"../util/OwnableWithoutContextUpgradeable.sol\";\n\nimport \"../interfaces/IPriceGetter.sol\";\n\nimport \"../libraries/DateTime.sol\";\nimport \"../libraries/StringUtils.sol\";\nimport \"../libraries/SimpleSafeERC20.sol\";\n\n/**\n * @title Policy Center\n *\n * @author Eric Lee (ylikp.ust@gmail.com) & Primata (primata@375labs.org)\n *\n * @notice This is the policy center for degis Protocol Protection\n *         Users can buy policies and get payoff here\n *         Sellers can provide liquidity and choose the pools to cover\n *\n */\ncontract PolicyCenter is\n    PolicyCenterEventError,\n    OwnableWithoutContextUpgradeable,\n    ExternalTokenDependencies,\n    PolicyCenterDependencies\n{\n    using SimpleSafeERC20 for SimpleIERC20;\n    using StringUtils for uint256;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    address public constant USDC = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E;\n\n    // Pool Id => Priority Pool Address\n    // Updated once pools are deployed\n    // Protection Pool is pool 0\n    mapping(uint256 => address) public priorityPools;\n\n    // Pool Id => Pool Native Token Address\n    mapping(uint256 => address) public tokenByPoolId;\n\n    // Protocol token => Oracle type\n    // 0: Default as chainlink oracle\n    // 1: Dex oracle by traderJoe\n    mapping(address => uint256) public oracleType;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(\n        address _deg,\n        address _veDeg,\n        address _protectionPool\n    ) public initializer {\n        __Ownable_init();\n        __ExternalToken__Init(_deg, _veDeg);\n\n        // Peotection pool as pool 0 and with usdc token\n        priorityPools[0] = _protectionPool;\n        tokenByPoolId[0] = USDC;\n\n        protectionPool = _protectionPool;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Whether the pool exists\n     */\n    modifier poolExists(uint256 _poolId) {\n        if (_poolId == 0 || priorityPools[_poolId] == address(0))\n            revert PolicyCenter__NonExistentPool();\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Returns the current LP address for a Pool ID\n     *\n     *         \"Current\" means the LP address that is currently being used\n     *         Because each priority pool may have several generations of LP tokens\n     *         Once reported and paid out, the LP generation will be updated\n     *\n     * @param _poolId Priority Pool ID\n     *\n     * @return lpAddress Current generation LP token address\n     */\n    function currentLPAddress(uint256 _poolId)\n        external\n        view\n        returns (address lpAddress)\n    {\n        lpAddress = IPriorityPool(priorityPools[_poolId]).currentLPAddress();\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function setExchange(address _exchange) external onlyOwner {\n        exchange = _exchange;\n    }\n\n    function setPriceGetter(address _priceGetter) external onlyOwner {\n        priceGetter = _priceGetter;\n    }\n\n    function setProtectionPool(address _protectionPool) external onlyOwner {\n        protectionPool = _protectionPool;\n    }\n\n    function setWeightedFarmingPool(address _weightedFarmingPool)\n        external\n        onlyOwner\n    {\n        weightedFarmingPool = _weightedFarmingPool;\n    }\n\n    function setCoverRightTokenFactory(address _coverRightTokenFactory)\n        external\n        onlyOwner\n    {\n        coverRightTokenFactory = _coverRightTokenFactory;\n    }\n\n    function setPriorityPoolFactory(address _priorityPoolFactory)\n        external\n        onlyOwner\n    {\n        priorityPoolFactory = _priorityPoolFactory;\n    }\n\n    function setPayoutPool(address _payoutPool) external onlyOwner {\n        payoutPool = _payoutPool;\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n    }\n\n    function setDexPriceGetter(address _dexPriceGetter) external onlyOwner {\n        dexPriceGetter = _dexPriceGetter;\n    }\n\n    function setOracleType(address _token, uint256 _type) external onlyOwner {\n        require(_type < 2, \"Wrong type\");\n        oracleType[_token] = _type;\n    }\n\n    /**\n     * @notice Approve the exchange to swap tokens\n     *\n     * @param _token Address of the approved token\n     */\n    function approvePoolToken(address _token) external onlyOwner {\n        _approvePoolToken(_token);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Buy new cover for a given pool\n     *\n     *         Select a pool with parameter \"poolId\"\n     *         Cover amount is in usdc and duration is in month\n     *         The premium ratio may be dynamic so \"maxPayment\" is similar to \"slippage\"\n     *\n     * @param _poolId        Pool id\n     * @param _coverAmount   Amount to cover\n     * @param _coverDuration Cover duration in month (1 ~ 3)\n     * @param _maxPayment    Maximum payment user can accept\n     *\n     * @return crToken CR token address\n     */\n    function buyCover(\n        uint256 _poolId,\n        uint256 _coverAmount,\n        uint256 _coverDuration,\n        uint256 _maxPayment,\n        address[] memory path\n    ) external poolExists(_poolId) returns (address) {\n        if (!_withinLength(_coverDuration)) revert PolicyCenter__BadLength();\n\n        _checkCapacity(_poolId, _coverAmount);\n\n        // Premium in USD and duration in second\n        (uint256 premium, uint256 timestampDuration) = _getCoverPrice(\n            _poolId,\n            _coverAmount,\n            _coverDuration\n        );\n        // Check if premium cost is within limits given by user\n        if (premium > _maxPayment) revert PolicyCenter__PremiumTooHigh();\n\n        // Mint cover right tokens to buyer\n        // CR token has different months and generations\n        address crToken = _checkCRToken(_poolId, _coverDuration);\n        ICoverRightToken(crToken).mint(_poolId, msg.sender, _coverAmount);\n\n        // Split the premium income and update the pool status\n        (\n            uint256 premiumToPriorityPool,\n            ,\n            uint256 premiumToTreasury\n        ) = _splitPremium(_poolId, premium, path);\n\n        IProtectionPool(protectionPool).updateWhenBuy();\n        IPriorityPool(priorityPools[_poolId]).updateWhenBuy(\n            _coverAmount,\n            premiumToPriorityPool,\n            _coverDuration,\n            timestampDuration\n        );\n        ITreasury(treasury).premiumIncome(_poolId, premiumToTreasury);\n\n        emit CoverBought(\n            msg.sender,\n            _poolId,\n            _coverDuration,\n            _coverAmount,\n            premium\n        );\n\n        return crToken;\n    }\n\n    /**\n     * @notice Provide liquidity to Protection Pool\n     *\n     * @param _amount Amount of liquidity (usdc) to provide\n     */\n    function provideLiquidity(uint256 _amount) external {\n        if (_amount == 0) revert PolicyCenter__ZeroAmount();\n\n        // Mint PRO-LP tokens and transfer usdc\n        IProtectionPool(protectionPool).providedLiquidity(_amount, msg.sender);\n        SimpleIERC20(USDC).transferFrom(msg.sender, protectionPool, _amount);\n\n        emit LiquidityProvided(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Stake Protection Pool LP (PRO-LP) into priority pools\n     *         And automatically stake the PRI-LP tokens into weighted farming pool\n     *         With this function, no need for approval of PRI-LP tokens\n     *\n     *         If you want to hold the PRI-LP tokens for other usage\n     *         Call \"stakeLiquidityWithoutFarming\"\n     *\n     * @param _poolId Pool id\n     * @param _amount Amount of PRO-LP tokens to stake\n     */\n    function stakeLiquidity(uint256 _poolId, uint256 _amount)\n        public\n        poolExists(_poolId)\n    {\n        if (_amount == 0) revert PolicyCenter__ZeroAmount();\n\n        address pool = priorityPools[_poolId];\n\n        // Update status and mint Prority Pool LP tokens\n        // Directly mint pri-lp tokens to policy center\n        // And send the PRI-LP tokens to weighted farming pool\n        // No need for approval\n        address lpToken = IPriorityPool(pool).stakedLiquidity(\n            _amount,\n            address(this)\n        );\n        SimpleIERC20(protectionPool).transferFrom(msg.sender, pool, _amount);\n        IProtectionPool(protectionPool).updateStakedSupply(true, _amount);\n\n        IWeightedFarmingPool(weightedFarmingPool).depositFromPolicyCenter(\n            _poolId,\n            lpToken,\n            _amount,\n            msg.sender\n        );\n        SimpleIERC20(lpToken).transfer(weightedFarmingPool, _amount);\n\n        emit LiquidityStaked(msg.sender, _poolId, _amount);\n    }\n\n    /**\n     * @notice Stake liquidity to priority pool without depositing into farming\n     *\n     * @param _poolId Pool id\n     * @param _amount Amount of PRO-LP amount\n     */\n    function stakeLiquidityWithoutFarming(uint256 _poolId, uint256 _amount)\n        public\n        poolExists(_poolId)\n    {\n        if (_amount == 0) revert PolicyCenter__ZeroAmount();\n\n        address pool = priorityPools[_poolId];\n\n        // Mint PRI-LP tokens to the user directly\n        IPriorityPool(pool).stakedLiquidity(_amount, msg.sender);\n        SimpleIERC20(protectionPool).transferFrom(msg.sender, pool, _amount);\n\n        IProtectionPool(protectionPool).updateStakedSupply(true, _amount);\n\n        emit LiquidityStakedWithoutFarming(msg.sender, _poolId, _amount);\n    }\n\n    /**\n     * @notice Unstake Protection Pool LP from priority pools\n     *         There may be different generations of priority lp tokens\n     *\n     *         This function will first remove the PRI-LP token from farming pool\n     *         Ensure that your PRI-LP tokens are inside the farming pool\n     *         If the PRI-LP tokens are in your own wallet, use \"unstakeLiquidityWithoutFarming\"\n     *\n     * @param _poolId     Pool id\n     * @param _priorityLP Priority lp token address to withdraw\n     * @param _amount     Amount of LP(priority lp) tokens to withdraw\n     */\n    function unstakeLiquidity(\n        uint256 _poolId,\n        address _priorityLP,\n        uint256 _amount\n    ) public poolExists(_poolId) {\n        if (_amount == 0) revert PolicyCenter__ZeroAmount();\n\n        // First remove the PRI-LP token from weighted farming pool\n        IWeightedFarmingPool(weightedFarmingPool).withdrawFromPolicyCenter(\n            _poolId,\n            _priorityLP,\n            _amount,\n            msg.sender\n        );\n\n        // Burn PRI-LP tokens and give back PRO-LP tokens\n        IPriorityPool(priorityPools[_poolId]).unstakedLiquidity(\n            _priorityLP,\n            _amount,\n            msg.sender\n        );\n\n        IProtectionPool(protectionPool).updateStakedSupply(false, _amount);\n\n        emit LiquidityUnstaked(msg.sender, _poolId, _priorityLP, _amount);\n    }\n\n    /**\n     * @notice Unstake liquidity without removing PRI-LP from farming\n     *\n     * @param _poolId     Pool id\n     * @param _priorityLP PRI-LP token address\n     * @param _amount     PRI-LP token amount to remove\n     */\n    function unstakeLiquidityWithoutFarming(\n        uint256 _poolId,\n        address _priorityLP,\n        uint256 _amount\n    ) external poolExists(_poolId) {\n        if (_amount == 0) revert PolicyCenter__ZeroAmount();\n\n        IPriorityPool(priorityPools[_poolId]).unstakedLiquidity(\n            _priorityLP,\n            _amount,\n            msg.sender\n        );\n\n        IProtectionPool(protectionPool).updateStakedSupply(false, _amount);\n\n        emit LiquidityUnstakedWithoutFarming(\n            msg.sender,\n            _poolId,\n            _priorityLP,\n            _amount\n        );\n    }\n\n    /**\n     * @notice Remove liquidity from protection pool\n     *\n     * @param _amount Amount of liquidity to provide\n     */\n    function removeLiquidity(uint256 _amount) external {\n        if (_amount == 0) revert PolicyCenter__ZeroAmount();\n\n        IProtectionPool(protectionPool).removedLiquidity(_amount, msg.sender);\n\n        emit LiquidityRemoved(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Claim payout\n     *         Need to use a specific crToken address as parameter\n     *\n     * @param _poolId     Pool id\n     * @param _crToken    Cover right token address\n     * @param _generation Generation of the priority pool\n     */\n    function claimPayout(\n        uint256 _poolId,\n        address _crToken,\n        uint256 _generation\n    ) public poolExists(_poolId) {\n        (string memory poolName, , , , ) = IPriorityPoolFactory(\n            priorityPoolFactory\n        ).pools(_poolId);\n\n        // Claim payout from payout pool\n        // Get the actual claimed amount and new generation cr token to be minted\n        (uint256 claimed, uint256 newGenerationCRAmount) = IPayoutPool(\n            payoutPool\n        ).claim(msg.sender, _crToken, _poolId, _generation);\n\n        emit PayoutClaimed(msg.sender, claimed);\n\n        // Check if the new generation crToken has been deployed\n        // If so, get the address\n        // If not, deploy the new generation cr token\n        if (newGenerationCRAmount > 0) {\n            uint256 expiry = ICoverRightToken(_crToken).expiry();\n\n            address newCRToken = _checkNewCRToken(\n                _poolId,\n                poolName,\n                expiry,\n                ++_generation\n            );\n\n            ICoverRightToken(newCRToken).mint(\n                _poolId,\n                msg.sender,\n                newGenerationCRAmount\n            );\n        }\n    }\n\n    /**\n     * @notice Store new pool information\n     *\n     * @param _pool   Address of the priority pool\n     * @param _token  Address of the priority pool's native token\n     * @param _poolId Pool id\n     */\n    function storePoolInformation(\n        address _pool,\n        address _token,\n        uint256 _poolId\n    ) external {\n        if (msg.sender != priorityPoolFactory)\n            revert PolicyCenter__OnlyPriorityPoolFactory();\n\n        // Should never change the protection pool information\n        assert(_poolId > 0);\n\n        tokenByPoolId[_poolId] = _token;\n        priorityPools[_poolId] = _pool;\n\n        _approvePoolToken(_token);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Swap tokens to USDC\n     *\n     * @param _fromToken Token address to swap from\n     * @param _amount    Amount of token to swap from\n     * @param _path      Swap path\n     *\n     * @return received Actual usdc amount received\n     */\n    function _swapTokens(\n        address _fromToken,\n        uint256 _amount,\n        address[] memory _path\n    ) internal returns (uint256 received) {\n        uint256 length = _path.length;\n\n        if (_path[length - 1] != USDC) revert PolicyCenter__WrongPath();\n        if (_path[0] != _fromToken) revert PolicyCenter__WrongPath();\n\n        // Swap for USDC and return the received amount\n        uint256[] memory amountsOut = new uint256[](2);\n\n        // @audit Calculating slippage\n        uint256[] memory amountOutCal = IExchange(exchange).getAmountsOut(\n            _amount,\n            _path\n        );\n\n        amountsOut = IExchange(exchange).swapExactTokensForTokens(\n            _amount,\n            ((amountOutCal[length - 1] * (10000 - SLIPPAGE)) / 10000),\n            _path,\n            address(this),\n            block.timestamp + 1\n        );\n\n        // Received amount is the second element of the return value\n        received = amountsOut[length - 1];\n\n        emit PremiumSwapped(_fromToken, _amount, received);\n    }\n\n    /**\n     * @notice Check the cover length\n     *\n     * @param _length Length to check (in month)\n     *\n     * @return withinLength Whether the cover is within the length\n     */\n    function _withinLength(uint256 _length) internal pure returns (bool) {\n        return _length > 0 && _length <= MAX_COVER_LENGTH;\n    }\n\n    /**\n     * @notice Check cover right tokens\n     *         If the crToken does not exist, it will be deployed here\n     *\n     * @param _poolId        Pool id\n     * @param _coverDuration Cover length in month\n     *\n     * @return crToken Cover right token address\n     */\n    function _checkCRToken(uint256 _poolId, uint256 _coverDuration)\n        internal\n        returns (address crToken)\n    {\n        // Get the expiry timestamp\n        (uint256 expiry, uint256 year, uint256 month) = DateTimeLibrary\n            ._getExpiry(block.timestamp, _coverDuration);\n\n        (\n            string memory poolName,\n            address poolAddress,\n            ,\n            ,\n\n        ) = IPriorityPoolFactory(priorityPoolFactory).pools(_poolId);\n\n        uint256 generation = IPriorityPool(poolAddress).generation();\n\n        crToken = _getCRTokenAddress(_poolId, expiry, generation);\n        if (crToken == address(0)) {\n            // CR-JOE-2022-1-G1\n            string memory tokenName = string.concat(\n                \"CR-\",\n                poolName,\n                \"-\",\n                year._toString(),\n                \"-\",\n                month._toString(),\n                \"-G\",\n                generation._toString()\n            );\n\n            crToken = ICoverRightTokenFactory(coverRightTokenFactory)\n                .deployCRToken(\n                    poolName,\n                    _poolId,\n                    tokenName,\n                    expiry,\n                    generation\n                );\n        }\n    }\n\n    /**\n     * @notice Check whether need to deploy new cr token\n     *\n     * @param _poolId        Pool id\n     * @param _poolName      Pool name\n     * @param _expiry        Expiry timestamp of the cr token\n     * @param _newGeneration New generation of the cr token\n     *\n     * @return newCRToken New cover right token address\n     */\n    function _checkNewCRToken(\n        uint256 _poolId,\n        string memory _poolName,\n        uint256 _expiry,\n        uint256 _newGeneration\n    ) internal returns (address newCRToken) {\n        (uint256 year, uint256 month, ) = DateTimeLibrary.timestampToDate(\n            _expiry\n        );\n\n        // Check the cr token exist\n        newCRToken = _getCRTokenAddress(_poolId, _expiry, _newGeneration);\n\n        // If cr token not exists, deploy it\n        if (newCRToken == address(0)) {\n            // CR-JOE-2022-1-G1\n            string memory tokenName = string.concat(\n                \"CR-\",\n                _poolName,\n                \"-\",\n                year._toString(),\n                \"-\",\n                month._toString(),\n                \"-G\",\n                _newGeneration._toString()\n            );\n\n            newCRToken = ICoverRightTokenFactory(coverRightTokenFactory)\n                .deployCRToken(\n                    _poolName,\n                    _poolId,\n                    tokenName,\n                    _expiry,\n                    _newGeneration\n                );\n        }\n    }\n\n    /**\n     * @notice Get cover right token address\n     *         The address is determined by poolId and expiry (last second of each month)\n     *         If token not exist, it will return zero address\n     *\n     * @param _poolId     Pool id\n     * @param _expiry     Expiry timestamp\n     * @param _generation Generation of the priority pool\n     *\n     * @return crToken Cover right token address\n     */\n    function _getCRTokenAddress(\n        uint256 _poolId,\n        uint256 _expiry,\n        uint256 _generation\n    ) internal view returns (address) {\n        bytes32 salt = keccak256(\n            abi.encodePacked(_poolId, _expiry, _generation)\n        );\n\n        return\n            ICoverRightTokenFactory(coverRightTokenFactory).saltToAddress(salt);\n    }\n\n    /**\n     * @notice Get native token amount to pay\n     *\n     * @param _premium Premium in USD\n     * @param _token   Native token address\n     *\n     * @return premiumInNativeToken Premium calculated in native token\n     */\n    function _getNativeTokenAmount(uint256 _premium, address _token)\n        internal\n        returns (uint256 premiumInNativeToken)\n    {\n        // Price in 18 decimals\n        uint256 price;\n        if (oracleType[_token] == 0) {\n            // By default use chainlink\n            price = IPriceGetter(priceGetter).getLatestPrice(_token);\n        } else if (oracleType[_token] == 1) {\n            // If no chainlink oracle, use dex price getter\n            price = IPriceGetter(dexPriceGetter).getLatestPrice(_token);\n        } else revert(\"Wrong type\");\n\n        // @audit Fix decimal for native tokens\n        // Check the real decimal diff\n        uint256 decimalDiff = IERC20Decimals(_token).decimals() - 6;\n        premiumInNativeToken = (_premium * 1e18 * (10**decimalDiff)) / price;\n\n        // Pay native tokens\n        SimpleIERC20(_token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            premiumInNativeToken\n        );\n    }\n\n    /**\n     * @notice Split premium for a pool\n     *         To priority pool is paid in native token\n     *         To protection pool and treasury is paid in usdc\n     *\n     * @param _poolId       Pool id\n     * @param _premiumInUSD Premium in USD\n     * @param _path         Swap path\n     *\n     * @return toPriority   Premium to priority pool\n     * @return toProtection Premium to protection pool\n     * @return toTreasury   Premium to treasury\n     */\n    function _splitPremium(\n        uint256 _poolId,\n        uint256 _premiumInUSD,\n        address[] memory _path\n    )\n        internal\n        returns (\n            uint256 toPriority,\n            uint256 toProtection,\n            uint256 toTreasury\n        )\n    {\n        if (_premiumInUSD == 0) revert PolicyCenter__ZeroPremium();\n\n        address nativeToken = tokenByPoolId[_poolId];\n\n        // Premium in project native token (paid in internal function)\n        uint256 premiumInNativeToken = _getNativeTokenAmount(\n            _premiumInUSD,\n            nativeToken\n        );\n\n        // Native tokens to Priority pool\n        toPriority = (premiumInNativeToken * PREMIUM_TO_PRIORITY) / 10000;\n\n        // Swap native tokens to usdc\n        // Except for amount to priority pool, remaining is distributed in usdc\n        uint256 amountToSwap = premiumInNativeToken - toPriority;\n        // USDC amount received\n        uint256 amountReceived = _swapTokens(nativeToken, amountToSwap, _path);\n\n        // USDC to Protection Pool\n        toProtection =\n            (amountReceived * PREMIUM_TO_PROTECTION) /\n            (PREMIUM_TO_PROTECTION + PREMIUM_TO_TREASURY);\n        // USDC to Treasury\n        toTreasury = amountReceived - toProtection;\n\n        emit PremiumSplitted(toPriority, toProtection, toTreasury);\n\n        // @audit Add real transfer\n        // Transfer tokens to different pools\n        SimpleIERC20(nativeToken).transfer(weightedFarmingPool, toPriority);\n        SimpleIERC20(USDC).transfer(protectionPool, toProtection);\n        SimpleIERC20(USDC).transfer(treasury, toTreasury);\n    }\n\n    /**\n     * @notice Approve a pool token for the exchange\n     *\n     * @param _token Token address\n     */\n    function _approvePoolToken(address _token) internal {\n        if (exchange == address(0)) revert PolicyCenter__NoExchange();\n        // approve exchange to swap policy center tokens for deg\n        SimpleIERC20(_token).approve(exchange, type(uint256).max);\n    }\n\n    /**\n     * @notice Get cover price from insurance pool\n     *\n     * @param _poolId        Pool id\n     * @param _coverAmount   Cover amount (usdc)\n     * @param _coverDuration Cover length in months (1,2,3)\n     */\n    function _getCoverPrice(\n        uint256 _poolId,\n        uint256 _coverAmount,\n        uint256 _coverDuration\n    ) internal view returns (uint256 price, uint256 timestampDuration) {\n        (price, timestampDuration) = IPriorityPool(priorityPools[_poolId])\n            .coverPrice(_coverAmount, _coverDuration);\n    }\n\n    /**\n     * @notice Check priority pool capacity\n     *\n     * @param _poolId      Pool id\n     * @param _coverAmount Amount (usdc) to cover\n     */\n    function _checkCapacity(uint256 _poolId, uint256 _coverAmount)\n        internal\n        view\n    {\n        IPriorityPool pool = IPriorityPool(priorityPools[_poolId]);\n        uint256 maxCapacityAmount = (SimpleIERC20(USDC).balanceOf(\n            address(protectionPool)\n        ) * pool.maxCapacity()) / 10000;\n\n        if (maxCapacityAmount < _coverAmount + pool.activeCovered())\n            revert PolicyCenter__InsufficientCapacity();\n    }\n}\n"
    },
    "src/core/interfaces/PolicyCenterEventError.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface PolicyCenterEventError {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event CoverBought(\n        address indexed buyer,\n        uint256 indexed poolId,\n        uint256 coverDuration,\n        uint256 coverAmount,\n        uint256 premiumInUSDC\n    );\n\n    event LiquidityProvided(address indexed user, uint256 amount);\n\n    event LiquidityStaked(\n        address indexed user,\n        uint256 indexed poolId,\n        uint256 amount\n    );\n\n    event LiquidityStakedWithoutFarming(\n        address indexed user,\n        uint256 indexed poolId,\n        uint256 amount\n    );\n\n    event LiquidityUnstaked(\n        address indexed user,\n        uint256 indexed poolId,\n        address priorityLP,\n        uint256 amount\n    );\n\n    event LiquidityUnstakedWithoutFarming(\n        address indexed user,\n        uint256 indexed poolId,\n        address priorityLP,\n        uint256 amount\n    );\n\n    event LiquidityRemoved(address indexed user, uint256 amount);\n\n    event PayoutClaimed(address indexed user, uint256 amount);\n\n    event PremiumSplitted(\n        uint256 toPriority,\n        uint256 toProtection,\n        uint256 toTreasury\n    );\n\n    event PremiumSwapped(address fromToken, uint256 amount, uint256 received);\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error PolicyCenter__AlreadyClaimedPayout(); // a2ded9c1\n    error PolicyCenter__WrongPriorityPoolID(); // 67f304bf\n    error PolicyCenter__InsufficientCapacity(); // 7730dc0b\n    error PolicyCenter__OnlyPriorityPoolFactory(); // aca500b4\n    error PolicyCenter__ZeroPremium(); // 720794bf\n    error PolicyCenter__NoLiquidity(); // d5c16599\n    error PolicyCenter__NoExchange(); // 7bb995d0\n    error PolicyCenter__ZeroAmount(); // 1613633b\n    error PolicyCenter__NoPayout(); // 6e472dea\n    error PolicyCenter__NonExistentPool(); // 5824d49b\n    error PolicyCenter__BadLength(); //\n    error PolicyCenter__PremiumTooHigh(); //\n    error PolicyCenter__InvalidPremiumSplit(); //\n    error PolicyCenter__PoolPaused(); //\n    error PolicyCenter__OnlyTreasury(); //\n    error PolicyCenter__WrongPath();\n}\n"
    },
    "src/interfaces/IPriceGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.13;\n\ninterface IPriceGetter {\n    function getLatestPrice(string memory _tokenName)\n        external\n        returns (uint256 price);\n\n    function getLatestPrice(address _token) external returns (uint256 price);\n}\n"
    },
    "src/libraries/StringUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nlibrary StringUtils {\n    function _toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "src/libraries/SimpleSafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../util/SimpleIERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nlibrary SimpleSafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        SimpleIERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        SimpleIERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(SimpleIERC20 token, bytes memory data)\n        private\n    {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n"
    },
    "src/pools/priorityPool/PriorityPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport \"../../util/PausableWithoutContext.sol\";\n\nimport \"./PriorityPoolDependencies.sol\";\nimport \"./PriorityPoolEventError.sol\";\nimport \"./PriorityPoolToken.sol\";\n\nimport \"../../libraries/DateTime.sol\";\nimport \"../../libraries/StringUtils.sol\";\n\n/**\n * @title Priority Pool (for single project)\n *\n * @author Eric Lee (ylikp.ust@gmail.com) & Primata (primata@375labs.org)\n *\n * @notice Priority pool is used for protecting a specific project\n *         Each priority pool has a maxCapacity (0 ~ 10,000 <=> 0 ~ 100%) that it can cover\n *         (that ratio represents the part of total assets in Protection Pool)\n *\n *         When liquidity providers join a priority pool,\n *         they need to transfer their RP_LP token to this priority pool.\n *\n *         After that, they can share the 45% percent native token reward of this pool.\n *         At the same time, that also means these liquidity will be first liquidated,\n *         when there is an incident happened for this project.\n *\n *         This reward is distributed in another contract (WeightedFarmingPool)\n *         By default, policy center will help user to deposit into farming pool when staking liquidity\n *\n *         For liquidation process, the pool will first redeem USDC from protectionPool with the staked RP_LP tokens.\n *         - If that is enough, no more redeeming.\n *         - If still need some liquidity to cover, it will directly transfer part of the protectionPool assets to users.\n *\n *         Most of the functions need to be called through Policy Center:\n *             1) When buying new covers: updateWhenBuy\n *             2) When staking liquidity: stakedLiquidity\n *             3) When unstaking liquidity: unstakedLiquidity\n *\n */\ncontract PriorityPool is\n    PriorityPoolEventError,\n    PausableWithoutContext,\n    PriorityPoolDependencies\n{\n    using StringUtils for uint256;\n    using DateTimeLibrary for uint256;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Mininum cover amount 10U\n    // Avoid accuracy issues\n    uint256 internal constant MIN_COVER_AMOUNT = 10e6;\n\n    // Max time length in month\n    uint256 internal constant MAX_LENGTH = 3;\n\n    // Min time length in month\n    uint256 internal constant MIN_LENGTH = 1;\n\n    address internal immutable owner;\n\n    // Base premium ratio (max 10000) (260 means 2.6% annually)\n    uint256 public immutable basePremiumRatio;\n\n    // Pool id set when deployed\n    uint256 public immutable poolId;\n\n    // Timestamp of pool creation\n    uint256 public immutable startTime;\n\n    // Address of insured token (used for premium payment)\n    address public immutable insuredToken;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Pool name\n    string public poolName;\n\n    // Current generation of this priority pool (start from 1)\n    // Every time there is a report and liquidation, generation += 1\n    uint256 public generation;\n\n    // Max capacity of cover amount to be bought (ratio of total liquidity)\n    // 10000 = 100%\n    uint256 public maxCapacity;\n\n    // Index for cover amount\n    uint256 public coverIndex;\n\n    // Has already passed the base premium ratio period\n    bool public passedBasePeriod;\n\n    // Year => Month => Amount of cover ends in that month\n    mapping(uint256 => mapping(uint256 => uint256)) public coverInMonth;\n\n    // Generation => lp token address\n    mapping(uint256 => address) public lpTokenAddress;\n\n    // Address => Whether is LP address\n    mapping(address => bool) public isLPToken;\n\n    // PRI-LP address => Price of lp tokens\n    // PRI-LP token amount * Price Index = PRO-LP token amount\n    mapping(address => uint256) public priceIndex;\n\n    mapping(uint256 => mapping(uint256 => uint256)) public payoutInMonth;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(\n        uint256 _poolId,\n        string memory _name,\n        address _protocolToken,\n        uint256 _maxCapacity,\n        uint256 _baseRatio,\n        address _owner,\n        address _priorityPoolFactory,\n        address _weightedFarmingPool,\n        address _protectionPool,\n        address _policyCenter,\n        address _payoutPool\n    ) {\n        owner = _owner;\n\n        poolId = _poolId;\n        poolName = _name;\n\n        insuredToken = _protocolToken;\n        maxCapacity = _maxCapacity;\n        startTime = block.timestamp;\n\n        basePremiumRatio = _baseRatio;\n\n        // Generation 1, price starts from 1 (SCALE)\n        priceIndex[_deployNewGenerationLP(_weightedFarmingPool)] = SCALE;\n\n        coverIndex = 10000;\n\n        priorityPoolFactory = _priorityPoolFactory;\n\n        weightedFarmingPool = _weightedFarmingPool;\n        protectionPool = _protectionPool;\n        policyCenter = _policyCenter;\n        payoutPool = _payoutPool;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    modifier onlyExecutor() {\n        if (msg.sender != IPriorityPoolFactory(priorityPoolFactory).executor())\n            revert PriorityPool__OnlyExecutor();\n        _;\n    }\n\n    modifier onlyPolicyCenter() {\n        if (msg.sender != policyCenter) revert PriorityPool__OnlyPolicyCenter();\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the current generation PRI-LP token address\n     *\n     * @return lpAddress Current pri-lp address\n     */\n    function currentLPAddress() public view returns (address) {\n        return lpTokenAddress[generation];\n    }\n\n    /**\n     * @notice Cost to buy a cover for a given period of time and amount of tokens\n     *\n     * @param _amount        Amount being covered (usdc)\n     * @param _coverDuration Cover length in month\n     *\n     * @return price  Cover price in usdc\n     * @return length Real length in timestamp\n     */\n    function coverPrice(uint256 _amount, uint256 _coverDuration)\n        external\n        view\n        returns (uint256 price, uint256 length)\n    {\n        _checkAmount(_amount);\n\n        // Dynamic premium ratio (annually)\n        uint256 dynamicRatio = dynamicPremiumRatio(_amount);\n\n        (uint256 endTimestamp, , ) = DateTimeLibrary._getExpiry(\n            block.timestamp,\n            _coverDuration\n        );\n\n        // Length in second\n        length = endTimestamp - block.timestamp;\n\n        // Price depends on the real timestamp length\n        price = (dynamicRatio * _amount * length) / (SECONDS_PER_YEAR * 10000);\n    }\n\n    /**\n     * @notice Get current active cover amount\n     *         Active cover amount = sum of the nearest 3 months' covers\n     *\n     * @return covered Total active cover amount\n     */\n    function activeCovered() public view returns (uint256 covered) {\n        (uint256 currentYear, uint256 currentMonth, ) = block\n            .timestamp\n            .timestampToDate();\n\n        // Only count the latest 3 months\n        for (uint256 i; i < 3; ) {\n            covered += (coverInMonth[currentYear][currentMonth] -\n                payoutInMonth[currentYear][currentMonth]);\n\n            unchecked {\n                if (++currentMonth > 12) {\n                    ++currentYear;\n                    currentMonth = 1;\n                }\n\n                ++i;\n            }\n        }\n\n        covered = (covered * coverIndex) / 10000;\n    }\n\n    /**\n     * @notice Current minimum asset requirement for Protection Pool\n     *         Min requirement * capacity ratio = active covered\n     *\n     *         Total assets in protection pool should be larger than any of the \"minAssetRequirement\"\n     *         Or the cover index would be cut\n     */\n    function minAssetRequirement() external view returns (uint256) {\n        return (activeCovered() * 10000) / maxCapacity;\n    }\n\n    /**\n     * @notice Get the dynamic premium ratio (annually)\n     *         Depends on the covers sold and liquidity amount in all dynamic priority pools\n     *         For the first 7 days, use the base premium ratio\n     *\n     * @param _coverAmount New cover amount (usdc) being bought\n     *\n     * @return ratio The dynamic ratio\n     */\n    function dynamicPremiumRatio(uint256 _coverAmount)\n        public\n        view\n        returns (uint256 ratio)\n    {\n        // Time passed since this pool started\n        uint256 fromStart = block.timestamp - startTime;\n\n        uint256 totalActiveCovered = IProtectionPool(protectionPool)\n            .getTotalActiveCovered();\n\n        uint256 stakedProSupply = IProtectionPool(protectionPool)\n            .stakedSupply();\n\n        // First 7 days use base ratio\n        // Then use dynamic ratio\n        // TODO: test use 5 hours\n        if (fromStart > DYNAMIC_TIME) {\n            // Total dynamic pools\n            uint256 numofDynamicPools = IPriorityPoolFactory(\n                priorityPoolFactory\n            ).dynamicPoolCounter();\n\n            if (\n                numofDynamicPools > 0 &&\n                totalActiveCovered > 0 &&\n                stakedProSupply > 0\n            ) {\n                // Covered ratio = Covered amount of this pool / Total covered amount\n                uint256 coveredRatio = ((activeCovered() + _coverAmount) *\n                    SCALE) / (totalActiveCovered + _coverAmount);\n\n                address lp = currentLPAddress();\n\n                //                         PRO-LP token in this pool\n                // LP Token ratio =  -------------------------------------------\n                //                    PRO-LP token staked in all priority pools\n                //\n                uint256 tokenRatio = (SimpleERC20(lp).totalSupply() * SCALE) /\n                    stakedProSupply;\n\n                // Dynamic premium ratio\n                // ( N = total dynamic pools  total pools )\n                //\n                //                      Covered          1\n                //                   --------------- + -----\n                //                    TotalCovered       N\n                // dynamic ratio =  -------------------------- * base ratio\n                //                      LP Amount         1\n                //                  ----------------- + -----\n                //                   Total LP Amount      N\n                //\n                ratio =\n                    (basePremiumRatio *\n                        (coveredRatio * numofDynamicPools + SCALE)) /\n                    ((tokenRatio * numofDynamicPools) + SCALE);\n            } else ratio = basePremiumRatio;\n        } else {\n            ratio = basePremiumRatio;\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set the max capacity of this priority pool manually\n     *         Only owner set this function on a monthly / quaterly base\n     *         (For those unpopular pools to decrease, and those popular ones to increase)\n     *\n     * @param _maxCapacity New max capacity of this pool\n     */\n    function setMaxCapacity(uint256 _maxCapacity) external {\n        require(msg.sender == owner, \"Only owner\");\n\n        maxCapacity = _maxCapacity;\n\n        bool isUp = _maxCapacity > maxCapacity;\n\n        uint256 diff;\n        if (isUp) {\n            diff = _maxCapacity - maxCapacity;\n        } else {\n            diff = maxCapacity - _maxCapacity;\n        }\n\n        // Store the max capacity change\n        IPriorityPoolFactory(priorityPoolFactory).updateMaxCapacity(isUp, diff);\n    }\n\n    /**\n     * @notice Set the cover index of this priority pool\n     *\n     *         Only called from protection pool\n     *\n     *         When a payout happened in another priority pool,\n     *         and this priority pool's minAssetRequirement is less than proteciton pool's asset,\n     *         the cover index of this pool will be cut by a ratio\n     *\n     * @param _newIndex New cover index\n     */\n    function setCoverIndex(uint256 _newIndex) external {\n        require(msg.sender == protectionPool, \"Only protection pool\");\n\n        emit CoverIndexChanged(coverIndex, _newIndex);\n        coverIndex = _newIndex;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Provide liquidity to priority pool\n     *         Only callable through policyCenter\n     *         Can not provide new liquidity when paused\n     *\n     * @param _amount   Amount of liquidity (PRO-LP token) to provide\n     * @param _provider Liquidity provider adress\n     */\n    function stakedLiquidity(uint256 _amount, address _provider)\n        external\n        whenNotPaused\n        onlyPolicyCenter\n        returns (address)\n    {\n        // Check whether this priority pool should be dynamic\n        // If so, update it\n        _updateDynamic();\n\n        // Mint current generation lp tokens to the provider\n        // PRI-LP amount always 1:1 to PRO-LP\n        _mintLP(_provider, _amount);\n        emit StakedLiquidity(_amount, _provider);\n\n        return currentLPAddress();\n    }\n\n    /**\n     * @notice Remove liquidity from priority pool\n     *         Only callable through policyCenter\n     *\n     * @param _lpToken  Address of PRI-LP token\n     * @param _amount   Amount of liquidity (PRI-LP) to remove\n     * @param _provider Provider address\n     */\n    function unstakedLiquidity(\n        address _lpToken,\n        uint256 _amount,\n        address _provider\n    ) external whenNotPaused onlyPolicyCenter {\n        if (!isLPToken[_lpToken]) revert PriorityPool__WrongLPToken();\n\n        // Check whether this priority pool should be dynamic\n        // If so, update it\n        _updateDynamic();\n\n        // Burn PRI-LP tokens and transfer PRO-LP tokens back\n        _burnLP(_lpToken, _provider, _amount);\n        emit UnstakedLiquidity(_amount, _provider);\n    }\n\n    /**\n     * @notice Update the record when new policy is bought\n     *         Only called from policy center\n     *\n     * @param _amount          Cover amount (usdc)\n     * @param _premium         Premium for priority pool (in protocol token)\n     * @param _length          Cover length (in month)\n     * @param _timestampLength Cover length (in second)\n     */\n    function updateWhenBuy(\n        uint256 _amount,\n        uint256 _premium,\n        uint256 _length,\n        uint256 _timestampLength\n    ) external whenNotPaused onlyPolicyCenter {\n        // Check cover length\n        _checkLength(_length);\n\n        // Check cover amount\n        _checkAmount(_amount);\n\n        _updateDynamic();\n\n        // Record cover amount in each month\n        _updateCoverInfo(_amount, _length);\n\n        // Update the weighted farming pool speed for this priority pool\n        uint256 newSpeed = (_premium * SCALE) / _timestampLength;\n        _updateWeightedFarmingSpeed(_length, newSpeed);\n    }\n\n    function _checkLength(uint256 _length) internal pure {\n        if (_length > MAX_LENGTH || _length < MIN_LENGTH)\n            revert PriorityPool__WrongCoverLength();\n    }\n\n    /**\n     * @notice Pause this pool\n     *\n     * @param _paused True to pause, false to unpause\n     */\n    function pausePriorityPool(bool _paused) external {\n        if ((msg.sender != owner) && (msg.sender != priorityPoolFactory))\n            revert PriorityPool__NotOwnerOrFactory();\n\n        _pause(_paused);\n    }\n\n    /**\n     * @notice Liquidate pool\n     *         Only callable by executor\n     *         Only after the report has passed the voting\n     *\n     * @param _amount Payout amount to be moved out\n     */\n    function liquidatePool(uint256 _amount) external onlyExecutor {\n        uint256 payout = _amount > activeCovered() ? activeCovered() : _amount;\n\n        uint256 payoutRatio = _retrievePayout(payout);\n\n        _updateCurrentLPWeight();\n\n        _updateCoveredWhenLiquidated(payoutRatio);\n\n        // Generation ++\n        // Deploy the new generation lp token\n        // Those who stake liquidity into this priority pool will be given the new lp token\n        _deployNewGenerationLP(weightedFarmingPool);\n\n        // Update other pools' cover indexes\n        IProtectionPool(protectionPool).updateIndexCut();\n\n        emit Liquidation(_amount, generation);\n    }\n\n    function _updateCoveredWhenLiquidated(uint256 _payoutRatio) internal {\n        (uint256 currentYear, uint256 currentMonth, ) = block\n            .timestamp\n            .timestampToDate();\n\n        // Only count the latest 3 months\n        for (uint256 i; i < 3; ) {\n            payoutInMonth[currentYear][currentMonth] =\n                (coverInMonth[currentYear][currentMonth] * _payoutRatio) /\n                SCALE;\n\n            unchecked {\n                if (++currentMonth > 12) {\n                    ++currentYear;\n                    currentMonth = 1;\n                }\n\n                ++i;\n            }\n        }\n    }\n\n    function updateWhenClaimed(uint256 _expiry, uint256 _amount) external {\n        require(msg.sender == payoutPool, \"Only payout pool\");\n\n        (uint256 currentYear, uint256 currentMonth, ) = _expiry\n            .timestampToDate();\n\n        coverInMonth[currentYear][currentMonth] -= _amount;\n        payoutInMonth[currentYear][currentMonth] -= _amount;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check & update dynamic status of this pool\n     *         Record this pool as \"already dynamic\" in factory\n     *\n     *         Every time there is a new interaction, will do this check\n     */\n    function _updateDynamic() internal {\n        // Put the cheaper check in the first place\n        if (!passedBasePeriod && (block.timestamp - startTime > DYNAMIC_TIME)) {\n            IPriorityPoolFactory(priorityPoolFactory).updateDynamicPool(poolId);\n            passedBasePeriod = true;\n        }\n    }\n\n    function _checkAmount(uint256 _amount) internal pure {\n        if (_amount < MIN_COVER_AMOUNT)\n            revert PriorityPool__UnderMinCoverAmount();\n    }\n\n    /**\n     * @notice Deploy a new generation lp token\n     *         Generation starts from 1\n     *\n     * @return newLPAddress The deployed lp token address\n     */\n    function _deployNewGenerationLP(address _weightedFarmingPool)\n        internal\n        returns (address newLPAddress)\n    {\n        uint256 currentGeneration = ++generation;\n\n        // PRI-LP-2-JOE-G1: First generation of JOE priority pool with pool id 2\n        string memory _name = string.concat(\n            \"PRI-LP-\",\n            poolId._toString(),\n            \"-\",\n            poolName,\n            \"-G\",\n            currentGeneration._toString()\n        );\n\n        newLPAddress = address(new PriorityPoolToken(_name));\n        lpTokenAddress[currentGeneration] = newLPAddress;\n\n        IWeightedFarmingPool(_weightedFarmingPool).addToken(\n            poolId,\n            newLPAddress,\n            SCALE\n        );\n\n        priceIndex[newLPAddress] = SCALE;\n\n        isLPToken[newLPAddress] = true;\n\n        emit NewGenerationLPTokenDeployed(\n            poolName,\n            poolId,\n            currentGeneration,\n            _name,\n            newLPAddress\n        );\n    }\n\n    /**\n     * @notice Mint current generation lp tokens\n     *\n     * @param _user   User address\n     * @param _amount PRI-LP token amount\n     */\n    function _mintLP(address _user, uint256 _amount) internal {\n        // Get current generation lp token address and mint tokens\n        address lp = currentLPAddress();\n        PriorityPoolToken(lp).mint(_user, _amount);\n    }\n\n    /**\n     * @notice Burn lp tokens\n     *         Need specific generation lp token address as parameter\n     *\n     * @param _lpToken PRI-LP token adderss\n     * @param _user    User address\n     * @param _amount  PRI-LP token amount to burn\n     */\n    function _burnLP(\n        address _lpToken,\n        address _user,\n        uint256 _amount\n    ) internal {\n        // Transfer PRO-LP token to user\n        uint256 proLPAmount = (priceIndex[_lpToken] * _amount) / SCALE;\n        SimpleERC20(protectionPool).transfer(_user, proLPAmount);\n\n        // Burn PRI-LP token\n        PriorityPoolToken(_lpToken).burn(_user, _amount);\n    }\n\n    /**\n     * @notice Update cover record info when new covers come in\n     *         Record the total cover amount in each month\n     *\n     * @param _amount Cover amount\n     * @param _length Cover length in month\n     */\n    function _updateCoverInfo(uint256 _amount, uint256 _length) internal {\n        (uint256 currentYear, uint256 currentMonth, uint256 currentDay) = block\n            .timestamp\n            .timestampToDate();\n\n        uint256 monthsToAdd = _length - 1;\n\n        if (currentDay >= 25) {\n            monthsToAdd++;\n        }\n\n        uint256 endYear = currentYear;\n        uint256 endMonth;\n\n        // Check if the cover will end in the same year\n        if (currentMonth + monthsToAdd > 12) {\n            endMonth = currentMonth + monthsToAdd - 12;\n            ++endYear;\n        } else {\n            endMonth = currentMonth + monthsToAdd;\n        }\n\n        coverInMonth[endYear][endMonth] += _amount;\n    }\n\n    /**\n     * @notice Update the farming speed in WeightedFarmingPool\n     *\n     * @param _length   Length in month\n     * @param _newSpeed Speed to be added (SCALED)\n     */\n    function _updateWeightedFarmingSpeed(uint256 _length, uint256 _newSpeed)\n        internal\n    {\n        uint256[] memory _years = new uint256[](_length);\n        uint256[] memory _months = new uint256[](_length);\n\n        (uint256 currentYear, uint256 currentMonth, ) = block\n            .timestamp\n            .timestampToDate();\n\n        for (uint256 i; i < _length; ) {\n            _years[i] = currentYear;\n            _months[i] = currentMonth;\n\n            unchecked {\n                if (++currentMonth > 12) {\n                    ++currentYear;\n                    currentMonth = 1;\n                }\n                ++i;\n            }\n        }\n\n        IWeightedFarmingPool(weightedFarmingPool).updateRewardSpeed(\n            poolId,\n            _newSpeed,\n            _years,\n            _months\n        );\n    }\n\n    /**\n     * @notice Retrieve assets from Protection Pool for payout\n     *\n     * @param _amount Amount of usdc to retrieve\n     */\n    function _retrievePayout(uint256 _amount)\n        internal\n        returns (uint256 payoutRatio)\n    {\n        // Current PRO-LP amount\n        uint256 currentLPAmount = SimpleERC20(protectionPool).balanceOf(\n            address(this)\n        );\n\n        IProtectionPool proPool = IProtectionPool(protectionPool);\n\n        uint256 proLPPrice = proPool.getLatestPrice();\n\n        // Need how many PRO-LP tokens to cover the _amount\n        uint256 neededLPAmount = (_amount * SCALE) / proLPPrice;\n\n        // If current PRO-LP inside priority pool is enough\n        // Remove part of the liquidity from Protection Pool\n        if (neededLPAmount < currentLPAmount) {\n            proPool.removedLiquidity(neededLPAmount, payoutPool);\n\n            priceIndex[currentLPAddress()] =\n                ((currentLPAmount - neededLPAmount) * SCALE) /\n                currentLPAmount;\n        } else {\n            uint256 usdcGot = proPool.removedLiquidity(\n                currentLPAmount,\n                payoutPool\n            );\n\n            uint256 remainingPayout = _amount - usdcGot;\n\n            proPool.removedLiquidityWhenClaimed(remainingPayout, payoutPool);\n\n            priceIndex[currentLPAddress()] = 0;\n        }\n\n        // Set a ratio used when claiming with crTokens\n        // E.g. ratio is 1e11\n        //      You can only use 10% (1e11 / SCALE) of your crTokens for claiming\n        activeCovered() > 0\n            ? payoutRatio = (_amount * SCALE) / activeCovered()\n            : payoutRatio = 0;\n\n        IPayoutPool(payoutPool).newPayout(\n            poolId,\n            generation,\n            _amount,\n            payoutRatio,\n            coverIndex,\n            address(this)\n        );\n    }\n\n    function _updateCurrentLPWeight() internal {\n        address lp = currentLPAddress();\n\n        // Update the farming pool with the new price index\n        IWeightedFarmingPool(weightedFarmingPool).updateWeight(\n            poolId,\n            lp,\n            priceIndex[lp]\n        );\n    }\n}\n"
    },
    "src/util/PausableWithoutContext.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nabstract contract PausableWithoutContext {\n    bool private _paused;\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Paused\");\n        _;\n    }\n\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    function _pause(bool _p) internal virtual {\n        _paused = _p;\n    }\n}\n"
    },
    "src/pools/priorityPool/PriorityPoolDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IPriorityPoolFactory {\n    function dynamicPoolCounter() external view returns (uint256);\n\n    function updateMaxCapacity(bool _isUp, uint256 _maxCapacity) external;\n\n    function updateDynamicPool(uint256 _poolId) external;\n\n    function executor() external view returns (address);\n}\n\ninterface IProtectionPool {\n    function getTotalActiveCovered() external view returns (uint256);\n\n    function getLatestPrice() external returns (uint256);\n\n    function removedLiquidity(uint256 _amount, address _provider)\n        external\n        returns (uint256);\n\n    function removedLiquidityWhenClaimed(uint256 _amount, address _to) external;\n\n    function pauseProtectionPool(bool _paused) external;\n\n    function stakedSupply() external view returns (uint256);\n\n    function updateIndexCut() external;\n}\n\ninterface IPolicyCenter {\n    function storePoolInformation(\n        address _pool,\n        address _token,\n        uint256 _poolId\n    ) external;\n}\n\ninterface IPayoutPool {\n    function newPayout(\n        uint256 _poolId,\n        uint256 _generation,\n        uint256 _amount,\n        uint256 _ratio,\n        uint256 _coverIndex,\n        address _poolAddress\n    ) external;\n}\n\ninterface IWeightedFarmingPool {\n    function addPool(address _token) external;\n\n    function addToken(\n        uint256 _id,\n        address _token,\n        uint256 _weight\n    ) external;\n\n    function updateRewardSpeed(\n        uint256 _id,\n        uint256 _newSpeed,\n        uint256[] memory _years,\n        uint256[] memory _months\n    ) external;\n\n    function updateWeight(\n        uint256 _id,\n        address _token,\n        uint256 _newWeight\n    ) external;\n}\n\nabstract contract PriorityPoolDependencies {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    uint256 internal constant SCALE = 1e12;\n    uint256 internal constant SECONDS_PER_YEAR = 86400 * 365;\n\n    // TODO: Different parameters for test and mainnet\n    uint256 internal constant DYNAMIC_TIME = 7 days;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    address internal policyCenter;\n    address internal priorityPoolFactory;\n    address internal protectionPool;\n    address internal weightedFarmingPool;\n    address internal payoutPool;\n}\n"
    },
    "src/pools/priorityPool/PriorityPoolEventError.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface PriorityPoolEventError {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event StakedLiquidity(uint256 amount, address sender);\n    event UnstakedLiquidity(uint256 amount, address sender);\n    event Liquidation(uint256 amount, uint256 generation);\n\n    event NewGenerationLPTokenDeployed(\n        string poolName,\n        uint256 poolId,\n        uint256 currentGeneration,\n        string name,\n        address newLPAddress\n    );\n\n    event CoverIndexChanged(uint256 oldIndex, uint256 newIndex);\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error PriorityPool__OnlyExecutor();\n    error PriorityPool__OnlyPolicyCenter();\n    error PriorityPool__NotOwnerOrFactory();\n    error PriorityPool__WrongLPToken();\n    error PriorityPool__WrongCoverLength();\n    error PriorityPool__UnderMinCoverAmount();\n}\n"
    },
    "src/pools/priorityPool/PriorityPoolToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\n\npragma solidity ^0.8.13;\n\nimport \"../../util/SimpleERC20.sol\";\n\n/**\n * @notice LP token for priority pools\n *\n *         This lp token can be deposited into farming pool to get the premium income\n *         LP token has different generations and they are different in names\n *\n *         E.g.  PRI-LP-2-JOE-G1 and PRI-LP-2-JOE-G2\n *               They are both lp tokens for priority pool 2 (JOE pool)\n *               But with different generations, they have different weights in farming\n *\n *         Every time there is a report for the project and some payout are given out\n *         There will be a new generation of lp token\n *\n *         The weight will be set when the report happened\n *         and will depend on how much part are paid during that report\n */\ncontract PriorityPoolToken is SimpleERC20 {\n    // Only minter and burner is Priority Pool\n    address private priorityPool;\n\n    modifier onlyPriorityPool() {\n        require(msg.sender == priorityPool, \"Only priority pool\");\n        _;\n    }\n\n    constructor(string memory _name) SimpleERC20(_name, \"PRI-LP\") {\n        priorityPool = msg.sender;\n    }\n\n    function mint(address _user, uint256 _amount) external onlyPriorityPool {\n        _mint(_user, _amount);\n    }\n\n    function burn(address _user, uint256 _amount) external onlyPriorityPool {\n        _burn(_user, _amount);\n    }\n}\n"
    },
    "src/util/SimpleERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nabstract contract SimpleERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public constant decimals = 6;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max)\n            allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "src/pools/priorityPool/PriorityPoolDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./PriorityPool.sol\";\n\ncontract PriorityPoolDeployer is Initializable {\n    address public owner;\n\n    address public priorityPoolFactory;\n    address public weightedFarmingPool;\n    address public protectionPool;\n    address public policyCenter;\n    address public payoutPool;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(\n        address _priorityPoolFactory,\n        address _weightedFarmingPool,\n        address _protectionPool,\n        address _policyCenter,\n        address _payoutPool\n    ) public initializer {\n        owner = msg.sender;\n\n        priorityPoolFactory = _priorityPoolFactory;\n        weightedFarmingPool = _weightedFarmingPool;\n        protectionPool = _protectionPool;\n        policyCenter = _policyCenter;\n        payoutPool = _payoutPool;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Create a new priority pool\n     *         Called by executor when an onboard proposal has passed\n     *\n     * @param _name             Name of the protocol\n     * @param _protocolToken    Address of the token used for the protocol\n     * @param _maxCapacity      Maximum capacity of the pool\n     * @param _basePremiumRatio Initial policy price per usdc\n     *\n     * @return address Address of the new insurance pool\n     */\n    function deployPool(\n        uint256 poolId,\n        string calldata _name,\n        address _protocolToken,\n        uint256 _maxCapacity,\n        uint256 _basePremiumRatio\n    ) public returns (address) {\n        require(\n            msg.sender == priorityPoolFactory || msg.sender == owner,\n            \"Only factory\"\n        );\n\n        address newPoolAddress = _deployPool(\n            poolId,\n            _name,\n            _protocolToken,\n            _maxCapacity,\n            _basePremiumRatio\n        );\n\n        return newPoolAddress;\n    }\n\n    function getPoolAddress(\n        uint256 _poolId,\n        string memory _name,\n        address _protocolToken,\n        uint256 _maxCapacity,\n        uint256 _baseRatio\n    ) public view returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(_poolId, _name));\n        bytes memory bytecodeWithParameters = _getBytecode(\n            _poolId,\n            _name,\n            _protocolToken,\n            _maxCapacity,\n            _baseRatio\n        );\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                keccak256(bytecodeWithParameters)\n            )\n        );\n\n        return address(uint160(uint256(hash)));\n    }\n\n    function _deployPool(\n        uint256 _poolId,\n        string memory _name,\n        address _protocolToken,\n        uint256 _maxCapacity,\n        uint256 _baseRatio\n    ) internal returns (address addr) {\n        bytes32 salt = keccak256(abi.encodePacked(_poolId, _name));\n\n        bytes memory bytecodeWithParameters = _getBytecode(\n            _poolId,\n            _name,\n            _protocolToken,\n            _maxCapacity,\n            _baseRatio\n        );\n\n        addr = _deploy(bytecodeWithParameters, salt);\n    }\n\n    function _getBytecode(\n        uint256 _poolId,\n        string memory _name,\n        address _protocolToken,\n        uint256 _maxCapacity,\n        uint256 _baseRatio\n    ) internal view returns (bytes memory bytecodeWithParameters) {\n        bytes memory bytecode = type(PriorityPool).creationCode;\n\n        bytecodeWithParameters = abi.encodePacked(\n            bytecode,\n            abi.encode(\n                _poolId,\n                _name,\n                _protocolToken,\n                _maxCapacity,\n                _baseRatio,\n                owner,\n                priorityPoolFactory,\n                weightedFarmingPool,\n                protectionPool,\n                policyCenter,\n                payoutPool\n            )\n        );\n    }\n\n    /**\n     * @notice Deploy function with create2\n     *\n     * @param _code Byte code of the contract (creation code) (including constructor parameters if any)\n     * @param _salt Salt for the deployment\n     *\n     * @return addr The deployed contract address\n     */\n    function _deploy(bytes memory _code, bytes32 _salt)\n        internal\n        returns (address addr)\n    {\n        assembly {\n            addr := create2(0, add(_code, 0x20), mload(_code), _salt)\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "src/priceGetter/DexPriceGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IPriceGetter} from \"../interfaces/IPriceGetter.sol\";\n\nimport {IUniswapV2Pair} from \"../libraries/IUniswapV2Pair.sol\";\nimport {FixedPoint} from \"../libraries/FixedPoint.sol\";\nimport {UniswapV2OracleLibrary} from \"../libraries/UniswapV2OracleLibrary.sol\";\nimport {UniswapV2Library} from \"../libraries/UniswapV2Library.sol\";\n\n/**\n * @title Price Getter for IDO Protection\n *\n * @notice This is the contract for getting price feed from DEX\n *         IDO projects does not have Chainlink feeds so we use DEX TWAP price as oracle\n *\n *         Workflow:\n *         1. Deploy naughty token for the IDO project and set its type as \"IDO\"\n *         2. Add ido price feed info by calling \"addIDOPair\" function\n *         3. Set auto tasks start within PERIOD to endTime to sample prices from DEX\n *         4. Call \"settleFinalResult\" function in core to settle the final price\n */\n\ncontract DexPriceGetter is OwnableUpgradeable {\n    using FixedPoint for *;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // WAVAX address\n    address public constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n    address public constant USDC = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Base price getter to transfer the price into USD\n    IPriceGetter public basePriceGetter;\n\n    struct IDOPriceInfo {\n        address pair; // Pair on TraderJoe\n        uint256 decimals; // If no special settings, it would be 0\n        uint256 sampleInterval;\n        uint256 isToken0;\n        uint256 priceAverage;\n        uint256 priceCumulativeLast;\n        uint256 lastTimestamp;\n    }\n    // Policy Base Token Name => IDO Info\n    mapping(string => IDOPriceInfo) public priceFeeds;\n\n    mapping(address => string) public addressToName;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event SamplePrice(\n        string policyToken,\n        uint256 priceAverage,\n        uint256 timestamp\n    );\n\n    event NewIDOPair(\n        string policyToken,\n        address pair,\n        uint256 decimals,\n        uint256 sampleInterval,\n        uint256 isToken0\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(address _priceGetter) public initializer {\n        __Ownable_init();\n\n        basePriceGetter = IPriceGetter(_priceGetter);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function addIDOPair(\n        string calldata _policyToken,\n        address _pair,\n        uint256 _decimals,\n        uint256 _interval\n    ) external onlyOwner {\n        require(IUniswapV2Pair(_pair).token0() != address(0), \"Non exist pair\");\n        require(\n            IUniswapV2Pair(_pair).token0() == WAVAX ||\n                IUniswapV2Pair(_pair).token1() == WAVAX,\n            \"Not avax pair\"\n        );\n        require(\n            priceFeeds[_policyToken].pair == address(0),\n            \"Pair already exists\"\n        );\n\n        IDOPriceInfo storage newFeed = priceFeeds[_policyToken];\n\n        newFeed.pair = _pair;\n        // Decimals should keep the priceAverage to have 18 decimals\n        // WAVAX always have 18 decimals\n        // E.g. Pair token both 18 decimals => price decimals 18\n        //      (5e18, 10e18) real price 0.5 => we show priceAverage 0.5 * 10^18\n        //      Pair token (18, 6) decimals => price decimals 6\n        //      (5e18, 10e6) real price 0.5 => we show priceAverage 0.5 * 10^18\n        newFeed.decimals = _decimals;\n        newFeed.sampleInterval = _interval;\n\n        // Check if the policy base token is token0\n        bool isToken0 = !(IUniswapV2Pair(_pair).token0() == WAVAX);\n\n        newFeed.isToken0 = isToken0 ? 1 : 0;\n\n        (, , newFeed.lastTimestamp) = IUniswapV2Pair(_pair).getReserves();\n\n        // Record the initial priceCumulativeLast\n        newFeed.priceCumulativeLast = isToken0\n            ? IUniswapV2Pair(_pair).price0CumulativeLast()\n            : IUniswapV2Pair(_pair).price1CumulativeLast();\n\n        emit NewIDOPair(\n            _policyToken,\n            _pair,\n            _decimals,\n            _interval,\n            newFeed.isToken0\n        );\n    }\n\n    /**\n     * @notice Set price in avax\n     *         Price in avax should be in 1e18\n     *\n     * @param _policyToken Policy token name\n     * @param _price       Price in avax\n     */\n    function setPrice(string calldata _policyToken, uint256 _price)\n        external\n        onlyOwner\n    {\n        priceFeeds[_policyToken].priceAverage = _price;\n    }\n\n    function setAddressToName(address _token, string memory _name)\n        external\n        onlyOwner\n    {\n        addressToName[_token] = _name;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function samplePrice(string calldata _policyToken) external {\n        IDOPriceInfo storage priceFeed = priceFeeds[_policyToken];\n\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint32 blockTimestamp\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(priceFeed.pair);\n\n        // Time between this sampling and last sampling (seconds)\n        uint32 timeElapsed = blockTimestamp - uint32(priceFeed.lastTimestamp);\n\n        uint256 decimals = priceFeed.decimals;\n\n        require(\n            timeElapsed > priceFeed.sampleInterval,\n            \"Minimum sample interval\"\n        );\n\n        // Update priceAverage and priceCumulativeLast\n        uint256 newPriceAverage;\n\n        if (priceFeed.isToken0 > 0) {\n            newPriceAverage = FixedPoint\n                .uq112x112(\n                    uint224(\n                        ((price0Cumulative - priceFeed.priceCumulativeLast) *\n                            10**decimals) / timeElapsed\n                    )\n                )\n                .decode();\n\n            priceFeed.priceCumulativeLast = price0Cumulative;\n        } else {\n            newPriceAverage = FixedPoint\n                .uq112x112(\n                    uint224(\n                        ((price1Cumulative - priceFeed.priceCumulativeLast) *\n                            10**decimals) / timeElapsed\n                    )\n                )\n                .decode();\n\n            priceFeed.priceCumulativeLast = price1Cumulative;\n        }\n\n        priceFeed.priceAverage = newPriceAverage;\n\n        // Update lastTimestamp\n        priceFeed.lastTimestamp = blockTimestamp;\n\n        emit SamplePrice(_policyToken, newPriceAverage, blockTimestamp);\n    }\n\n    /**\n     * @notice Get latest price of a token\n     *\n     * @param _token Address of the token\n     *\n     * @return price The latest price\n     */\n    function getLatestPrice(address _token) public returns (uint256) {\n        return getLatestPriceFromName(addressToName[_token]);\n    }\n\n    /**\n     * @notice Get latest price\n     *\n     * @param _policyToken Policy token name\n     *\n     * @return price USD price of the base token\n     */\n    function getLatestPriceFromName(string memory _policyToken)\n        public\n        returns (uint256 price)\n    {\n        uint256 priceInAVAX;\n\n        // If token0 is WAVAX, use price1Average\n        // Else, use price0Average\n        priceInAVAX = priceFeeds[_policyToken].priceAverage;\n\n        require(priceInAVAX > 0, \"Zero Price\");\n\n        // AVAX price, 1e18 scale\n        uint256 avaxPrice = basePriceGetter.getLatestPrice(\"AVAX\");\n\n        // Warning: for DCAR we tempararily double the price because the settlement price is 0.165\n        //          but we set it as 0.33 (they changed the ido price after this round online)\n\n        // This final price is also multiplied by 1e18\n        price = (avaxPrice * priceInAVAX) / 1e18;\n    }\n}\n"
    },
    "src/libraries/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IUniswapV2Pair {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "src/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x)\n        internal\n        pure\n        returns (uq112x112 memory)\n    {\n        require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y)\n        internal\n        pure\n        returns (uq144x112 memory)\n    {\n        uint256 z;\n        require(\n            y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x),\n            \"FixedPoint: MULTIPLICATION_OVERFLOW\"\n        );\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator)\n        internal\n        pure\n        returns (uq112x112 memory)\n    {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n}\n"
    },
    "src/libraries/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./IUniswapV2Pair.sol\";\nimport \"./FixedPoint.sol\";\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2**32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(address pair)\n        internal\n        view\n        returns (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint32 blockTimestamp\n        )\n    {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        ) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative +=\n                uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n                timeElapsed;\n            // counterfactual\n            price1Cumulative +=\n                uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n                timeElapsed;\n        }\n    }\n}\n"
    },
    "src/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./IUniswapV2Pair.sol\";\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}\n\nlibrary UniswapV2Library {\n    using SafeMath for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\n            pairFor(factory, tokenA, tokenB)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(\n            reserveA > 0 && reserveB > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i],\n                path[i + 1]\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i - 1],\n                path[i]\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "src/mock/MockExchange.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IERC20Decimals.sol\";\n\ncontract MockExchange {\n    constructor() {}\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut) {\n        require(block.timestamp <= deadline);\n\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n\n        // path[0] is native token with 18 decimals\n        // path[1] is MockUSDC with 6 decimals\n        uint256 decimalDiff = IERC20Decimals(path[0]).decimals() -\n            IERC20Decimals(path[1]).decimals();\n\n        // E.g. amountIn = 1e18\n        //      amountOut = 1e6\n        amountOut = amountIn / 10**decimalDiff;\n\n        IERC20(path[1]).transfer(to, amountOut);\n    }\n}\n"
    },
    "src/priceGetter/PriceGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {OwnableWithoutContextUpgradeable} from \"../util/OwnableWithoutContextUpgradeable.sol\";\n\n/**\n * @title  Price Getter\n * @notice This is the contract for getting price feed from chainlink.\n *         The contract will keep a record from tokenName => priceFeed Address.\n *         Got the sponsorship and collaboration with Chainlink.\n * @dev    The price from chainlink priceFeed has different decimals, be careful.\n */\ncontract PriceGetter is OwnableWithoutContextUpgradeable {\n    struct PriceFeedInfo {\n        address priceFeedAddress;\n        uint256 decimals;\n    }\n    // Use token address as the mapping key\n    mapping(address => PriceFeedInfo) public priceFeedInfo;\n\n    // Find address according to name\n    mapping(string => address) public nameToAddress;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    event PriceFeedChanged(\n        string tokenName,\n        address tokenAddress,\n        address feedAddress,\n        uint256 decimals\n    );\n\n    event LatestPriceGet(\n        uint80 roundID,\n        int256 price,\n        uint256 startedAt,\n        uint256 timeStamp,\n        uint80 answeredInRound\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize() public initializer {\n        __Ownable_init();\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Modifiers ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Can not give zero address\n     */\n    modifier notZeroAddress(address _address) {\n        require(_address != address(0), \"Zero address\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set a price feed oracle address for a token\n     * @dev Only callable by the owner\n     *      The price result decimal should be less than 18\n     *\n     * @param _tokenName   Address of the token\n     * @param _tokenAddress Address of the token\n     * @param _feedAddress Price feed oracle address\n     * @param _decimals    Decimals of this price feed service\n     */\n    function setPriceFeed(\n        string memory _tokenName,\n        address _tokenAddress,\n        address _feedAddress,\n        uint256 _decimals\n    ) public onlyOwner notZeroAddress(_feedAddress) {\n        require(_decimals <= 18, \"Too many decimals\");\n\n        priceFeedInfo[_tokenAddress] = PriceFeedInfo(_feedAddress, _decimals);\n        nameToAddress[_tokenName] = _tokenAddress;\n\n        emit PriceFeedChanged(\n            _tokenName,\n            _tokenAddress,\n            _feedAddress,\n            _decimals\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Main Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get latest price of a token\n     *\n     * @param _tokenName Name of the token\n     *\n     * @return price The latest price\n     */\n    function getLatestPrice(string memory _tokenName) public returns (uint256) {\n        return getLatestPrice(nameToAddress[_tokenName]);\n    }\n\n    /**\n     * @notice Get latest price of a token\n     *\n     * @param _tokenAddress Address of the token\n     *\n     * @return finalPrice The latest price\n     */\n    function getLatestPrice(address _tokenAddress)\n        public\n        returns (uint256 finalPrice)\n    {\n        PriceFeedInfo memory priceFeed = priceFeedInfo[_tokenAddress];\n\n        if (priceFeed.priceFeedAddress == address(0)) {\n            finalPrice = 1e18;\n        } else {\n            (\n                uint80 roundID,\n                int256 price,\n                uint256 startedAt,\n                uint256 timeStamp,\n                uint80 answeredInRound\n            ) = AggregatorV3Interface(priceFeed.priceFeedAddress)\n                    .latestRoundData();\n\n            // require(price > 0, \"Only accept price that > 0\");\n            if (price < 0) price = 0;\n\n            emit LatestPriceGet(\n                roundID,\n                price,\n                startedAt,\n                timeStamp,\n                answeredInRound\n            );\n            // Transfer the result decimals\n            finalPrice = uint256(price) * (10**(18 - priceFeed.decimals));\n        }\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "src/mock/MockPriceGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {OwnableWithoutContext} from \"../util/OwnableWithoutContext.sol\";\n\n/**\n * @title  Price Getter\n * @notice This is the contract for getting price feed from chainlink.\n *         The contract will keep a record from tokenName => priceFeed Address.\n *         Got the sponsorship and collaboration with Chainlink.\n * @dev    The price from chainlink priceFeed has different decimals, be careful.\n */\ncontract MockPriceGetter is OwnableWithoutContext {\n    // Find address according to name\n    mapping(string => address) public nameToAddress;\n\n    event LatestPriceGet(address token);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor() OwnableWithoutContext(msg.sender) {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Main Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function getLatestPrice(string memory _tokenName) public returns (uint256) {\n        return getLatestPrice(nameToAddress[_tokenName]);\n    }\n\n    function getLatestPrice(address _tokenAddress) public returns (uint256) {\n        emit LatestPriceGet(_tokenAddress);\n        return 1e18;\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031363735333234313036363236"
      }
    }
  }
}