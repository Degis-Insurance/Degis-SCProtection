{
  "language": "Solidity",
  "sources": {
    "src/core/Executor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\nimport \"../util/OwnableWithoutContext.sol\";\n\nimport \"./interfaces/ExecutorDependencies.sol\";\n\nimport \"../voting/interfaces/VotingParameters.sol\";\n\npragma solidity ^0.8.13;\n\n/**\n * @title Executor\n *\n * @author Eric Lee (ylikp.ust@gmail.com) & Primata (primata@375labs.org)\n *\n * @notice This is the executor for degis Protocol Protection\n *         The executor is responsible for the execution of the reports and pool proposals\n *         Both administrators or users can execute proposals and reports out of self interest\n *\n */\ncontract Executor is\n    ExecutorDependencies,\n    VotingParameters,\n    OwnableWithoutContext\n{\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // if chosen to, executor report could have a buffer timer to prevent abuse of the system\n    // from team or organization members\n    uint256 public reportBuffer;\n    uint256 public poolBuffer;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event ReportExecuted(address pool, uint256 poolId, uint256 reportId);\n\n    event NewPoolExecuted(\n        address poolAddress,\n        uint256 proposalId,\n        address protocol\n    );\n\n    constructor() OwnableWithoutContext(msg.sender) {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice              Set pool and report time buffers\n     *\n     * @param _poolBuffer   time in unix\n     * @param _reportBuffer time in unix\n     */\n    function setBuffers(uint256 _poolBuffer, uint256 _reportBuffer) public {\n        poolBuffer = _poolBuffer;\n        reportBuffer = _reportBuffer;\n    }\n\n    function setPolicyCenter(address _policyCenter) external onlyOwner {\n        _setPolicyCenter(_policyCenter);\n    }\n\n    function setInsurancePoolFactory(address _insurancePoolFactory)\n        external\n        onlyOwner\n    {\n        _setInsurancePoolFactory(_insurancePoolFactory);\n    }\n\n    function setReinsurancePool(address _reinsurancePool) external onlyOwner {\n        _setReinsurancePool(_reinsurancePool);\n    }\n\n    function setIncidentReport(address _incidentReport) external onlyOwner {\n        _setIncidentReport(_incidentReport);\n    }\n\n    function setOnboardProposal(address _onboardProposal) external onlyOwner {\n        _setOnboardProposal(_onboardProposal);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Execute a report already settled\n     *\n     * @param _reportId Id of the report to be executed\n     */\n    function executeReport(uint256 _reportId) public {\n        // get the report\n        (\n            uint256 poolId,\n            ,\n            address reporter,\n            ,\n            ,\n            ,\n            ,\n            uint256 status,\n            uint256 result,\n\n        ) = IIncidentReport(incidentReport).reports(_reportId);\n\n        require(status == SETTLED_STATUS, \"Report is not ready to be executed\");\n        require(result == 1, \"Report is not passed\");\n\n        // execute the pool\n        address poolAddress = IPolicyCenter(policyCenter).insurancePools(\n            poolId\n        );\n        address tokenAddress = IPolicyCenter(policyCenter).tokenByPoolId(\n            poolId\n        );\n\n        // reward 10% of treasury to reporter\n        IPolicyCenter(policyCenter).rewardTreasuryToReporter(reporter);\n\n        // liquidate the pool\n        IInsurancePool(poolAddress).liquidatePool();\n\n        // remove pool from protocol registry in insurance pool factory\n        // that allows the creation of newe pools for that protocol\n        IInsurancePoolFactory(insurancePoolFactory).deregisterAddress(\n            tokenAddress\n        );\n        // IInsurancePoolFactory(poolAddress).deregisterToken()\n        // emit the event\n        emit ReportExecuted(poolAddress, poolId, _reportId);\n    }\n\n    /**\n     * @notice Settle the proposal\n     *\n     * @param _proposalId Proposal id\n     */\n    function executeProposal(uint256 _proposalId) external returns (address) {\n        IOnboardProposal.Proposal memory proposal = IOnboardProposal(\n            onboardProposal\n        ).getProposal(_proposalId);\n\n        require(proposal.status == SETTLED_STATUS, \"Not settled\");\n\n        require(proposal.result == 1, \"Has not been approved\");\n\n        // execute the proposal\n        address newPool = IInsurancePoolFactory(insurancePoolFactory)\n            .deployPool(\n                proposal.name,\n                proposal.protocolAddress,\n                proposal.maxCapacity,\n                proposal.priceRatio\n            );\n\n        // emit the event\n        emit NewPoolExecuted(newPool, _proposalId, proposal.protocolAddress);\n\n        return newPool;\n    }\n}\n"
    },
    "src/util/OwnableWithoutContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.13;\n\nabstract contract OwnableWithoutContext {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting a customized initial owner.\n     */\n    constructor(address _initOwner) {\n        _transferOwnership(_initOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "src/core/interfaces/ExecutorDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IInsurancePool.sol\";\nimport \"../../interfaces/IReinsurancePool.sol\";\nimport \"../../interfaces/IInsurancePoolFactory.sol\";\nimport \"../../interfaces/IOnboardProposal.sol\";\nimport \"../../interfaces/IPolicyCenter.sol\";\nimport \"../../interfaces/IIncidentReport.sol\";\n\nabstract contract ExecutorDependencies {\n    address public policyCenter;\n    address public reinsurancePool;\n    address public insurancePoolFactory;\n    address public incidentReport;\n    address public onboardProposal;\n\n    function _setPolicyCenter(address _policyCenter) internal virtual {\n        policyCenter = _policyCenter;\n    }\n\n    function _setReinsurancePool(address _reinsurancePool) internal virtual {\n        reinsurancePool = _reinsurancePool;\n    }\n\n    function _setInsurancePoolFactory(address _insurancePoolFactory)\n        internal\n        virtual\n    {\n        insurancePoolFactory = _insurancePoolFactory;\n    }\n\n    function _setIncidentReport(address _incidentReport) internal virtual {\n        incidentReport = _incidentReport;\n    }\n\n    function _setOnboardProposal(address _onboardProposal) internal virtual {\n        onboardProposal = _onboardProposal;\n    }\n}\n"
    },
    "src/voting/interfaces/VotingParameters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nabstract contract VotingParameters {\n    // Status parameters for a voting\n    uint256 constant INIT_STATUS = 0;\n    uint256 constant PENDING_STATUS = 1;\n    uint256 constant VOTING_STATUS = 2;\n    uint256 constant SETTLED_STATUS = 3;\n    uint256 constant CLOSE_STATUS = 404;\n\n    // Result parameters for a voting\n    uint256 constant INIT_RESULT = 0;\n    uint256 constant PASS_RESULT = 1;\n    uint256 constant REJECT_RESULT = 2;\n    uint256 constant TIED_RESULT = 3;\n}\n"
    },
    "src/interfaces/IInsurancePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IInsurancePool {\n    event AccRewardsPerShareUpdated(uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event EmissionRateUpdated(uint256 newEmissionRate, uint256 newEmissionEndTime);\n    event Liquidation(uint256 amount, uint256 endDate);\n    event LiquidationEnded(uint256 timestamp);\n    event LiquidityProvision(uint256 amount, address sender);\n    event LiquidityRemoved(uint256 amount, address sender);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Paused(address account);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Unpaused(address account);\n\n    function DISTRIBUTION_PERIOD() view external returns (uint256);\n    function PAY_COVER_PERIOD() view external returns (uint256);\n    function accumulatedRewardPerShare() view external returns (uint256);\n    function administrator() view external returns (address);\n    function allowance(address owner, address spender) view external returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) view external returns (uint256);\n    function calculateReward(uint256 _amount, uint256 _userDebt) view external returns (uint256);\n    function coveragePrice(uint256 _amount, uint256 _length) view external returns (uint256);\n    function decimals() view external returns (uint8);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n    function deg() view external returns (address);\n    function emissionEndTime() view external returns (uint256);\n    function emissionRate() view external returns (uint256);\n    function endLiquidationDate() view external returns (uint256);\n    function executor() view external returns (address);\n    function incidentReport() view external returns (address);\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    function insurancePoolFactory() view external returns (address);\n    function insuredToken() view external returns (address);\n    function lastRewardTimestamp() view external returns (uint256);\n    function liquidatePool() external;\n    function liquidated() view external returns (bool);\n    function maxCapacity() view external returns (uint256);\n    function maxLength() view external returns (uint256);\n    function name() view external returns (string memory);\n    function onboardProposal() view external returns (address);\n    function owner() view external returns (address);\n    function paused() view external returns (bool);\n    function policyCenter() view external returns (address);\n\n    function poolInfo() view external returns (bool, uint256, uint256, uint256, uint256, uint256);\n\n    function priceRatio() view external returns (uint256);\n    function provideLiquidity(uint256 _amount, address _provider) external;\n    function reinsurancePool() view external returns (address);\n    function removeLiquidity(uint256 _amount, address _provider) external;\n    function renounceOwnership() external;\n   \n    \n    function setExecutor(address _executor) external;\n    function setIncidentReport(address _incidentReport) external;\n    function setInsurancePoolFactory(address _insurancePoolFactory) external;\n    function setMaxCapacity(uint256 _maxCapacity) external;\n    function setMaxLength(uint256 _maxLength) external;\n    function setOnboardProposal(address _onboardProposal) external;\n    function pauseInsurancePool(bool _paused) external;\n    function setPolicyCenter(address _policyCenter) external;\n    function setReinsurancePool(address _reinsurancePool) external;\n    \n    function shield() view external returns (address);\n    function startTime() view external returns (uint256);\n    function symbol() view external returns (string memory);\n    function totalSupply() view external returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function transferOwnership(address newOwner) external;\n    function updateEmissionRate(uint256 _premium) external;\n    function updateRewards() external;\n    function veDeg() view external returns (address);\n    function endLiquidation() external;\n}"
    },
    "src/interfaces/IReinsurancePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IReinsurancePool {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Deposit(address indexed user, uint256 amount);\n    event MoveLiquidity(uint256 poolId, uint256 amount);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Withdraw(address indexed user, uint256 amount);\n\n    function accumulatedRewardPerShare() view external returns (uint256);\n    function addPremium(uint256 _amount) external;\n    function allowance(address owner, address spender) view external returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) view external returns (uint256);\n    function calculateReward(uint256 _amount, uint256 _userDebt) view external returns (uint256);\n    function claimReward(address _provider) external;\n    function decimals() view external returns (uint8);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n    function deg() view external returns (address);\n    function emissionRate() view external returns (uint256);\n    function endLiquidationPeriod() external;\n    function executor() view external returns (address);\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    function insurancePoolFactory() view external returns (address);\n    function insurancePoolLiquidated() view external returns (bool);\n    function liquidities(address) view external returns (uint256 amount, uint256 userDebt, uint256 lastClaim);\n    function moveLiquidity(uint256 _poolId, uint256 _amount) external;\n    function name() view external returns (string memory);\n    function owner() view external returns (address);\n    function paused() view external returns (bool);\n    function policyCenter() view external returns (address);\n    function poolInfo() external view returns (bool,uint256,uint256,uint256,uint256,uint256);\n    function pools(address) view external returns (address protocolAddress, uint256 proportion);\n    function proposalCenter() view external returns (address);\n    function provideLiquidity(uint256 _amount, address _provider) external;\n    function reinsurancePool() view external returns (address);\n    function reinsurePool(uint256 _amount, address _address) external;\n    function removeLiquidity(uint256 _amount, address _provider) external;\n    function renounceOwnership() external;\n    \n    function setExecutor(address _executor) external;\n    function setInsurancePoolFactory(address _insurancePoolFactory) external;\n    function pauseReinsurancePool(bool _paused) external;\n\n    function setPolicyCenter(address _policyCenter) external;\n    function setProposalCenter(address _proposalCenter) external;\n    function setReinsurancePool(address _reinsurancePool) external;\n    \n    function shield() view external returns (address);\n    function symbol() view external returns (string memory);\n    function totalDistributedReward() view external returns (uint256);\n    function totalReward() view external returns (uint256);\n    function totalSupply() view external returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function transferOwnership(address newOwner) external;\n    function updateEmissionRate(uint256 _premium) external;\n    function updateRewards() external;\n    function veDeg() view external returns (address);\n}\n"
    },
    "src/interfaces/IInsurancePoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IInsurancePoolFactory {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event PoolCreated(\n        address poolAddress,\n        uint256 poolId,\n        string protocolName,\n        address protocolToken,\n        uint256 maxCapacity,\n        uint256 policyPricePerShield\n    );\n\n    struct PoolInfo {\n        string a;\n        address b;\n        address c;\n        uint256 d;\n        uint256 e;\n    }\n\n    function administrator() external view returns (address);\n\n    function deg() external view returns (address);\n\n    function deregisterAddress(address _tokenAddress) external;\n\n    function deployPool(\n        string memory _name,\n        address _protocolToken,\n        uint256 _maxCapacity,\n        uint256 _policyPricePerToken\n    ) external returns (address);\n\n    function executor() external view returns (address);\n\n    function getPoolAddressList() external view returns (address[] memory);\n\n    function getPoolInfo(uint256 _id) external view returns (PoolInfo memory);\n\n    function incidentReport() external view returns (address);\n\n    function insurancePoolFactory() external view returns (address);\n\n    function maxCapacity() external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function policyCenter() external view returns (address);\n\n    function poolCounter() external view returns (uint256);\n\n    function poolInfoById(uint256)\n        external\n        view\n        returns (\n            string memory protocolName,\n            address poolAddress,\n            address protocolToken,\n            uint256 maxCapacity,\n            uint256 policyPricePerShield\n        );\n\n    function poolRegistered(address) external view returns (bool);\n\n    function proposalCenter() external view returns (address);\n\n    function reinsurancePool() external view returns (address);\n\n    function renounceOwnership() external;\n\n\n    function setExecutor(address _executor) external;\n\n    function setIncidentReport(address _incidentReport) external;\n\n    function setInsurancePoolFactory(address _insurancePoolFactory) external;\n\n    function setPolicyCenter(address _policyCenter) external;\n\n    function setProposalCenter(address _proposalCenter) external;\n\n    function setReinsurancePool(address _reinsurancePool) external;\n\n    function shield() external view returns (address);\n\n    function tokenRegistered(address) external view returns (bool);\n\n    function transferOwnership(address newOwner) external;\n\n    function veDeg() external view returns (address);\n}\n"
    },
    "src/interfaces/IOnboardProposal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IOnboardProposal {\n    struct Proposal {\n        string name;\n        address protocolAddress;\n        address proposer;\n        uint256 proposeTimestamp;\n        uint256 numFor; // Votes voting for\n        uint256 numAgainst; // Votes voting against\n        uint256 maxCapacity;\n        uint256 priceRatio;\n        uint256 poolId;\n        uint256 status;\n        uint256 result;\n    }\n\n    event NewProposal(\n        string name,\n        address token,\n        uint256 maxCapacity,\n        uint256 priceRatio\n    );\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event ProposalSettled(uint256 proposalId, uint256 result);\n    event ProposalVoted(\n        uint256 proposalId,\n        address indexed user,\n        uint256 voteFor,\n        uint256 amount\n    );\n\n    function claim(uint256 _proposalId) external;\n\n    function deg() external view returns (address);\n\n    function executor() external view returns (address);\n\n    function executeProposal(uint256 _proposalId) external returns (address);\n\n    function incidentReport() external view returns (address);\n\n    function insurancePoolFactory() external view returns (address);\n\n    function getProposal(uint256 _proposalId)\n        external\n        view\n        returns (Proposal memory);\n\n    function owner() external view returns (address);\n\n    function policyCenter() external view returns (address);\n\n    function proposalCenter() external view returns (address);\n\n    function proposalCounter() external view returns (uint256);\n\n    function proposals(uint256)\n        external\n        view\n        returns (\n            string memory name,\n            address protocolAddress,\n            address proposer,\n            uint256 proposeTimestamp,\n            uint256 numFor,\n            uint256 numAgainst,\n            uint256 maxCapacity,\n            uint256 priceRatio,\n            uint256 poolId,\n            uint256 status,\n            uint256 result\n        );\n\n    function propose(\n        string memory _name,\n        address _token,\n        uint256 _maxCapacity,\n        uint256 _priceRatio\n    ) external;\n\n    function reinsurancePool() external view returns (address);\n\n    function renounceOwnership() external;\n\n    function setExecutor(address _executor) external;\n\n    function setIncidentReport(address _incidentReport) external;\n\n    function setInsurancePoolFactory(address _insurancePoolFactory) external;\n\n    function setPolicyCenter(address _policyCenter) external;\n\n    function setProposalCenter(address _proposalCenter) external;\n\n    function setReinsurancePool(address _reinsurancePool) external;\n\n\n\n    function settle(uint256 _proposalId) external;\n\n    function shield() external view returns (address);\n\n    function transferOwnership(address newOwner) external;\n\n    function userProposalVotes(address, uint256)\n        external\n        view\n        returns (\n            uint256 choice,\n            uint256 amount,\n            bool claimed\n        );\n\n    function veDeg() external view returns (address);\n\n    function vote(\n        uint256 _proposalId,\n        uint256 _isFor,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "src/interfaces/IPolicyCenter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IPolicyCenter {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Payout(uint256 _amount, address _address);\n    event Reward(uint256 _amount, address _address);\n\n    function approvePoolToken(address _token) external;\n    function buyCover(uint256 _poolId, uint256 _pay, uint256 _coverAmount, uint256 _length) external;\n    function calculatePayout(uint256 _poolId, address _insured) view external returns (uint256);\n    function calculateReward(uint256 _poolId, address _provider) view external returns (uint256);\n    function claimPayout(uint256 _poolId) external;\n    function claimReward(uint256 _poolId) external;\n    function coverages(uint256, address) view external returns (uint256 amount, uint256 buyDate, uint256 length);\n    function deg() view external returns (address);\n    function exchange() view external returns (address);\n    function executor() view external returns (address);\n    function fundsByPoolId(uint256) view external returns (uint256);\n\n \n    function getPoolInfo(uint256 _poolId) external view returns (bool, uint256, uint256, uint256 ,uint256, uint256, uint256);\n    function getPremiumSplits() view external returns (uint256, uint256);\n    function incidentReport() view external returns (address);\n    function insurancePoolFactory() view external returns (address);\n    function insurancePools(uint256) view external returns (address);\n\n    function liquidities(uint256, address) view external returns (uint256 amount, uint256 userDebt, uint256 lastClaim);\n    function liquidityByPoolId(uint256) view external returns (uint256);\n    function onboardProposal() view external returns (address);\n    function owner() view external returns (address);\n    function policyCenter() view external returns (address);\n    function premiumSplits(uint256) view external returns (uint256);\n    function provideLiquidity(uint256 _poolId, uint256 _amount) external;\n    function reinsurancePool() view external returns (address);\n    function removeLiquidity(uint256 _poolId, uint256 _amount) external;\n    function renounceOwnership() external;\n    function rewardTreasuryToReporter(address _reporter) external;\n    \n    function setExchange(address _exchange) external;\n    function setExecutor(address _executor) external;\n    function setIncidentReport(address _incidentReport) external;\n    function setInsurancePoolFactory(address _insurancePoolFactory) external;\n    function setOnboardProposal(address _onboardProposal) external;\n    function setPolicyCenter(address _policyCenter) external;\n    function setPremiumSplit(uint256 _insurance, uint256 _reinsurance) external;\n    function setReinsurancePool(address _reinsurancePool) external;\n    \n    function shield() view external returns (address);\n    function storePoolInformation(address _pool, address _token, uint256 _poolId) external;\n    function tokenByPoolId(uint256) view external returns (address);\n    function totalRewardsByPoolId(uint256) view external returns (uint256);\n    function transferOwnership(address newOwner) external;\n    function treasury() view external returns (uint256);\n    function veDeg() view external returns (address);\n}\n"
    },
    "src/interfaces/IIncidentReport.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IIncidentReport {\n\n    event DebtPaid(address payer, address user, uint256 debt, uint256 unlockAmount);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event ReportClosed(uint256 reportId, uint256 closeTimestamp);\n    event ReportCreated(uint256 reportId, uint256 indexed poolId, uint256 reportTimestamp, address indexed reporter);\n    event ReportExtended(uint256 reportId, uint256 round);\n    event ReportSettled(uint256 reportId, uint256 result);\n    event ReportVoted(uint256 reportId, address indexed user, uint256 voteFor, uint256 amount);\n    event VotingStart(uint256 reportId, uint256 startTimestamp);\n\n    struct TempResult { uint256 a; uint256 b; bool c; }\n    struct UserVote { uint256 a; uint256 b; bool c; }\n    struct Report { uint256 a; uint256 b; address c; uint256 d; uint256 e; uint256 f; uint256 g; uint256 h; uint256 i; uint256 j; }\n\n    function COOLDOWN_WRONG_REPORT() view external returns (uint256);\n    function claimReward(uint256 _reportId) external;\n    function closeReport(uint256 _reportId) external;\n    function deg() view external returns (address);\n    function executor() view external returns (address);\n    function getReport(uint256 _id) view external returns (Report memory);\n    function getTempResult(uint256 _id) view external returns (TempResult memory);\n    function getUserVote(address _user, uint256 _id) view external returns (UserVote memory);\n    function incidentReport() view external returns (address);\n    function insurancePoolFactory() view external returns (address);\n    function owner() view external returns (address);\n    function payDebt(uint256 _reportId, address _user) external;\n    function policyCenter() view external returns (address);\n    function poolReported(address) view external returns (bool);\n    function proposalCenter() view external returns (address);\n    function reinsurancePool() view external returns (address);\n    function renounceOwnership() external;\n    function report(uint256 _poolId) external;\n    function reportCounter() view external returns (uint256);\n    function reportTempResults(uint256) view external returns (uint256 result, uint256 sampleTimestamp, bool hasChanged);\n    function reports(uint256) view external returns (uint256 poolId, uint256 reportTimestamp, address reporter, uint256 voteTimestamp, uint256 numFor, uint256 numAgainst, uint256 round, uint256 status, uint256 result, uint256 votingReward);\n    \n    function setExecutor(address _executor) external;\n    function setIncidentReport(address _incidentReport) external;\n    function setInsurancePoolFactory(address _insurancePoolFactory) external;\n    function setPolicyCenter(address _policyCenter) external;\n    function setProposalCenter(address _proposalCenter) external;\n    function setReinsurancePool(address _reinsurancePool) external;\n \n    function settle(uint256 _reportId) external;\n    function shield() view external returns (address);\n    function startVoting(uint256 _reportId) external;\n    function transferOwnership(address newOwner) external;\n    function userCoolDownUntil(address) view external returns (uint256);\n    function userReportVotes(address, uint256) view external returns (uint256 choice, uint256 amount, bool claimed);\n    function veDeg() view external returns (address);\n    function vote(uint256 _reportId, uint256 _isFor, uint256 _amount) external;\n}"
    },
    "src/voting/interfaces/OnboardProposalParameters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"./VotingParameters.sol\";\n\nabstract contract OnboardProposalParameters is VotingParameters {\n    // uint256 constant VOTING_PERIOD = 3 days;\n    uint256 constant VOTING_PERIOD = 2 hours;\n\n    // minimum 50% votes\n    uint256 constant QUORUM_RATIO = 50;\n\n    // DEG threshold for starting a report\n    uint256 constant REPORT_THRESHOLD = 1000 ether;\n}\n"
    },
    "src/voting/OnboardProposal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../util/OwnableWithoutContext.sol\";\n\nimport \"./interfaces/OnboardProposalParameters.sol\";\nimport \"./interfaces/OnboardProposalDependencies.sol\";\n\nimport \"../interfaces/ExternalTokenDependencies.sol\";\n\ncontract OnboardProposal is\n    OnboardProposalParameters,\n    OnboardProposalDependencies,\n    ExternalTokenDependencies,\n    OwnableWithoutContext\n{\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Total number of reports\n    uint256 public proposalCounter;\n\n    struct Proposal {\n        string name;\n        address protocolToken;\n        address proposer;\n        uint256 proposeTimestamp;\n        uint256 numFor; // Votes voting for\n        uint256 numAgainst; // Votes voting against\n        uint256 maxCapacity;\n        uint256 priceRatio;\n        uint256 poolId;\n        uint256 status;\n        uint256 result;\n    }\n    // Proposal ID => Proposal\n    mapping(uint256 => Proposal) public proposals;\n    mapping(address => bool) public poolProposed;\n\n    struct UserVote {\n        uint256 choice; // 1: vote for, 2: vote against\n        uint256 amount;\n        bool claimed;\n    }\n    // User address => report id => user's voting info\n    mapping(address => mapping(uint256 => UserVote)) public userProposalVotes;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event NewProposal(\n        string name,\n        address token,\n        uint256 maxCapacity,\n        uint256 priceRatio\n    );\n\n    event ProposalVoted(\n        uint256 proposalId,\n        address indexed user,\n        uint256 voteFor,\n        uint256 amount\n    );\n\n    event ProposalSettled(uint256 proposalId, uint256 result);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(\n        address _deg,\n        address _veDeg,\n        address _shield\n    ) ExternalTokenDependencies(_deg, _veDeg, _shield) OwnableWithoutContext(msg.sender) {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function getProposal(uint256 _proposalId)\n        public\n        view\n        returns (Proposal memory)\n    {\n        return proposals[_proposalId];\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function setExecutor(address _executor) external onlyOwner {\n        _setExecutor(_executor);\n    }\n\n    function setInsurancePoolFactory(address _insurancePoolFactory)\n        external\n        onlyOwner\n    {\n        _setInsurancePoolFactory(_insurancePoolFactory);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Start a new proposal\n     *\n     * @param _name        New project name\n     * @param _token       Native token address\n     * @param _maxCapacity Max capacity for the project pool\n     * @param _priceRatio  Price ratio of the premium\n     */\n    function propose(\n        string calldata _name,\n        address _token,\n        uint256 _maxCapacity,\n        uint256 _priceRatio // 10000 == 100% premium anual cost\n    ) external {\n        require(\n            !IInsurancePoolFactory(insurancePoolFactory).tokenRegistered(\n                _token\n            ),\n            \"Protocol already protected\"\n        );\n\n        require(poolProposed[_token] == false, \"Protocol already proposed\");\n\n        // Burn degis tokens to start a proposal\n        IDegisToken(deg).burnDegis(msg.sender, REPORT_THRESHOLD);\n\n        poolProposed[_token] = true;\n\n        uint256 currentProposalCounter = ++proposalCounter;\n\n        Proposal storage proposal = proposals[currentProposalCounter];\n        proposal.protocolToken = _token;\n        proposal.proposer = msg.sender;\n        proposal.proposeTimestamp = block.timestamp;\n        proposal.status = PENDING_STATUS;\n        proposal.maxCapacity = _maxCapacity;\n        proposal.priceRatio = _priceRatio;\n\n        emit NewProposal(_name, _token, _maxCapacity, _priceRatio);\n    }\n\n    /**\n     * @notice Vote for a proposal\n     *\n     * @param _proposalId Proposal id\n     * @param _isFor      Voting choice\n     * @param _amount     Amount to vote\n     */\n    function vote(\n        uint256 _proposalId,\n        uint256 _isFor,\n        uint256 _amount\n    ) external {\n        // Should be manually switched on the voting process\n        require(\n            proposals[_proposalId].status == VOTING_STATUS,\n            \"Not voting status\"\n        );\n\n        require(_isFor == 1 || _isFor == 2, \"Wrong choice\");\n\n        _enoughVeDEG(msg.sender, _amount);\n\n        // Lock vedeg until this report is settled\n        IVeDEG(veDeg).lockVeDEG(msg.sender, _amount);\n\n        // Record the user's choice\n        UserVote storage userProposalVote = userProposalVotes[msg.sender][\n            _proposalId\n        ];\n        if (userProposalVote.amount > 0) {\n            require(\n                userProposalVote.choice == _isFor,\n                \"Can not choose both sides\"\n            );\n        } else {\n            userProposalVote.choice = _isFor;\n        }\n\n        Proposal storage currentProposal = proposals[_proposalId];\n        // Record the vote for this report\n        if (_isFor == 1) {\n            currentProposal.numFor += _amount;\n        } else {\n            currentProposal.numAgainst += _amount;\n        }\n\n        emit ProposalVoted(_proposalId, msg.sender, _isFor, _amount);\n    }\n\n    /**\n     * @notice Settle the proposal\n     *\n     * @param _proposalId Proposal id\n     */\n    function settle(uint256 _proposalId) external {\n        Proposal storage currentProposal = proposals[_proposalId];\n\n        require(currentProposal.status == VOTING_STATUS, \"Not voting status\");\n\n        // Check has passed the voting period\n        require(\n            _passedVotingPeriod(currentProposal.proposeTimestamp),\n            \"Not reached settlement\"\n        );\n\n        require(currentProposal.result == 0, \"Already settled\");\n\n        _checkQuorum(currentProposal.numFor + currentProposal.numAgainst);\n\n        uint256 res = _getVotingResult(\n            currentProposal.numFor,\n            currentProposal.numAgainst\n        );\n\n        currentProposal.result = res;\n        currentProposal.status = SETTLED_STATUS;\n\n        // allow for new proposals to be proposed for this protocol\n        poolProposed[currentProposal.protocolToken] = false;\n        emit ProposalSettled(_proposalId, res);\n    }\n\n    function closeProposal(uint256 _proposalId) external {\n        require(msg.sender == executor, \"Only executor can close proposal\");\n\n        Proposal storage currentProposal = proposals[_proposalId];\n\n        // require current proposal to be settled\n        require(\n            currentProposal.status == PENDING_STATUS,\n            \"Not pending or settled status\"\n        );\n\n        // Must close the report before pending period ends\n        require(\n            !_passedVotingPeriod(currentProposal.proposeTimestamp),\n            \"Already passed pending period\"\n        );\n\n        currentProposal.status = CLOSE_STATUS;\n    }\n\n    /**\n     * @notice Claim back veDEG after voting result settled\n     *\n     * @param _proposalId Proposal id\n     */\n    function claim(uint256 _proposalId) external {\n        Proposal storage currentProposal = proposals[_proposalId];\n\n        require(currentProposal.status == SETTLED_STATUS, \"Not settled status\");\n\n        UserVote storage userVote = userProposalVotes[msg.sender][_proposalId];\n\n        IVeDEG(veDeg).unlockVeDEG(msg.sender, userVote.amount);\n\n        userVote.claimed = true;\n    }\n\n    /**\n     * @notice Check if the proposal is settled\n     *\n     * @param _proposalId Proposal id\n     */\n    function startVoting(uint256 _proposalId) external {\n        Proposal storage currentProposal = proposals[_proposalId];\n\n        require(currentProposal.status == PENDING_STATUS, \"Not pending status\");\n\n        require(\n            _passedVotingPeriod(currentProposal.proposeTimestamp),\n            \"Not reached voting period\"\n        );\n\n        currentProposal.status = VOTING_STATUS;\n    }\n\n    /**\n     * @notice Get the final voting result\n     *\n     * @param _numFor     Votes for\n     * @param _numAgainst Votes against\n     *\n     * @return result Pass, reject or tied\n     */\n    function _getVotingResult(uint256 _numFor, uint256 _numAgainst)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        if (_numFor > _numAgainst) result = PASS_RESULT;\n        else if (_numFor < _numAgainst) result = REJECT_RESULT;\n        else result = TIED_RESULT;\n    }\n\n    /**\n     * @notice Check whether has passed the voting time period\n     *\n     * @param _reportTime Start timestamp of the report\n     *\n     * @return hasPassed True for passing\n     */\n    function _passedVotingPeriod(uint256 _reportTime)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 endTime = _reportTime + VOTING_PERIOD;\n\n        return block.timestamp > endTime;\n    }\n\n    /**\n     * @notice Check quorum requirement\n     *         30% of totalSupply is the minimum requirement for participation\n     *\n     * @param _totalVotes Total vote numbers\n     */\n    function _checkQuorum(uint256 _totalVotes) internal view {\n        require(\n            _totalVotes >= (IVeDEG(veDeg).totalSupply() * QUORUM_RATIO) / 100,\n            \"Not reached quorum\"\n        );\n    }\n\n    /**\n     * @notice Check veDEG to be enough\n     *\n     * @param _user   User address\n     * @param _amount Amount to fulfill\n     */\n    function _enoughVeDEG(address _user, uint256 _amount) internal view {\n        uint256 unlockedBalance = IERC20(veDeg).balanceOf(_user) -\n            IVeDEG(veDeg).locked(_user);\n        require(unlockedBalance >= _amount, \"Not enough veDEG\");\n    }\n}\n"
    },
    "src/voting/interfaces/OnboardProposalDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IExecutor.sol\";\nimport \"../../interfaces/IInsurancePoolFactory.sol\";\n\nabstract contract OnboardProposalDependencies {\n    address public executor;\n    address public insurancePoolFactory;\n\n    function _setExecutor(address _executor) internal virtual {\n        executor = _executor;\n    }\n\n    function _setInsurancePoolFactory(address _insurancePoolFactory)\n        internal\n        virtual\n    {\n        insurancePoolFactory = _insurancePoolFactory;\n    }\n}\n"
    },
    "src/interfaces/ExternalTokenDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"./IDegisToken.sol\";\nimport \"./IVeDEG.sol\";\n\n/**\n * @notice External token dependencies\n *         Include the tokens that are not deployed by this repo\n *         DEG, veDEG & SHIELD\n *         They are set as immutable\n */\n\nabstract contract ExternalTokenDependencies {\n    uint256 public constant SCALE = 1e12;\n\n    address public immutable deg;\n    address public immutable veDeg;\n    address public immutable shield;\n\n    constructor(\n        address _deg,\n        address _veDeg,\n        address _shield\n    ) {\n        deg = _deg;\n        veDeg = _veDeg;\n        shield = _shield;\n    }\n}\n"
    },
    "src/interfaces/IExecutor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\ninterface IExecutor {\n    event NewPoolEecuted(address poolAddress, uint256 proposalId, address protocol);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event QueuePool(uint256 proposalId, uint256 maxCapacity, uint256 ends);\n    event QueueReport(uint256 reportId, uint256 poolId, uint256 ends);\n    event ReportExecuted(address pool, uint256 poolId, uint256 reportId);\n\n    function cancelNewPool(uint256 _proposalId) external;\n    function cancelReport(uint256 _reportId) external;\n    function deg() view external returns (address);\n    function executeProposal(uint256 _proposalId) external returns (address newPool);\n    function executeReport(uint256 _reportId) external;\n    function executor() view external returns (address);\n    function incidentReport() view external returns (address);\n    function insurancePoolFactory() view external returns (address);\n    function owner() view external returns (address);\n    function policyCenter() view external returns (address);\n    function poolBuffer() view external returns (uint256);\n    function proposalCenter() view external returns (address);\n    function queuePool(string memory _protocolName, uint256 _proposalId, address _protocol, uint256 _maxCapacity, uint256 _policyPricePerToken, bool _pending, bool _approved) external;\n    function queueReport(bool _pending, bool _approved, uint256 _reportId, uint256 _poolId) external;\n    function queuedPoolsById(uint256) view external returns (string memory protocolName, address protocol, uint256 maxCapacity, uint256 policyPricePerShield, uint256 queueEnds, bool pending, bool approved);\n    function queuedReportsById(uint256) view external returns (uint256 poolId, uint256 queueEnds, bool pending, bool approved);\n    function reinsurancePool() view external returns (address);\n    function renounceOwnership() external;\n    function reportBuffer() view external returns (uint256);\n    function setBuffers(uint256 _poolBuffer, uint256 _reportBuffer) external;\n   \n    function setExecutor(address _executor) external;\n    function setIncidentReport(address _incidentReport) external;\n    function setInsurancePoolFactory(address _insurancePoolFactory) external;\n    function setPolicyCenter(address _policyCenter) external;\n    function setProposalCenter(address _proposalCenter) external;\n    function setReinsurancePool(address _reinsurancePool) external;\n    \n    function shield() view external returns (address);\n    function transferOwnership(address newOwner) external;\n    function veDeg() view external returns (address);\n}"
    },
    "src/interfaces/IDegisToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDegisToken is IERC20 {\n    // Mint degis token\n    function mintDegis(address _account, uint256 _amount) external;\n\n    // Burn degis token\n    function burnDegis(address _account, uint256 _amount) external;\n}\n"
    },
    "src/interfaces/IVeDEG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Interface of the VeDEG\n */\ninterface IVeDEG is IERC20 {\n    // Get the locked amount of a user's veDeg\n    function locked(address _user) external view returns (uint256);\n\n    // Lock veDEG\n    function lockVeDEG(address _to, uint256 _amount) external;\n\n    // Unlock veDEG\n    function unlockVeDEG(address _to, uint256 _amount) external;\n    \n    function users(uint256 _pool, address _user) external view returns (uint256, uint256);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "src/voting/IncidentReport.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../util/OwnableWithoutContext.sol\";\n\nimport \"./interfaces/IncidentReportParameters.sol\";\nimport \"./interfaces/IncidentReportDependencies.sol\";\n\nimport \"../interfaces/ExternalTokenDependencies.sol\";\n\nimport \"lib/forge-std/src/console.sol\";\n\ncontract IncidentReport is\n    IncidentReportParameters,\n    IncidentReportDependencies,\n    ExternalTokenDependencies,\n    OwnableWithoutContext\n{\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Total number of reports\n    uint256 public reportCounter;\n\n    struct Report {\n        uint256 poolId; // Project pool id\n        uint256 reportTimestamp; // Time of starting report\n        address reporter; // Reporter address\n        uint256 voteTimestamp; // Voting start timestamp\n        uint256 numFor; // Votes voting for\n        uint256 numAgainst; // Votes voting against\n        uint256 round; // 0: Initial round 3 days, 1: Extended round 1 day, 2: Double extended 1 day\n        uint256 status;\n        uint256 result; // 1: Pass, 2: Reject, 3: Tied\n        uint256 votingReward; // Voting reward per veDEG if the report passed\n    }\n    // Report id => Report\n    mapping(uint256 => Report) public reports;\n\n    struct TempResult {\n        uint256 result;\n        uint256 sampleTimestamp;\n        bool hasChanged;\n    }\n    mapping(uint256 => TempResult) public reportTempResults;\n\n    struct UserVote {\n        uint256 choice; // 1: vote for, 2: vote against\n        uint256 amount;\n        bool claimed;\n    }\n    // User address => report id => user's voting info\n    mapping(address => mapping(uint256 => UserVote)) public userReportVotes;\n\n    // User address => cool down for report until\n    mapping(address => uint256) public userCoolDownUntil;\n\n    // Pool address => whether the pool is being reported\n    mapping(address => bool) public poolReported;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event ReportCreated(\n        uint256 reportId,\n        uint256 indexed poolId,\n        uint256 reportTimestamp,\n        address indexed reporter\n    );\n\n    event VotingStart(uint256 reportId, uint256 startTimestamp);\n\n    event ReportClosed(uint256 reportId, uint256 closeTimestamp);\n\n    event ReportVoted(\n        uint256 reportId,\n        address indexed user,\n        uint256 voteFor,\n        uint256 amount\n    );\n\n    event ReportSettled(uint256 reportId, uint256 result);\n\n    event ReportExtended(uint256 reportId, uint256 round);\n\n    event DebtPaid(\n        address payer,\n        address user,\n        uint256 debt,\n        uint256 unlockAmount\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    constructor(\n        address _deg,\n        address _veDeg,\n        address _shield\n    )\n        ExternalTokenDependencies(_deg, _veDeg, _shield)\n        OwnableWithoutContext(msg.sender)\n    {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function getUserVote(address _user, uint256 _poolId)\n        external\n        view\n        returns (UserVote memory)\n    {\n        return userReportVotes[_user][_poolId];\n    }\n\n    function getTempResult(uint256 _poolId)\n        external\n        view\n        returns (TempResult memory)\n    {\n        return reportTempResults[_poolId];\n    }\n\n    function getReport(uint256 _id) public view returns (Report memory) {\n        return reports[_id];\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function setPolicyCenter(address _policyCenter) external onlyOwner {\n        _setPolicyCenter(_policyCenter);\n    }\n\n    function setReinsurancePool(address _reinsurancePool) external onlyOwner {\n        _setReinsurancePool(_reinsurancePool);\n    }\n\n    function setInsurancePoolFactory(address _insurancePoolFactory)\n        external\n        onlyOwner\n    {\n        _setInsurancePoolFactory(_insurancePoolFactory);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Start a new incident report\n     *\n     *         1000 DEG tokens are staked to start a report\n     *         If the report is correct, reporter gets back 1000DEG + 10% shield income + extra 1000DEG\n     *         If the report is wrong, reporter loses 1000DEG to those who vote against\n     *\n     * @param _poolId Pool id to report incident\n     */\n    function report(uint256 _poolId) external {\n        address pool = IPolicyCenter(policyCenter).insurancePools(_poolId);\n        require(pool != address(0), \"Pool doesn't exist\");\n        require(!poolReported[pool], \"Pool already reported\");\n\n        uint256 currentReportId = ++reportCounter;\n\n        poolReported[pool] = true;\n\n        // Record the new report\n        Report storage newReport = reports[currentReportId];\n        newReport.poolId = _poolId;\n        newReport.reportTimestamp = block.timestamp;\n        newReport.reporter = msg.sender;\n        newReport.status = PENDING_STATUS;\n\n        // burn degis tokens to start a report\n        IDegisToken(deg).burnDegis(msg.sender, REPORT_THRESHOLD);\n\n        // Pause insurance pool and reinsurance pool\n        _pausePools(pool);\n\n        emit ReportCreated(reportCounter, _poolId, block.timestamp, msg.sender);\n    }\n\n    /**\n     * @notice Start the voting process\n     *\n     * @param _reportId Report id\n     */\n    function startVoting(uint256 _reportId) external {\n        Report storage currentReport = reports[_reportId];\n        require(currentReport.status == PENDING_STATUS, \"Not pending status\");\n\n        // Can only start the voting after pending period\n        require(\n            _passedPendingPeriod(currentReport.reportTimestamp),\n            \"Not passed pending period\"\n        );\n\n        currentReport.status = VOTING_STATUS;\n        currentReport.voteTimestamp = block.timestamp;\n\n        emit VotingStart(_reportId, block.timestamp);\n    }\n\n    /**\n     * @notice Close a pending report\n     *\n     * @param _reportId Report id\n     */\n    function closeReport(uint256 _reportId) external onlyOwner {\n        Report storage currentReport = reports[_reportId];\n        require(currentReport.status == PENDING_STATUS, \"Not pending status\");\n\n        // Must close the report before pending period ends\n        require(\n            !_passedPendingPeriod(currentReport.reportTimestamp),\n            \"Already passed pending period\"\n        );\n\n        currentReport.status = CLOSE_STATUS;\n\n        emit ReportClosed(_reportId, block.timestamp);\n    }\n\n    /**\n     * @notice Vote on currently pending reports\n     *\n     *         Voting power is decided by the (unlocked) balance of veDEG\n     *         Rewarded if votes with majority\n     *         Punished if votes against majority\n     *\n     * @param _reportId Id of the report to be voted on\n     * @param _isFor    The user's choice (1: vote for, 2: vote against)\n     * @param _amount   Amount of veDEG used for this vote\n     */\n    function vote(\n        uint256 _reportId,\n        uint256 _isFor,\n        uint256 _amount\n    ) external {\n        // Should be manually switched on the voting process\n        require(\n            reports[_reportId].status == VOTING_STATUS,\n            \"Not voting status\"\n        );\n\n        require(_isFor == 1 || _isFor == 2, \"Wrong choice\");\n\n        _enoughVeDEG(msg.sender, _amount);\n\n        // Lock vedeg until this report is settled\n        IVeDEG(veDeg).lockVeDEG(msg.sender, _amount);\n\n        // Record the user's choice\n        UserVote storage userReportVote = userReportVotes[msg.sender][\n            _reportId\n        ];\n        if (userReportVote.amount > 0) {\n            require(\n                userReportVote.choice == _isFor,\n                \"Can not choose both sides\"\n            );\n        } else {\n            userReportVote.choice = _isFor;\n        }\n\n        userReportVote.amount += _amount;\n\n        Report storage currentReport = reports[_reportId];\n        // Record the vote for this report\n        if (_isFor == 1) {\n            currentReport.numFor += _amount;\n        } else {\n            currentReport.numAgainst += _amount;\n        }\n\n        // Record a temporary result\n        // If the hasChanged already been true, no need for further update\n        // If the voting period has passed, no need for update\n        if (\n            !reportTempResults[_reportId].hasChanged &&\n            !_passedVotingPeriod(\n                currentReport.round,\n                currentReport.reportTimestamp\n            )\n        ) {\n            _recordTempResult(\n                _reportId,\n                currentReport.round,\n                currentReport.numFor,\n                currentReport.numAgainst\n            );\n        }\n\n        emit ReportVoted(_reportId, msg.sender, _isFor, _amount);\n    }\n\n    /**\n     * @notice Settle the final result for a report\n     *\n     * @param _reportId Report id\n     */\n    function settle(uint256 _reportId) external {\n        Report storage currentReport = reports[_reportId];\n\n        require(currentReport.status == VOTING_STATUS, \"Not voting status\");\n\n        // Check has passed the voting period\n        require(\n            _passedVotingPeriod(\n                currentReport.round,\n                currentReport.reportTimestamp\n            ),\n            \"Not reached settlement\"\n        );\n\n        require(currentReport.result == 0, \"Already settled\");\n\n        _checkQuorum(currentReport.numFor + currentReport.numAgainst);\n\n        uint256 res = _checkRoundExtended(_reportId, currentReport.round);\n\n        console.log(\"Res\", res);\n\n        if (res > 0) {\n            _settleVotingReward(_reportId);\n\n            currentReport.status = SETTLED_STATUS;\n\n            emit ReportSettled(_reportId, res);\n        } else {\n            emit ReportExtended(_reportId, currentReport.round);\n        }\n    }\n\n    /**\n     * @notice Claim the voting reward\n     *\n     * @param _reportId Report id\n     */\n    function claimReward(uint256 _reportId) external {\n        UserVote memory userVote = userReportVotes[msg.sender][_reportId];\n        uint256 finalResult = reports[_reportId].result;\n\n        require(finalResult > 0, \"Not settled\");\n        require(!userVote.claimed, \"Already claimed\");\n\n        // Correct choice\n        if (userVote.choice == finalResult) {\n            IDegisToken(deg).mintDegis(\n                msg.sender,\n                (reports[_reportId].votingReward * userVote.amount) / SCALE\n            );\n            IVeDEG(veDeg).unlockVeDEG(msg.sender, userVote.amount);\n        } else if (finalResult == TIED_RESULT) {\n            // Tied result, give back user's veDEG\n            IVeDEG(veDeg).unlockVeDEG(msg.sender, userVote.amount);\n        } else revert(\"No reward to claim\");\n\n        userReportVotes[msg.sender][_reportId].claimed = true;\n    }\n\n    /**\n     * @notice Pay debt to get back veDEG\n     *\n     *         For those who made a wrong voting choice\n     *\n     * @param _reportId Report id\n     * @param _user     User address (can pay debt for another user)\n     */\n    function payDebt(uint256 _reportId, address _user) external {\n        UserVote memory userVote = userReportVotes[_user][_reportId];\n        uint256 finalResult = reports[_reportId].result;\n\n        require(finalResult > 0, \"Not settled\");\n        require(userVote.choice != finalResult, \"Not wrong choice\");\n\n        uint256 debt = (userVote.amount * DEBT_RATIO) / 10000;\n\n        console.log(\"debt\", debt);\n\n        // Pay the debt in DEG\n        IDegisToken(deg).burnDegis(msg.sender, debt);\n\n        // Unlock the user's veDEG\n        IVeDEG(veDeg).unlockVeDEG(_user, userVote.amount);\n\n        emit DebtPaid(msg.sender, _user, debt, userVote.amount);\n    }\n\n    function unpausePools(address _pool) external {\n        require(\n            IInsurancePool(_pool).endLiquidationDate() < block.timestamp,\n            \"pool is still in payout period\"\n        );\n        _unpausePools(_pool);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Settle voting reward depending on the result\n     *\n     * @param _reportId Report id\n     */\n    function _settleVotingReward(uint256 _reportId) internal {\n        Report storage currentReport = reports[_reportId];\n\n        if (currentReport.result == 1) {\n            // Get back REPORT_THRESHOLD and get extra REPORTER_REWARD deg tokens\n            IDegisToken(deg).mintDegis(\n                currentReport.reporter,\n                REPORTER_REWARD + REPORT_THRESHOLD\n            );\n\n            _distributeIncomeForWinner(currentReport.reporter);\n\n            // Total deg reward\n            uint256 totalRewardToVoters = currentReport.numAgainst / 100;\n\n            // Update deg reward for those who vote for\n            currentReport.votingReward =\n                (totalRewardToVoters * SCALE) /\n                currentReport.numFor;\n        } else if (currentReport.result == 2) {\n            // Total deg reward\n            uint256 totalRewardToVoters = REPORT_THRESHOLD +\n                currentReport.numFor /\n                100;\n\n            // Update deg reward for those who vote against\n            currentReport.votingReward =\n                (totalRewardToVoters * SCALE) /\n                currentReport.numAgainst;\n        }\n    }\n\n    /**\n     * @notice Distribute part of shield income to correct reporter\n     *\n     * @param _winner Winner address\n     */\n    function _distributeIncomeForWinner(address _winner) internal {\n        // IDegisToken(deg).mintDegis(_winner, REPORT_THRESHOLD);\n    }\n\n    /**\n     * @notice Check quorum requirement\n     *         30% of totalSupply is the minimum requirement for participation\n     *\n     * @param _totalVotes Total vote numbers\n     */\n    function _checkQuorum(uint256 _totalVotes) internal view {\n        require(\n            _totalVotes >= (IVeDEG(veDeg).totalSupply() * QUORUM_RATIO) / 100,\n            \"Not reached quorum\"\n        );\n    }\n\n    /**\n     * @notice Check veDEG to be enough\n     *\n     * @param _user   User address\n     * @param _amount Amount to fulfill\n     */\n    function _enoughVeDEG(address _user, uint256 _amount) internal view {\n        uint256 unlockedBalance = IERC20(veDeg).balanceOf(_user) -\n            IVeDEG(veDeg).locked(_user);\n        require(unlockedBalance >= _amount, \"Not enough veDEG\");\n    }\n\n    /**\n     * @notice Check whether has passed the pending time period\n     *\n     * @param _reportTimestamp Start timestamp of the report\n     *\n     * @return hasPassed True for passing\n     */\n    function _passedPendingPeriod(uint256 _reportTimestamp)\n        internal\n        view\n        returns (bool)\n    {\n        return block.timestamp > _reportTimestamp + PENDING_PERIOD;\n    }\n\n    /**\n     * @notice Check whether has passed the voting time period\n     *\n     * @param _round      Current round\n     * @param _reportTime Start timestamp of the report\n     *\n     * @return hasPassed True for passing\n     */\n    function _passedVotingPeriod(uint256 _round, uint256 _reportTime)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 endTime = _reportTime +\n            PENDING_PERIOD +\n            VOTING_PERIOD +\n            _round *\n            EXTEND_PERIOD;\n        return block.timestamp > endTime;\n    }\n\n    /**\n     * @notice Check whether this round need extend\n     *\n     * @param _reportId Report id\n     * @param _round    Current round\n     *\n     * @return result 0 for extending, 1/2/3 for final result\n     */\n    function _checkRoundExtended(uint256 _reportId, uint256 _round)\n        internal\n        returns (uint256 result)\n    {\n        console.log(\"has changed\", reportTempResults[_reportId].hasChanged);\n\n        if (!reportTempResults[_reportId].hasChanged) {\n            result = _settleResult(\n                _reportId,\n                reports[_reportId].numFor,\n                reports[_reportId].numAgainst\n            );\n        } else if (reportTempResults[_reportId].hasChanged && _round < 2) {\n            _extendRound(_reportId);\n        }\n    }\n\n    /**\n     * @notice Settle the result for a report\n     *\n     * @param _reportId   Report id\n     * @param _numFor     Number of votes voting for\n     * @param _numAgainst Number of votes voting against\n     *\n     * @return result 0 for pass, 1 for reject and 2 for tied\n     */\n    function _settleResult(\n        uint256 _reportId,\n        uint256 _numFor,\n        uint256 _numAgainst\n    ) internal returns (uint256 result) {\n        result = _getVotingResult(_numFor, _numAgainst);\n\n        reports[_reportId].result = result;\n    }\n\n    /**\n     * @notice Extend the current round\n     *\n     * @param _reportId Report id\n     */\n    function _extendRound(uint256 _reportId) internal {\n        reports[_reportId].round += 1;\n    }\n\n    /**\n     * @notice Record a temporary result when goes in the sampling period\n     *\n     *         Temporary result use 1 for \"pass\" and 2 for \"reject\"\n     *\n     * @param _reportId   Report id\n     * @param _numFor     Vote numbers for\n     * @param _numAgainst Vote numbers against\n     */\n    function _recordTempResult(\n        uint256 _reportId,\n        uint256 _round,\n        uint256 _numFor,\n        uint256 _numAgainst\n    ) internal {\n        TempResult storage temp = reportTempResults[_reportId];\n\n        // Only record when it has reached the last day (time uint)\n        if (\n            block.timestamp >\n            reports[_reportId].voteTimestamp +\n                VOTING_PERIOD +\n                _round *\n                EXTEND_PERIOD -\n                SAMPLE_PERIOD\n        ) {\n            uint256 currentResult = _getVotingResult(_numFor, _numAgainst);\n\n            // If this is the first time for sampling, not record hasChange state\n            if (temp.result > 0) {\n                temp.hasChanged = currentResult != temp.result;\n            }\n\n            // Store the current result and sample time\n            temp.result = currentResult;\n            temp.sampleTimestamp = block.timestamp;\n        }\n    }\n\n    /**\n     * @notice Get the final voting result\n     *\n     * @param _numFor     Votes for\n     * @param _numAgainst Votes against\n     *\n     * @return result Pass, reject or tied\n     */\n    function _getVotingResult(uint256 _numFor, uint256 _numAgainst)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        if (_numFor > _numAgainst) result = PASS_RESULT;\n        else if (_numFor < _numAgainst) result = REJECT_RESULT;\n        else result = TIED_RESULT;\n    }\n\n    /**\n     * @notice Pause the related project pool and the re-insurance pool\n     *         Once there is an incident reported\n     *\n     * @param _pool Project pool address\n     */\n    function _pausePools(address _pool) internal {\n        IInsurancePool(_pool).pauseInsurancePool(true);\n        IReinsurancePool(reinsurancePool).pauseReinsurancePool(true);\n    }\n\n    /**\n     * @notice Pause the related project pool and the re-insurance pool\n     *         Once there is an incident reported\n     *\n     * @param _pool Project pool address\n     */\n    function _unpausePools(address _pool) internal {\n        IInsurancePool(_pool).pauseInsurancePool(false);\n        IReinsurancePool(reinsurancePool).pauseReinsurancePool(false);\n    }\n}\n"
    },
    "src/voting/interfaces/IncidentReportParameters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"./VotingParameters.sol\";\n\nabstract contract IncidentReportParameters is VotingParameters {\n    // Cool down time parameter\n    // If you submitted a wrong report, you cannot start another within cooldown period\n    uint256 public constant COOLDOWN_WRONG_REPORT = 7 days;\n\n    // Voting time length parameters\n    // uint256 constant PENDING_PERIOD = 3 days;\n    uint256 constant PENDING_PERIOD = 20 minutes;\n\n    // uint256 constant VOTING_PERIOD = 3 days;\n    uint256 constant VOTING_PERIOD = 2 hours;\n\n    uint256 constant EXTEND_PERIOD = 1 hours;\n    uint256 constant SAMPLE_PERIOD = 1 hours;\n\n    // Quorum parameter\n    uint256 constant QUORUM_RATIO = 30;\n\n    // DEG threshold for starting a report\n    uint256 constant REPORT_THRESHOLD = 1000 ether;\n\n    // DEG reward for correct reporter\n    uint256 constant REPORTER_REWARD = 1000 ether;\n\n    // Punishment for those who vote wrong\n    uint256 constant PUNISHMENT_RATIO = 40; // 40% go to winners, 40% reserve\n    uint256 constant DEBT_RATIO = 80; // 80% as the debt to unlock veDEG\n}\n"
    },
    "src/voting/interfaces/IncidentReportDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IPolicyCenter.sol\";\nimport \"../../interfaces/IInsurancePool.sol\";\nimport \"../../interfaces/IReinsurancePool.sol\";\nimport \"../../interfaces/IInsurancePoolFactory.sol\";\n\nabstract contract IncidentReportDependencies {\n    address public policyCenter;\n    address public reinsurancePool;\n    address public insurancePoolFactory;\n\n    function _setPolicyCenter(address _policyCenter) internal virtual {\n        policyCenter = _policyCenter;\n    }\n\n    function _setReinsurancePool(address _reinsurancePool) internal virtual {\n        reinsurancePool = _reinsurancePool;\n    }\n\n    function _setInsurancePoolFactory(address _insurancePoolFactory)\n        internal\n        virtual\n    {\n        insurancePoolFactory = _insurancePoolFactory;\n    }\n}\n"
    },
    "lib/forge-std/src/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "src/pools/ReinsurancePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./interfaces/ReinsurancePoolDependencies.sol\";\n\nimport \"../util/OwnableWithoutContext.sol\";\n\nimport \"../interfaces/ExternalTokenDependencies.sol\";\n\nimport \"lib/forge-std/src/console.sol\";\n\n/**\n * @title Reinsurance Pool\n *\n * @author Eric Lee (ylikp.ust@gmail.com) & Primata (primata@375labs.org)\n *\n * @notice This is the reinsurance pool contract for degis Protocol Protection\n *         Users can provide liquidity to it through the Policy Center.\n *         If the insurance pool is unable to fulfil the insurance, the reinsurance pool\n *         will be able to provide the insurance to the user.\n */\ncontract ReinsurancePool is\n    ERC20,\n    ReinsurancePoolDependencies,\n    ExternalTokenDependencies,\n    OwnableWithoutContext\n{\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    uint256 public constant DISTRIBUTION_PERIOD = 30 days;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    bool public insurancePoolLiquidated;\n    bool public paused;\n\n    uint256 public maxCapacity;\n\n    uint256 public startTime;\n\n    // Variables about distributing reward\n    // Accumulated reward per share (lp token)\n    uint256 public accumulatedRewardPerShare;\n\n    // Last reward update timestamp\n    uint256 public lastRewardTimestamp;\n\n    // Emission end tiemstamp\n    uint256 public emissionEndTime;\n\n    // Current emission rate\n    uint256 public emissionRate;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event MoveLiquidity(uint256 poolId, uint256 amount);\n    event LiquidityProvision(uint256 amount, address sender);\n    event LiquidityRemoved(uint256 amount, address sender);\n    event EmissionRateUpdated(\n        uint256 newEmissionRate,\n        uint256 newEmissionEndTime\n    );\n    event AccRewardsPerShareUpdated(uint256 amount);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(\n        address _deg,\n        address _veDeg,\n        address _shield\n    )\n        ERC20(\"ReinsurancePool\", \"RP\")\n        ExternalTokenDependencies(_deg, _veDeg, _shield)\n        OwnableWithoutContext(msg.sender)\n    {\n        // Register time that pool was deployed\n        startTime = block.timestamp;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Only allowed to be called from a pool\n    modifier poolOnly() {\n        require(\n            IInsurancePoolFactory(insurancePoolFactory).poolRegistered(\n                msg.sender\n            ),\n            \"Pool not found\"\n        );\n        _;\n    }\n\n    modifier onlyPolicyCenter() {\n        require(\n            msg.sender == policyCenter,\n            \"Only policy center can call this function\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Returns the to be rewarded by reinsurance pool\n     *\n     * @param _amount   Amount of liquidity provided by the user\n     * @param _userDebt Amount of debt the user has to the pool\n     *\n     * @return reward Reward amount\n     */\n    function calculateReward(uint256 _amount, uint256 _userDebt)\n        public\n        view\n        returns (uint256)\n    {\n        if (totalSupply() == 0) {\n            return 0;\n        }\n\n        uint256 rewards = (block.timestamp - lastRewardTimestamp) *\n            emissionRate;\n\n        uint256 acc = accumulatedRewardPerShare +\n            ((rewards * SCALE) / totalSupply());\n\n        uint256 pending = (_amount * acc) / SCALE - _userDebt;\n\n        return pending;\n    }\n\n    /**\n     * @notice returns pool information\n     */\n    function poolInfo()\n        external\n        view\n        returns (\n            bool,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            paused,\n            accumulatedRewardPerShare,\n            lastRewardTimestamp,\n            emissionEndTime,\n            emissionRate,\n            maxCapacity\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n    @notice terminate liquidation period on reinsurance pool only\n    */\n    function endLiquidationPeriod() external onlyOwner {\n        insurancePoolLiquidated = false;\n    }\n\n    function setIncidentReport(address _incidentReport) external onlyOwner {\n        _setIncidentReport(_incidentReport);\n    }\n\n    function setPolicyCenter(address _policyCenter) external onlyOwner {\n        _setPolicyCenter(_policyCenter);\n    }\n\n    function setInsurancePoolFactory(address _insurancePoolFactory)\n        external\n        onlyOwner\n    {\n        _setInsurancePoolFactory(_insurancePoolFactory);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice mints liquidity tokens. Only callable through policyCenter\n     *\n     * @param _amount Liquidity amount (shield)\n     */\n    function provideLiquidity(uint256 _amount, address _provider)\n        external\n        onlyPolicyCenter\n    {\n        require(_amount > 0, \"amount should be greater than 0\");\n\n        _mint(_provider, _amount);\n        emit LiquidityProvision(_amount, _provider);\n    }\n\n    /**\n    @notice burns liquidity tokens. Only callable through policyCenter\n     *\n    @param _amount      token being insured\n    @param _provider    liquidity provider adress\n    */\n    function removeLiquidity(uint256 _amount, address _provider)\n        external\n        onlyPolicyCenter\n    {\n        require(_amount <= totalSupply(), \"amount exceeds totalSupply\");\n        require(_amount > 0, \"amount should be greater than 0\");\n\n        require(!paused, \"cannot remove liquidity while paused\");\n        _burn(_provider, _amount);\n        emit LiquidityRemoved(_amount, _provider);\n    }\n\n    /**\n     * @notice  Move liquidity to another pool to be used for reinsurance,\n                reducing gas costs during liquidation period.\n     *\n     * @param _amount Amount of liquidity to transfer to insurance pool\n     * @param _poolId Id of the pool to move the liquidity to.\n     */\n    function moveLiquidity(uint256 _poolId, uint256 _amount)\n        external\n        onlyOwner\n    {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        address poolAddress = IPolicyCenter(policyCenter).insurancePools(\n            _poolId\n        );\n        require(poolAddress != address(0), \"Pool not found\");\n\n        IERC20(shield).transferFrom(address(this), poolAddress, _amount);\n        emit MoveLiquidity(_poolId, _amount);\n    }\n\n    /**\n     * @notice Sets paused state of the reinsurance pool\n     *\n     * @param _paused true if paused, false if not.\n     */\n    function pauseReinsurancePool(bool _paused) external {\n        require(\n            (msg.sender == owner()) || (msg.sender == incidentReport),\n            \"Only owner or Incident Report can call this function\"\n        );\n        paused = _paused;\n    }\n\n    /**\n    @notice Called when liqudity is provided, removed or coverage is bought.\n    updates all state variables to reflect current reward emission.\n    */\n    function updateRewards() public onlyPolicyCenter {\n        _updateRewards();\n    }\n\n    /**\n     * @notice Update emission rate based on new premium comission to liquidity providers\n     *\n     * @param _premium premium given to liquidity providers\n     */\n    function updateEmissionRate(uint256 _premium) public onlyPolicyCenter {\n        _updateEmissionRate(_premium);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Updates emission rate based on new incoming premium\n     *\n     * @param _premium incoming new premium\n     */\n    function _updateEmissionRate(uint256 _premium) internal {\n        // Update current reward taking into account new emission rate\n        _updateRewards();\n        // Get time to complete current pool of tokens emission to liquidity providers\n        uint256 timeToFinishEmission = emissionEndTime > block.timestamp\n            ? emissionEndTime - block.timestamp\n            : 0;\n\n        // Calculate new emission rate by adding new premium and redistributing previous emission\n        // Throughout the time it takes to complete emission.\n        if (timeToFinishEmission > 0) {\n            emissionRate =\n                ((emissionRate * timeToFinishEmission) + _premium) /\n                DISTRIBUTION_PERIOD;\n            // Update emission rate\n        } else {\n            // Update emission rate\n            emissionRate = _premium / DISTRIBUTION_PERIOD;\n        }\n\n        // update emission rate and emission ends\n        emissionEndTime = block.timestamp + (DISTRIBUTION_PERIOD * 1 days);\n\n        emit EmissionRateUpdated(emissionRate, emissionEndTime);\n    }\n\n    /**\n     * @notice Update rewards\n     */\n    function _updateRewards() internal {\n        if (totalSupply() == 0 || emissionEndTime == 0) {\n            // if totalSupply is 0, no rewards can be paid\n            // update last time rewards were claimed\n            lastRewardTimestamp = block.timestamp;\n        } else {\n            // if no coverages have been bought in over 30 days,\n            // discount time passed since the time that emission ends.\n\n            uint256 claimTimestamp = emissionEndTime < block.timestamp\n                ? emissionEndTime\n                : block.timestamp;\n            // Calculate difference between claim time and last time rewards were claimed\n            uint256 timeSinceLastReward = claimTimestamp - lastRewardTimestamp;\n\n            // Calculate new reward\n            uint256 rewards = (timeSinceLastReward * emissionRate) / 1 days;\n\n            // Update accumulated rewards given to each pool share\n            // accumulated\n            accumulatedRewardPerShare =\n                accumulatedRewardPerShare +\n                rewards /\n                totalSupply();\n            lastRewardTimestamp = block.timestamp;\n\n            // emit event to notify users that rewards have been updated\n            emit AccRewardsPerShareUpdated(accumulatedRewardPerShare);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "src/pools/interfaces/ReinsurancePoolDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IInsurancePoolFactory.sol\";\nimport \"../../interfaces/IPolicyCenter.sol\";\n\nabstract contract ReinsurancePoolDependencies {\n    address public insurancePoolFactory;\n    address public policyCenter;\n    address public incidentReport;\n\n    function _setPolicyCenter(address _policyCenter) internal virtual {\n        policyCenter = _policyCenter;\n    }\n\n    function _setInsurancePoolFactory(address _insurancePoolFactory)\n        internal\n        virtual\n    {\n        insurancePoolFactory = _insurancePoolFactory;\n    }\n\n    function _setIncidentReport(address _incidentReport) internal virtual {\n        incidentReport = _incidentReport;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "src/util/PriceGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport {AggregatorV3Interface} from \"lib/chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {OwnableWithoutContext} from \"./OwnableWithoutContext.sol\";\n\n/**\n * @title  Price Getter\n * @notice This is the contract for getting price feed from chainlink.\n *         The contract will keep a record from tokenName => priceFeed Address.\n *         Got the sponsorship and collaboration with Chainlink.\n * @dev    The price from chainlink priceFeed has different decimals, be careful.\n */\ncontract PriceGetter is OwnableWithoutContext {\n    struct PriceFeedInfo {\n        address priceFeedAddress;\n        uint256 decimals;\n    }\n    // Use token address as the mapping key\n    mapping(address => PriceFeedInfo) public priceFeedInfo;\n\n    // Find address according to name\n    mapping(string => address) public nameToAddress;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    event PriceFeedChanged(\n        string tokenName,\n        address tokenAddress,\n        address feedAddress,\n        uint256 decimals\n    );\n\n    event LatestPriceGet(\n        uint80 roundID,\n        int256 price,\n        uint256 startedAt,\n        uint256 timeStamp,\n        uint80 answeredInRound\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor() OwnableWithoutContext(msg.sender) {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Modifiers ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Can not give zero address\n     */\n    modifier notZeroAddress(address _address) {\n        require(_address != address(0), \"Zero address\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set a price feed oracle address for a token\n     * @dev Only callable by the owner\n     *      The price result decimal should be less than 18\n     *\n     * @param _tokenName   Address of the token\n     * @param _feedAddress Price feed oracle address\n     * @param _decimals    Decimals of this price feed service\n     */\n    function setPriceFeed(\n        string memory _tokenName,\n        address _tokenAddress,\n        address _feedAddress,\n        uint256 _decimals\n    ) public onlyOwner notZeroAddress(_feedAddress) {\n        require(_decimals <= 18, \"Too many decimals\");\n\n        priceFeedInfo[_tokenAddress] = PriceFeedInfo(_feedAddress, _decimals);\n        nameToAddress[_tokenName] = _tokenAddress;\n\n        emit PriceFeedChanged(\n            _tokenName,\n            _tokenAddress,\n            _feedAddress,\n            _decimals\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Main Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get latest price of a token\n     *\n     * @param _tokenName Name of the token\n     *\n     * @return price The latest price\n     */\n    function getLatestPrice(string memory _tokenName) public returns (uint256) {\n        return getLatestPrice(nameToAddress[_tokenName]);\n    }\n\n    /**\n     * @notice Get latest price of a token\n     *\n     * @param _tokenAddress Address of the token\n     *\n     * @return price The latest price\n     */\n    function getLatestPrice(address _tokenAddress) public returns (uint256) {\n        PriceFeedInfo memory priceFeed = priceFeedInfo[_tokenAddress];\n\n        (\n            uint80 roundID,\n            int256 price,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(priceFeed.priceFeedAddress).latestRoundData();\n\n        // require(price > 0, \"Only accept price that > 0\");\n        if (price < 0) price = 0;\n\n        emit LatestPriceGet(\n            roundID,\n            price,\n            startedAt,\n            timeStamp,\n            answeredInRound\n        );\n        // Transfer the result decimals\n        uint256 finalPrice = uint256(price) * (10**(18 - priceFeed.decimals));\n\n        return finalPrice;\n    }\n}\n"
    },
    "lib/chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "src/pools/InsurancePoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./interfaces/InsurancePoolFactoryDependencies.sol\";\n\nimport \"../util/OwnableWithoutContext.sol\";\n\nimport \"../interfaces/ExternalTokenDependencies.sol\";\n\nimport \"./InsurancePool.sol\";\n\n/**\n * @title Insurance Pool Factory\n *\n * @author Eric Lee (ylikp.ust@gmail.com)\n *\n * @notice This is the factory contract for deploying new insurance pools\n *         Each pool represents a project that has joined Degis Smart Contract Protection\n */\ncontract InsurancePoolFactory is\n    InsurancePoolFactoryDependencies,\n    ExternalTokenDependencies,\n    OwnableWithoutContext\n{\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    struct PoolInfo {\n        string protocolName;\n        address poolAddress;\n        address protocolToken;\n        uint256 maxCapacity;\n        uint256 policyPricePerShield;\n    }\n    // poolId => Pool Information\n    mapping(uint256 => PoolInfo) public pools;\n\n    uint256 public poolCounter;\n    uint256 public maxCapacity;\n\n    // Record whether a protocol token or pool address has been registered\n    mapping(address => bool) public poolRegistered;\n    mapping(address => bool) public tokenRegistered;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event PoolCreated(\n        uint256 poolId,\n        address poolAddress,\n        string protocolName,\n        address protocolToken,\n        uint256 maxCapacity,\n        uint256 policyPricePerShield\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(\n        address _deg,\n        address _veDeg,\n        address _shield,\n        address _reinsurancePool\n    )\n        ExternalTokenDependencies(_deg, _veDeg, _shield)\n        OwnableWithoutContext(msg.sender)\n    {\n        // stores addresses of the reinsurance pool and degis token\n        reinsurancePool = _reinsurancePool;\n\n        // stores information about reinsurance pool, first pool recorded\n        pools[poolCounter] = PoolInfo(\n            \"ReinsurancePool\",\n            _reinsurancePool,\n            _shield,\n            100000e18,\n            1\n        );\n\n        // Register reinsurance pool and degis token\n        poolRegistered[_reinsurancePool] = true;\n        tokenRegistered[_shield] = true;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the pool address list\n     *\n     * @return List of pool addresses\n     */\n    function getPoolAddressList() external view returns (address[] memory) {\n        uint256 poolAmount = poolCounter + 1;\n\n        address[] memory list = new address[](poolAmount);\n\n        for (uint256 i; i < poolAmount; ) {\n            list[i] = pools[i].poolAddress;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return list;\n    }\n\n    /**\n     * @notice Get the pool information by pool id\n     *\n     * @param _poolId Pool id\n     */\n    function getPoolInfo(uint256 _poolId)\n        public\n        view\n        returns (PoolInfo memory)\n    {\n        return pools[_poolId];\n    }\n\n    function setPolicyCenter(address _policyCenter) external onlyOwner {\n        _setPolicyCenter(_policyCenter);\n    }\n\n    function setReinsurancePool(address _reinsurancePool) external onlyOwner {\n        _setReinsurancePool(_reinsurancePool);\n    }\n\n    function setExecutor(address _executor) external onlyOwner {\n        _setExecutor(_executor);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Creates a new insurance pool\n     *\n     * @param _name                 Name of the protocol\n     * @param _protocolToken        Address of the token used for the protocol\n     * @param _maxCapacity          Maximum capacity of the pool\n     * @param _priceRatio  Initial policy price per shield\n     *\n     * @return address Address of the new insurance pool\n     */\n    function deployPool(\n        string calldata _name,\n        address _protocolToken,\n        uint256 _maxCapacity,\n        uint256 _priceRatio\n    ) public returns (address) {\n        require(\n            msg.sender == owner() || msg.sender == executor,\n            \"Only owner or executor contract can create a new insurance pool\"\n        );\n        require(!tokenRegistered[_protocolToken], \"Already registered\");\n\n        bytes32 salt = keccak256(abi.encodePacked(_name));\n\n        bytes memory bytecode = _getInsurancePoolBytecode(\n            _protocolToken,\n            _maxCapacity,\n            _priceRatio,\n            _name,\n            _name\n        );\n\n        // Finish deployment and get the address\n        address newPoolAddress = _deploy(bytecode, salt);\n\n        tokenRegistered[_protocolToken] = true;\n        poolRegistered[newPoolAddress] = true;\n\n        uint256 currentPoolId = ++poolCounter;\n\n        // Store pool information in Policy Center\n        IPolicyCenter(policyCenter).storePoolInformation(\n            newPoolAddress,\n            _protocolToken,\n            currentPoolId\n        );\n        pools[currentPoolId] = PoolInfo(\n            _name,\n            newPoolAddress,\n            _protocolToken,\n            _maxCapacity,\n            _priceRatio\n        );\n\n        emit PoolCreated(\n            currentPoolId,\n            newPoolAddress,\n            _name,\n            _protocolToken,\n            _maxCapacity,\n            _priceRatio\n        );\n\n        return newPoolAddress;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get bytecode for insurance pool creation according to parameters\n     *\n     * @param _protocolToken Address of the protocol token to insure\n     * @param _maxCapacity   Max coverage capacity\n     * @param _policyPrice   Policy price\n     * @param _tokenName     Name for the new pool\n     * @param _symbol        Symbol for new pool\n     *\n     * @return bytecode Creation bytecode\n     */\n    function _getInsurancePoolBytecode(\n        address _protocolToken,\n        uint256 _maxCapacity,\n        uint256 _policyPrice,\n        string memory _tokenName,\n        string memory _symbol\n    ) internal view virtual returns (bytes memory) {\n        bytes memory bytecode = type(InsurancePool).creationCode;\n\n        // Encodepacked the parameters\n        // The minter is set to be the policyCore address\n        return\n            abi.encodePacked(\n                bytecode,\n                abi.encode(\n                    _protocolToken,\n                    _maxCapacity,\n                    _tokenName,\n                    _symbol,\n                    _policyPrice,\n                    owner()\n                )\n            );\n    }\n\n    /**\n     * @notice Deploy function with create2\n     *\n     * @param _code Byte code of the contract (creation code) (including constructor parameters if any)\n     * @param _salt Salt for the deployment\n     *\n     * @return addr The deployed contract address\n     */\n    function _deploy(bytes memory _code, bytes32 _salt)\n        internal\n        returns (address addr)\n    {\n        assembly {\n            addr := create2(0, add(_code, 0x20), mload(_code), _salt)\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function deregisterAddress(address _tokenAddress) external {\n        require(\n            msg.sender == owner() || msg.sender == executor,\n            \"Only owner or executor contract can deregister an address\"\n        );\n        require(tokenRegistered[_tokenAddress], \"Address is not registered\");\n        tokenRegistered[_tokenAddress] = false;\n    }\n}\n"
    },
    "src/pools/interfaces/InsurancePoolFactoryDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IPolicyCenter.sol\";\n\nabstract contract InsurancePoolFactoryDependencies {\n    address public reinsurancePool;\n    address public policyCenter;\n    address public executor;\n\n    function _setExecutor(address _executor) internal virtual {\n        executor = _executor;\n    }\n\n    function _setReinsurancePool(address _reinsurancePool) internal virtual {\n        reinsurancePool = _reinsurancePool;\n    }\n\n    function _setPolicyCenter(address _policyCenter) internal virtual {\n        policyCenter = _policyCenter;\n    }\n\n}\n"
    },
    "src/pools/InsurancePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport \"lib/openzeppelin-contracts/contracts/security/Pausable.sol\";\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./interfaces/InsurancePoolDependencies.sol\";\n\nimport \"../util/OwnableWithoutContext.sol\";\n\nimport \"lib/forge-std/src/console.sol\";\n\n/**\n * @title Insurance Pool Factory\n *\n * @author Eric Lee (ylikp.ust@gmail.com) & Primata (primata@375labs.org)\n *\n * @notice This is the factory contract for deploying new insurance pools\n *         Each pool represents a project that has joined Degis Smart Contract Protection\n */\ncontract InsurancePool is\n    ERC20,\n    InsurancePoolDependencies,\n    OwnableWithoutContext,\n    Pausable\n{\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Time to distribute premium payments to liquidity providers\n    uint256 public constant DISTRIBUTION_PERIOD = 30;\n\n    // Time users have to claim payout when pool is liquidated\n    uint256 public constant CLAIM_PERIOD = 90;\n\n    uint256 public constant MIN_COVER_AMOUNT = 1 ether;\n\n    // Max time length in days of granted protection\n    uint256 public immutable maxLength;\n\n    // Min time length in days\n    uint256 public immutable minLength;\n\n    // Premium ratio (max 10000) (260 means 2.6% annually)\n    uint256 public immutable premiumRatio;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Admin address, set to be the owner of factory\n    address public admin;\n\n    // Address of insured token\n    address public insuredToken;\n\n    // If the pool has been liquidated\n    bool public liquidated;\n\n    // Max amount of bought protection in shield\n    uint256 public maxCapacity;\n\n    // Timestamp of pool creation\n    uint256 public startTime;\n\n    // Accumulated reward per lp token\n    uint256 public accumulatedRewardPerShare;\n\n    uint256 public lastRewardTimestamp;\n\n    uint256 public emissionEndTime;\n\n    uint256 public emissionRate;\n\n    uint256 public endLiquidationDate;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event LiquidityProvision(uint256 amount, address sender);\n    event LiquidityRemoved(uint256 amount, address sender);\n    event Liquidation(uint256 amount, uint256 endDate);\n    event EmissionRateUpdated(\n        uint256 newEmissionRate,\n        uint256 newEmissionEndTime\n    );\n    event AccRewardsPerShareUpdated(uint256 amount);\n    event LiquidationEnded(uint256 timestamp);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(\n        address _protocolToken,\n        uint256 _maxCapacity,\n        string memory _name,\n        string memory _symbol,\n        uint256 _premiumRatio,\n        address _admin\n    ) ERC20(_name, _symbol) OwnableWithoutContext(_admin) {\n        // token address insured by pool\n        insuredToken = _protocolToken;\n        maxCapacity = _maxCapacity;\n        startTime = block.timestamp;\n\n        premiumRatio = _premiumRatio;\n\n        maxLength = 90;\n        minLength = 7;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Only executor contract\n    modifier onlyExecutor() {\n        require(msg.sender == executor, \"Only executor can call this function\");\n        _;\n    }\n\n    // Only policy center contract\n    modifier onlyPolicyCenter() {\n        require(\n            msg.sender == policyCenter,\n            \"Only policy center can call this function\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice returns cost to buy coverage for a given period of time and amount of tokens\n     *\n     * @param _amount Amount being covered\n     * @param _length Coverage length in days\n     */\n    function coveragePrice(uint256 _amount, uint256 _length)\n        external\n        view\n        returns (uint256)\n    {\n        require(_amount >= MIN_COVER_AMOUNT, \"Under minimum cover amount\");\n        require(_withinLength(_length), \"Wrong cover length\");\n\n        // price in bps per year * amount of tokens to receive when pool is liquidated\n        // * lenght of coverage in days / year and 10000 to get bps to percentage\n        return (premiumRatio * _amount * _length) / 3650000;\n    }\n\n    /**\n     * @notice Calculate your reward\n     *\n     * @param _amount   Amount in provided liquidity\n     * @param _userDebt Amount of debt the user\n     */\n    function calculateReward(uint256 _amount, uint256 _userDebt)\n        external\n        view\n        returns (uint256)\n    {\n        if (totalSupply() == 0) {\n            return 0;\n        }\n        uint256 timePassed = block.timestamp - lastRewardTimestamp;\n        uint256 rewards = timePassed * emissionRate;\n\n        uint256 acc = accumulatedRewardPerShare + rewards / totalSupply();\n        uint256 reward = (_amount * acc) - _userDebt;\n        return reward;\n    }\n\n    /**\n     * @notice returns pool information\n     */\n    function poolInfo()\n        external\n        view\n        returns (\n            bool,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            paused(),\n            accumulatedRewardPerShare,\n            lastRewardTimestamp,\n            emissionEndTime,\n            emissionRate,\n            maxCapacity\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Pause this pool\n     *\n     * @param _paused True to pause, false to unpause\n     */\n    function pauseInsurancePool(bool _paused) external {\n        require(\n            (msg.sender == owner()) || (msg.sender == incidentReport),\n            \"Only owner or Incident Report can call this function\"\n        );\n        if (_paused) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    function setMaxCapacity(uint256 _maxCapacity) external onlyOwner {\n        maxCapacity = _maxCapacity;\n    }\n\n    function setExecutor(address _executor) external onlyOwner {\n        _setExecutor(_executor);\n    }\n\n    function setIncidentReport(address _incidentReport) external onlyOwner {\n        _setIncidentReport(_incidentReport);\n    }\n\n    function setPolicyCenter(address _policyCenter) external onlyOwner {\n        _setPolicyCenter(_policyCenter);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Provide liquidity from liquidity pool. Only callable through policyCenter\n     *\n     * @param _amount   Amount of liquidity to provide\n     * @param _provider Liquidity provider adress\n     */\n    function provideLiquidity(uint256 _amount, address _provider)\n        external\n        whenNotPaused\n        onlyPolicyCenter\n    {\n        require(!liquidated, \"cannot provide new liquidity\");\n        require(_amount > 0, \"amount should be greater than 0\");\n\n        _mint(_provider, _amount);\n        emit LiquidityProvision(_amount, _provider);\n    }\n\n    /**\n     * @notice Remove liquidity from insurance pool. Only callable through policyCenter\n     *\n     * @param _amount   Amount of liquidity to remove\n     * @param _provider Provider address\n     */\n    function removeLiquidity(uint256 _amount, address _provider)\n        external\n        whenNotPaused\n        onlyPolicyCenter\n    {\n        require(\n            !liquidated,\n            \"Pool has been liquidated, cannot remove liquidity\"\n        );\n\n        require(_amount > 0, \"amount should be greater than 0\");\n        _burn(_provider, _amount);\n        emit LiquidityRemoved(_amount, _provider);\n    }\n\n    /**\n    @notice Called when liqudity is provided, removed or coverage is bought.\n    updates all state variables to reflect current reward emission.\n    */\n    function updateRewards() public onlyPolicyCenter {\n        _updateRewards();\n    }\n\n    /**\n     * @notice Update emission rate based on new premium comission to liquidity providers\n     *\n     * @param _premium premium given to liquidity providers\n     */\n    function updateEmissionRate(uint256 _premium) public onlyPolicyCenter {\n        _updateEmissionRate(_premium);\n    }\n\n    /**\n     * @notice Sets this insurance pool status to liquidated\n     *         Only callable by executor\n     *         Only after the report has passed the voting\n     */\n    function liquidatePool() external onlyExecutor {\n        // changes the status of the insurance pool to liquidated and allows payout claims\n        _setLiquidationStatus(true);\n\n        // when liquidated, totalSupply does not change. liquidity providers keep LP tokens.\n        // LP tokens represent their share of remaining liquidity after payout is done.\n        uint256 amount = totalSupply();\n\n        // Set end liquidation date\n        // Users will have CLAIM_PERIOD days to claim payout.\n        endLiquidationDate = block.timestamp + CLAIM_PERIOD * 1 days;\n\n        // emit event to notify users that pool has been liquidated.\n        emit Liquidation(amount, endLiquidationDate);\n    }\n\n    /**\n     * @notice End the liquidation period\n     */\n    function endLiquidation() external {\n        require(liquidated, \"Pool has not been liquidated\");\n        require(\n            block.timestamp > endLiquidationDate,\n            \"Pool has not ended liquidation\"\n        );\n\n        // liquidation has ended. payout claims cannot be made.\n        _setLiquidationStatus(false);\n\n        emit LiquidationEnded(block.timestamp);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Updates emission rate based on new incoming premium\n     *\n     * @param _premium Incoming new premium\n     */\n    function _updateEmissionRate(uint256 _premium) internal {\n        // Update current reward taking into account new emission rate\n        _updateRewards();\n\n        // Get time to complete current pool of tokens emission to liquidity providers\n        uint256 timeToFinishEmission = emissionEndTime > block.timestamp\n            ? emissionEndTime - block.timestamp\n            : 0;\n\n        // Calculate new emission rate by adding new premium and redistributing previous emission\n        // Throughout the time it takes to complete emission.\n        if (timeToFinishEmission > 0) {\n            emissionRate =\n                ((emissionRate * timeToFinishEmission) + _premium) /\n                DISTRIBUTION_PERIOD;\n            // Update emission rate\n        } else {\n            // Update emission rate\n            emissionRate = _premium / DISTRIBUTION_PERIOD;\n        }\n\n        // update emission rate and emission ends\n        emissionEndTime = block.timestamp + (DISTRIBUTION_PERIOD * 1 days);\n\n        emit EmissionRateUpdated(emissionRate, emissionEndTime);\n    }\n\n    /**\n     * @notice Update rewards\n     */\n    function _updateRewards() internal {\n        if (totalSupply() == 0 || emissionEndTime == 0) {\n            // if totalSupply is 0, no rewards can be paid\n            // update last time rewards were claimed\n            lastRewardTimestamp = block.timestamp;\n        } else {\n            // if no coverages have been bought in over 30 days,\n            // discount time passed since the time that emission ends.\n            uint256 claimTimestamp = emissionEndTime < block.timestamp\n                ? emissionEndTime\n                : block.timestamp;\n\n            // Calculate difference between claim time and last time rewards were claimed\n            uint256 timeSinceLastReward = claimTimestamp - lastRewardTimestamp;\n\n            // Calculate new reward\n            uint256 rewards = (timeSinceLastReward * emissionRate) / 1 days;\n\n            // Update accumulated rewards given to each pool share\n            // accumulated\n            accumulatedRewardPerShare += rewards / totalSupply();\n            lastRewardTimestamp = block.timestamp;\n\n            // emit event to notify users that rewards have been updated\n            emit AccRewardsPerShareUpdated(accumulatedRewardPerShare);\n        }\n    }\n\n    /**\n     * @notice Set liquidation status\n     */\n    function _setLiquidationStatus(bool _liquidated) internal {\n        liquidated = _liquidated;\n    }\n\n    /**\n     * @notice Check the cover length is ok\n     */\n    function _withinLength(uint256 _length) internal view returns (bool) {\n        return _length >= minLength && _length <= maxLength;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "src/pools/interfaces/InsurancePoolDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nabstract contract InsurancePoolDependencies {\n    address public executor;\n    address public incidentReport;\n    address public policyCenter;\n\n    function _setExecutor(address _executor) internal virtual {\n        executor = _executor;\n    }\n\n\n    function _setIncidentReport(address _incidentReport) internal virtual {\n        incidentReport = _incidentReport;\n    }\n\n    function _setPolicyCenter(address _policyCenter) internal virtual {\n        policyCenter = _policyCenter;\n    }\n\n  \n}\n"
    },
    "src/mock/MockVeDEG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockVeDEG is ERC20 {\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n\n    uint8 public _decimals; //How many decimals to show.\n\n    mapping(address => bool) public whitelist;\n\n    mapping(address => uint256) public locked;\n\n    constructor(\n        uint256 _initialAmount,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol\n    ) ERC20(_tokenName, _tokenSymbol) {\n        _mint(msg.sender, _initialAmount);\n\n        _decimals = _decimalUnits; // Amount of decimals for display purposes\n\n        whitelist[msg.sender] = true;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    modifier whitelisted() {\n        require(whitelist[msg.sender], \"not whitelisted address\");\n        _;\n    }\n\n    function setWhitelist(address _address, bool _status) public {\n        whitelist[_address] = _status;\n    }\n\n    function mint(address user, uint256 amount) public {\n        _mint(user, amount);\n    }\n\n    function lockVeDEG(address _owner, uint256 _value) public {\n        locked[_owner] += _value;\n    }\n\n    function unlockVeDEG(address _owner, uint256 _value) public {\n        locked[_owner] -= _value;\n    }\n}\n"
    },
    "src/mock/MockSHIELD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockSHIELD is ERC20 {\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n\n    uint8 public _decimals; //How many decimals to show.\n\n    constructor(\n        uint256 _initialAmount,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol\n    ) ERC20(_tokenName, _tokenSymbol) {\n        _mint(msg.sender, _initialAmount);\n\n        _decimals = _decimalUnits; // Amount of decimals for display purposes\n    }\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _to, uint256 _amount) public {\n        _burn(_to, _amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "src/util/ProtocolProtection.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\nimport \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/IDegisToken.sol\";\nimport \"../interfaces/IVeDEG.sol\";\nimport \"../interfaces/IExchange.sol\";\nimport \"../interfaces/IReinsurancePool.sol\";\nimport \"../interfaces/IInsurancePool.sol\";\nimport \"../interfaces/IInsurancePoolFactory.sol\";\nimport \"../interfaces/IOnboardProposal.sol\";\nimport \"../interfaces/IIncidentReport.sol\";\nimport \"../interfaces/IPolicyCenter.sol\";\nimport \"../interfaces/IExecutor.sol\";\nimport \"../interfaces/IDegisToken.sol\";\nimport \"../interfaces/IVeDEG.sol\";\n\npragma solidity ^0.8.13;\n\ncontract ProtocolProtection is Ownable {\n    uint256 constant SCALE = 1e12;\n\n    // External Address\n    address public deg;\n    address public veDeg;\n    address public shield;\n\n    //\n    address public executor;\n    address public policyCenter;\n    address public incidentReport;\n    address public onboardProposal;\n    address public reinsurancePool;\n    address public insurancePoolFactory;\n\n    constructor() {}\n\n    function setDeg(address _deg) external virtual onlyOwner {\n        deg = _deg;\n    }\n\n    function setVeDeg(address _veDeg) external virtual onlyOwner {\n        veDeg = _veDeg;\n    }\n\n    function setShield(address _shield) external virtual onlyOwner {\n        shield = _shield;\n    }\n\n    function setExecutor(address _executor) external virtual onlyOwner {\n        executor = _executor;\n    }\n\n    function setPolicyCenter(address _policyCenter) external virtual onlyOwner {\n        policyCenter = _policyCenter;\n    }\n\n    function setIncidentReport(address _incidentReport)\n        external\n        virtual\n        onlyOwner\n    {\n        incidentReport = _incidentReport;\n    }\n\n    function setOnboardProposal(address _onboardProposal)\n        external\n        virtual\n        onlyOwner\n    {\n        onboardProposal = _onboardProposal;\n    }\n\n    function setReinsurancePool(address _reinsurancePool)\n        external\n        virtual\n        onlyOwner\n    {\n        reinsurancePool = _reinsurancePool;\n    }\n\n    function setInsurancePoolFactory(address _insurancePoolFactory)\n        external\n        virtual\n        onlyOwner\n    {\n        insurancePoolFactory = _insurancePoolFactory;\n    }\n}\n"
    },
    "src/interfaces/IExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n\ninterface IExchange {\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) view external returns (uint256);\n    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) external returns (uint256);\n    function swapTokensForExactTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) external returns (uint256);\n\n}"
    },
    "src/voting/ProposalCenter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\nimport \"../util/ProtocolProtection.sol\";\n\npragma solidity ^0.8.13;\n\n/**\n * @title Proposal Center\n *\n * @author Eric Lee (ylikp.ust@gmail.com) & Primata (primata@375labs.org)\n *\n * @notice This is the Proposal Center where users can submit reports and proposals.\n *         Each proposal and report is assigned a unique ID and is stored in the proposal center.\n *         Users can evaluate proposals and reports and vote to pass them on weighted by their veDeg balance.\n */\ncontract ProposalCenter is ProtocolProtection {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    struct Report {\n        uint256 poolId;\n        uint256 timestamp;\n        address reporterAddress;\n        uint256 yes;\n        uint256 no;\n        uint256 round;\n        bool pending;\n        bool approved;\n        address[] voted;\n    }\n\n    uint256 public reportCounter;\n    mapping(uint256 => Report) public reportIds;\n    // reportId => address => vote\n    mapping(uint256 => mapping(address => bool)) public confirmsReport;\n    // refer to pool addresses through policy center\n    mapping(address => bool) public poolReported;\n    uint256 public reportBuffer;\n\n    struct PoolProposal {\n        string protocolName;\n        address protocolAddress;\n        address[] voted;\n        uint256 maxCapacity;\n        // per year in bps 10000 == 100%\n        uint256 policyPricePerShield;\n        uint256 timestamp;\n        uint256 yes;\n        uint256 no;\n        uint256 round;\n        bool pending;\n        bool approved;\n    }\n\n    uint256 public proposalCounter;\n    mapping(uint256 => PoolProposal) public proposalIds;\n    // refer to pool addresses through policy center\n    mapping(address => bool) public poolProposed;\n    uint256 public proposalBuffer;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event Vote(uint256 _id, bool _quorum, string _who);\n    event ReportCreated(\n        uint256 _reportId,\n        uint256 _poolId,\n        uint256 _timestamp,\n        address _reporterAddress\n    );\n    event ReportApproved(\n        uint256 _reportId,\n        uint256 _poolId,\n        uint256 _timestamp,\n        address _reporterAddress,\n        uint256 yes,\n        uint256 no\n    );\n    event ReportRejected(\n        uint256 _reportId,\n        uint256 _poolId,\n        uint256 _timestamp,\n        address _reporterAddress,\n        uint256 _yes,\n        uint256 _no\n    );\n\n    event PoolProposalCreated(\n        uint256 indexed _proposalId,\n        address _protocol,\n        uint256 _maxCapacity,\n        uint256 _timestamp\n    );\n\n    event PoolProposalApproved(\n        uint256 _proposalId,\n        address _protocol,\n        uint256 _timestamp,\n        uint256 _yes,\n        uint256 _no\n    );\n    event PoolProposalRejected(\n        uint256 _proposalId,\n        address _protocol,\n        uint256 _timestamp,\n        uint256 _yes,\n        uint256 _no\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor() {\n        // initiates buffers to 3 days\n        reportBuffer = 3 days;\n        proposalBuffer = 3 days;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    modifier onlyOwnerOrExecutor() {\n        require(\n            (msg.sender == owner()) || (msg.sender == executor),\n            \"Only owner or executor can call this function\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Returns the number of proposals in the proposal center.\n     * @return protocolName     name of the protocol\n     * @return protocolAddress  address of the protocol\n     * @return voted            list of addresses that have already voted\n     * @return maxCapacity      maximum capacity of the pool\n     * @return timestamp        timestamp of the proposal\n     * @return policyPricePerShield  price per shield in bps\n     * @return yes              number of yes votes in veDEG\n     * @return no               number of no votes in veDEG\n     * @return pending          if decision is still pending\n     * @return approved         if current decision is approved\n\n     */\n    function getPoolProposal(uint256 _proposalId)\n        public\n        view\n        returns (\n            string memory,\n            address,\n            address[] memory,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            bool\n        )\n    {\n        PoolProposal memory proposal = proposalIds[_proposalId];\n        return (\n            proposal.protocolName,\n            proposal.protocolAddress,\n            proposal.voted,\n            proposal.maxCapacity,\n            proposal.timestamp,\n            proposal.policyPricePerShield,\n            proposal.yes,\n            proposal.no,\n            proposal.pending,\n            proposal.approved\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n    @notice sets a pool state to reported. If reported, prevents further proposed.\n    @param _poolAddress address of the pool to be proposed\n    @param _decision    true if reported, false if not proposed\n     */\n    function setPoolProposed(address _poolAddress, bool _decision)\n        external\n        onlyOwnerOrExecutor\n    {\n        poolProposed[_poolAddress] = _decision;\n    }\n\n    /**\n    @notice sets a pool state to reported. If reported, prevents further reporting.\n    @param _poolAddress address of the pool to be reported\n    @param _decision    true if reported, false if not reported\n     */\n    function setPoolReported(address _poolAddress, bool _decision)\n        external\n        onlyOwnerOrExecutor\n    {\n        poolReported[_poolAddress] = _decision;\n    }\n\n    /**\n    @notice approves a proposal or not.\n    @param _proposalId address of the pool to be proposed\n    @param _decision    true if proposed, false if not proposed\n     */\n    function setProposalApproval(uint256 _proposalId, bool _decision)\n        external\n        onlyOwnerOrExecutor\n    {\n        proposalIds[_proposalId].approved = _decision;\n        proposalIds[_proposalId].pending = false;\n    }\n\n    /**\n    @notice approves a proposal or not.\n    @param _reportId address of the pool to be proposed\n    @param _decision    true if proposed, false if not proposed\n     */\n    function setReportApproval(uint256 _reportId, bool _decision)\n        external\n        onlyOwnerOrExecutor\n    {\n        reportIds[_reportId].approved = _decision;\n        reportIds[_reportId].pending = false;\n    }\n\n    /**\n    @notice sets report and proposal voting buffers.\n    @param _reportBuffer buffer for reports\n    @param _proposalBuffer buffer for proposals\n    */\n    function setBuffers(uint256 _reportBuffer, uint256 _proposalBuffer)\n        external\n        onlyOwnerOrExecutor\n    {\n        reportBuffer = _reportBuffer;\n        proposalBuffer = _proposalBuffer;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n    @notice votes on currently pending report in proposal center.\n            voting power is decided by the amount of staked veDEG.\n            rewarded if votes with majority.\n            punished if votes against majority.\n    @param _reportId id of the report to be voted on\n    @param _vote true if yes, false if no\n    */\n    function voteReport(uint256 _reportId, bool _vote) external {\n        require(reportIds[_reportId].pending, \"Report is not pending\");\n        address[] storage voted = reportIds[_reportId].voted;\n        uint256 length = voted.length;\n        // verifies if address already voted\n        for (uint256 i = 0; i < length; i++) {\n            require(voted[i] != msg.sender, \"Address already voted\");\n        }\n        // vedeg weight to vote in balance\n        uint256 balance = IERC20(veDeg).balanceOf(msg.sender);\n        require(balance > 0, \"You have no tokens\");\n        // lock vedeg until vote is processed\n        IVeDEG(veDeg).lockVeDEG(msg.sender, (balance * 4) / 5);\n        // register vote\n        if (_vote) {\n            reportIds[_reportId].yes += balance;\n            confirmsReport[_reportId][msg.sender] = true;\n        } else {\n            reportIds[_reportId].no += balance;\n            confirmsReport[_reportId][msg.sender] = false;\n        }\n        // registers voter\n        voted.push(msg.sender);\n        emit Vote(_reportId, _vote, \"Report\");\n    }\n\n    /**\n    @notice votes on currently pending proposal in proposal center.\n            voting power is decided by the amount of staked veDEG.\n            no penalty nor rewards.\n    @param _proposalId id of the pool proposal to be voted on\n    @param _vote true if yes, false if no\n    */\n    function votePoolProposal(uint256 _proposalId, bool _vote) external {\n        require(proposalIds[_proposalId].pending, \"Report is not pending\");\n        address[] storage voted = proposalIds[_proposalId].voted;\n        uint256 length = voted.length;\n        // verifies if address already voted\n        for (uint256 i = 0; i < length; i++) {\n            require(voted[i] != msg.sender, \"Address already voted\");\n        }\n        uint256 balance = IERC20(veDeg).balanceOf(msg.sender);\n        require(balance > 0, \"You have no tokens\");\n        // register votes\n        if (_vote) {\n            proposalIds[_proposalId].yes += balance;\n        } else {\n            proposalIds[_proposalId].no += balance;\n        }\n        // registers voter\n        voted.push(msg.sender);\n        emit Vote(_proposalId, _vote, \"New Pool\");\n    }\n\n    /**\n    @notice evaluates votes on a pending report in proposal center.\n            if it approval is the same twice in a row or round is 2,\n            it is approved and sent to executor queue.\n    @param _reportId id of the report to be voted on\n    */\n    function evaluateReportVotes(uint256 _reportId) external {\n        require(reportIds[_reportId].pending, \"report not pending\");\n        // 3 days for the report to be evaluated\n        require(\n            reportIds[_reportId].timestamp + reportBuffer < block.timestamp,\n            \"report not ready\"\n        );\n\n        uint256 total = reportIds[_reportId].yes + reportIds[_reportId].no;\n        // requires 30% of vedeg total supply to vote on a report\n        require(\n            total > (IERC20(veDeg).totalSupply() * 3) / 10,\n            \"Not enough votes\"\n        );\n        address pool = IPolicyCenter(policyCenter).insurancePools(\n            reportIds[_reportId].poolId\n        );\n        bool result = reportIds[_reportId].yes > reportIds[_reportId].no;\n        // if last round or vote agrees with previous round, move on with the report\n        if (\n            (reportIds[_reportId].round == 2) ||\n            (reportIds[_reportId].round > 0 &&\n                result == reportIds[_reportId].approved)\n        ) {\n            if (result) {\n                reportIds[_reportId].approved = true;\n                emit ReportApproved(\n                    _reportId,\n                    reportIds[_reportId].poolId,\n                    reportIds[_reportId].timestamp,\n                    reportIds[_reportId].reporterAddress,\n                    reportIds[_reportId].yes,\n                    reportIds[_reportId].no\n                );\n                // queue report for execution\n                IExecutor(executor).queueReport(\n                    reportIds[_reportId].pending,\n                    reportIds[_reportId].approved,\n                    _reportId,\n                    reportIds[_reportId].poolId\n                );\n            } else {\n                // pool is not approved and pool is open to new proposal\n                reportIds[_reportId].approved = false;\n                poolReported[pool] = false;\n                emit ReportRejected(\n                    _reportId,\n                    reportIds[_reportId].poolId,\n                    reportIds[_reportId].timestamp,\n                    reportIds[_reportId].reporterAddress,\n                    reportIds[_reportId].yes,\n                    reportIds[_reportId].no\n                );\n            }\n            reportIds[_reportId].pending = false;\n        } else {\n            // if not definitive round, set approval for future check\n            // and add 24hrs to voting period\n            reportIds[_reportId].approved = result;\n            reportIds[_reportId].timestamp += 86400;\n        }\n        reportIds[_reportId].round++;\n    }\n\n    /**\n    @notice evaluates votes on a pending pool proposal in proposal center.\n            if it approval is the same twice in a row or round is 2,\n            it is approved and sent to executor queue.\n    @param _proposalId id of the proposal to be voted on\n    */\n    function evaluatePoolProposalVotes(uint256 _proposalId) external {\n        require(proposalIds[_proposalId].pending, \"proposal not pending\");\n        // 3 days for the report to be evaluated\n        require(\n            proposalIds[_proposalId].timestamp + proposalBuffer <\n                block.timestamp,\n            \"proposal not ready\"\n        );\n        address protocol = proposalIds[_proposalId].protocolAddress;\n        uint256 total = proposalIds[_proposalId].yes +\n            proposalIds[_proposalId].no;\n        // requires 30% of vedeg total supply to vote on a proposal\n        require(\n            total > (IERC20(veDeg).totalSupply() * 3) / 10,\n            \"Not enough votes\"\n        );\n        bool result = proposalIds[_proposalId].yes >\n            proposalIds[_proposalId].no;\n        // if last round or vote agrees with previous round, move on with the report\n        if (\n            (proposalIds[_proposalId].round == 2) ||\n            (proposalIds[_proposalId].round > 0 &&\n                result == proposalIds[_proposalId].approved)\n        ) {\n            if (result) {\n                proposalIds[_proposalId].approved = true;\n                emit PoolProposalApproved(\n                    _proposalId,\n                    protocol,\n                    proposalIds[_proposalId].timestamp,\n                    proposalIds[_proposalId].yes,\n                    proposalIds[_proposalId].no\n                );\n                // queue pool for execution\n                IExecutor(executor).queuePool(\n                    proposalIds[_proposalId].protocolName,\n                    _proposalId,\n                    proposalIds[_proposalId].protocolAddress,\n                    proposalIds[_proposalId].maxCapacity,\n                    proposalIds[_proposalId].policyPricePerShield,\n                    proposalIds[_proposalId].pending,\n                    proposalIds[_proposalId].approved\n                );\n            } else {\n                // pool is not approved and pool is open to new proposal\n                proposalIds[_proposalId].approved = false;\n                poolProposed[protocol] = false;\n                emit PoolProposalRejected(\n                    _proposalId,\n                    protocol,\n                    proposalIds[_proposalId].timestamp,\n                    proposalIds[_proposalId].yes,\n                    proposalIds[_proposalId].no\n                );\n            }\n            proposalIds[_proposalId].pending = false;\n        } else {\n            // if not definitive round, set approval for future check\n            // and add 24hrs to voting period\n            proposalIds[_proposalId].approved = result;\n            proposalIds[_proposalId].timestamp += 86400;\n        }\n        proposalIds[_proposalId].round++;\n    }\n\n    /**\n    @notice reports that a protocol has been compromised.\n            user notifies that pool should be liquidated.\n            1000 DEG tokens are held by the proposal center\n            until report is deemed truthful.\n    @param _poolId id of the pool to be reported\n    */\n    function reportPool(uint256 _poolId) public {\n        address pool = IPolicyCenter(policyCenter).insurancePools(_poolId);\n        require(!poolReported[pool], \"Pool already reported\");\n        require(pool != address(0), \"Pool doesn't exist\");\n        uint256 counter = ++reportCounter;\n        address[] memory initializeArray;\n        poolReported[pool] = true;\n        // registers new report\n        Report storage report = reportIds[counter];\n        report.poolId = _poolId;\n        report.timestamp = block.timestamp;\n        report.reporterAddress = msg.sender;\n        report.pending = true;\n        report.approved = false;\n        report.voted = initializeArray;\n        // transfer back to deg address. another option is to burn it.\n        IERC20(deg).transferFrom(msg.sender, deg, 1000);\n        IInsurancePool(pool).pauseInsurancePool(true);\n        IReinsurancePool(reinsurancePool).pauseReinsurancePool(true);\n\n        emit ReportCreated(\n            counter,\n            reportIds[counter].poolId,\n            reportIds[counter].timestamp,\n            reportIds[counter].reporterAddress\n        );\n    }\n\n    /**\n    @notice proposes a new protocol to be insured.\n\n    @param _protocol             address of token to receive have a new insurance pool.\n    @param _name                 name of the protocol to be insured.\n    @param _maxCapacity          maximum capacity of the insurance pool in native token.\n    @param _policyPricePerShield price of the policy in native token.\n    */\n    function proposePool(\n        address _protocol,\n        string memory _name,\n        uint256 _maxCapacity,\n        uint256 _policyPricePerShield\n    ) public {\n        require(!poolProposed[_protocol], \"Protocol already proposed\");\n        uint256 counter = ++proposalCounter;\n        address[] memory emptyVoted;\n        // registers new proposal\n        PoolProposal storage pool = proposalIds[counter];\n        pool.protocolName = _name;\n        pool.protocolAddress = _protocol;\n        pool.voted = emptyVoted;\n        pool.maxCapacity = _maxCapacity;\n        pool.policyPricePerShield = _policyPricePerShield;\n        pool.timestamp = block.timestamp;\n        pool.pending = true;\n        pool.approved = false;\n\n        // sets protocol to proposed so there are no cuncurrent duplicates\n        poolProposed[_protocol] = true;\n        emit PoolProposalCreated(\n            proposalCounter,\n            _protocol,\n            proposalIds[counter].maxCapacity,\n            proposalIds[counter].timestamp\n        );\n    }\n\n    /**\n    @notice reward voters for a report with a final result and penalizes\n            bad votes.\n            Only callable through executor.\n    @param _reportId    id of the report to be reward voters on.\n    @param _veredict    true if report was approved, false if rejected.\n     */\n    function rewardByReportId(uint256 _reportId, bool _veredict) external {\n        require(msg.sender == executor, \"Only Executor can liquidate\");\n        address[] memory voted = reportIds[_reportId].voted;\n        uint256 reward = 0;\n        if (_veredict) {\n            IPolicyCenter(policyCenter).rewardTreasuryToReporter(\n                reportIds[_reportId].reporterAddress\n            );\n            IDegisToken(deg).mintDegis(\n                reportIds[_reportId].reporterAddress,\n                2000\n            );\n            // punishment for voting against majority\n            for (uint256 i = 0; i < voted.length; i++) {\n                if (confirmsReport[_reportId][voted[i]] != _veredict) {\n                    (uint256 veDegBalance, ) = IVeDEG(deg).users(1, voted[i]);\n                    uint256 stakedDegPenalty = (veDegBalance * 4) / 500;\n                    reward += stakedDegPenalty;\n                    IERC20(deg).transferFrom(\n                        voted[i],\n                        address(this),\n                        stakedDegPenalty\n                    );\n                    // unlock vedeg balance\n                    IVeDEG(veDeg).unlockVeDEG(voted[i], (veDegBalance * 4) / 5);\n                }\n            }\n            // rewards for voting with majority\n            if (reward > 0) {\n                for (uint256 i = 0; i < voted.length; i++) {\n                    if (confirmsReport[_reportId][voted[i]] == _veredict) {\n                        // if voted with the decision, reward 50% of penalty to voters\n                        // according to the amount of vedeg they hold\n                        uint256 balance = IERC20(veDeg).balanceOf(voted[i]);\n                        uint256 toTransfer = (balance *\n                            reportIds[_reportId].yes) / 2;\n                        IERC20(deg).transfer(voted[i], toTransfer);\n                        IVeDEG(veDeg).unlockVeDEG(voted[i], (balance * 4) / 5);\n                        reward -= toTransfer;\n                    }\n                }\n                IERC20(deg).transfer(policyCenter, reward);\n            }\n        }\n    }\n}\n"
    },
    "src/core/interfaces/PolicyCenterDependencies.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IInsurancePool.sol\";\nimport \"../../interfaces/IReinsurancePool.sol\";\nimport \"../../interfaces/IInsurancePoolFactory.sol\";\nimport \"../../interfaces/IExchange.sol\";\n\nabstract contract PolicyCenterDependencies {\n    address public executor;\n    address public reinsurancePool;\n    address public insurancePoolFactory;\n    address public exchange;\n\n    function _setExchange(address _exchange) internal virtual {\n        exchange = _exchange;\n    }\n\n    function _setExecutor(address _executor) internal virtual {\n        executor = _executor;\n    }\n\n    function _setReinsurancePool(address _reinsurancePool) internal virtual {\n        reinsurancePool = _reinsurancePool;\n    }\n\n    function _setInsurancePoolFactory(address _insurancePoolFactory)\n        internal\n        virtual\n    {\n        insurancePoolFactory = _insurancePoolFactory;\n    }\n}\n"
    },
    "src/core/PolicyCenter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n  *******         **********     ***********     *****     ***********\n  *      *        *              *                 *       *\n  *        *      *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     *              *                 *       *\n  *         *     **********     *       *****     *       ***********\n  *         *     *              *         *       *                 *\n  *         *     *              *         *       *                 *\n  *        *      *              *         *       *                 *\n  *      *        *              *         *       *                 *\n  *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.13;\n\nimport \"../util/OwnableWithoutContext.sol\";\n\nimport \"../mock/MockExchange.sol\";\n\nimport \"./interfaces/PolicyCenterDependencies.sol\";\n\nimport \"../interfaces/ExternalTokenDependencies.sol\";\n\nimport \"lib/forge-std/src/console.sol\";\n\n/**\n * @title Policy Center\n *\n * @author Eric Lee (ylikp.ust@gmail.com) & Primata (primata@375labs.org)\n *\n * @notice This is the policy center for degis Protocol Protection\n *         Users can buy policies and get payoff here\n *         Sellers can provide liquidity and choose the pools to cover\n *\n */\ncontract PolicyCenter is\n    PolicyCenterDependencies,\n    ExternalTokenDependencies,\n    OwnableWithoutContext\n{\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // poolId => address, updated once pools are deployed\n    // ReinsurancePool is pool 0\n    mapping(uint256 => address) public insurancePools;\n    mapping(uint256 => address) public tokenByPoolId;\n\n    // poolId => user => Cover info\n    struct Cover {\n        uint256 amount;\n        uint256 buyDate;\n        uint256 length;\n    }\n    mapping(uint256 => mapping(address => Cover)) public covers;\n\n    mapping(uint256 => uint256) public fundsByPoolId;\n\n    // amount of rewards by pool Id paid by cover buyers\n    mapping(uint256 => uint256) public totalRewardsByPoolId;\n\n    // poolId => user => Liquidity info\n    struct Liquidity {\n        uint256 amount;\n        uint256 userDebt;\n        uint256 lastClaim;\n    }\n    mapping(uint256 => mapping(address => Liquidity)) public liquidities;\n    // amount of liquidity by pool id given by liquidity providers\n    mapping(uint256 => uint256) public liquidityByPoolId;\n\n    // bps distribution of premiums 0: insurance pool, 1: reinsurance pool\n    uint256[2] public premiumSplits;\n\n    // amount of degis in treasury\n    uint256 public treasury;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event Reward(uint256 _amount, address _address);\n    event Payout(uint256 _amount, address _address);\n    event CoverBought(\n        address buyer,\n        uint256 poolId,\n        uint256 length,\n        uint256 coverAmount,\n        uint256 premium\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(\n        address _deg,\n        address _veDeg,\n        address _shield,\n        address _reinsurancePool\n    )\n        ExternalTokenDependencies(_deg, _veDeg, _shield)\n        OwnableWithoutContext(msg.sender)\n    {\n        // initializes required reinsurance address and degis token as reinsurance token\n        insurancePools[0] = _reinsurancePool;\n        tokenByPoolId[0] = _shield;\n\n        _setReinsurancePool(_reinsurancePool);\n\n        // initializes premium split standard in bps\n        premiumSplits = [4500, 5000];\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // veirifies if pool exists. used throughout insurance contracts\n    modifier poolExists(uint256 _poolId) {\n        require(insurancePools[_poolId] != address(0), \"Pool not found\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice returns premium split used by Policy Center\n     * @return insurancePool premium split in bps\n     * @return reinsurancePool premium split in bps\n     */\n    function getPremiumSplits() public view returns (uint256, uint256) {\n        return (premiumSplits[0], premiumSplits[1]);\n    }\n\n    /**\n     * @notice returns pool  info for a given pool id\n     * @param _poolId                   pool id generated by Policy Center\n     * @return paused                   true if pool is paused, false otherwise\n     * @return accumulatedRewardPerShare  accumulated reward per each share of the pool\n     * @return lastRewardTimestamp      last time reward has been  updated\n     * @return emissionEndTime          time emission ends if no new cover is bought\n     * @return emissionRate             rate of emission if no new cover is bought\n     * @return maxCapacity              max capacity of the pool in shield\n     */\n    function getPoolInfo(uint256 _poolId)\n        public\n        view\n        poolExists(_poolId)\n        returns (\n            bool paused,\n            uint256 accumulatedRewardPerShare,\n            uint256 lastRewardTimestamp,\n            uint256 emissionEndTime,\n            uint256 emissionRate,\n            uint256 maxCapacity\n        )\n    {\n        (\n            paused,\n            accumulatedRewardPerShare,\n            lastRewardTimestamp,\n            emissionEndTime,\n            emissionRate,\n            maxCapacity\n        ) = IInsurancePool(insurancePools[_poolId]).poolInfo();\n    }\n\n    /**\n     * @notice returns information about the cover of a given user\n     *\n     * @param _poolId Pool id\n     * @param _user   User address\n     *\n     * @return cover Cover info\n     */\n    function getCover(uint256 _poolId, address _user)\n        public\n        view\n        poolExists(_poolId)\n        returns (Cover memory)\n    {\n        return covers[_poolId][_user];\n    }\n\n    /**\n     * @notice Reward for liquidity providers\n     *\n     * @param _poolId Pool id (0 for reinsurance pool)\n     *\n     * @return uint256 Reward\n     */\n    function calculateReward(uint256 _poolId, address _provider)\n        public\n        view\n        poolExists(_poolId)\n        returns (uint256)\n    {\n        Liquidity memory liquidity = liquidities[_poolId][_provider];\n        if (_poolId > 0) {\n            // gets reward from insurance pool\n            return\n                IInsurancePool(insurancePools[_poolId]).calculateReward(\n                    liquidity.amount,\n                    liquidity.userDebt\n                );\n        } else {\n            return\n                // gets reward from reinsurance pool\n                IReinsurancePool(reinsurancePool).calculateReward(\n                    liquidity.amount,\n                    liquidity.userDebt\n                );\n        }\n    }\n\n    /**\n     * @notice returns payout given to cover buyers when report passes\n     * @param _poolId pool id to claim from. 0 if reinsurance pool\n     * @return uint256 amount of payout\n     */\n    function calculatePayout(uint256 _poolId, address _insured)\n        public\n        view\n        returns (uint256)\n    {\n        require(_poolId > 0, \"Reinsurance pool grants no direct payout\");\n        // returns amount user has paid for cover\n        uint256 amount = covers[_poolId][_insured].amount;\n        return amount;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice sets the premium splits used by Policy Center\n     * @param _insurance    split for insurance\n     * @param _reinsurance  split for reinsurance\n     */\n    function setPremiumSplit(uint256 _insurance, uint256 _reinsurance)\n        external\n        onlyOwner\n    {\n        // up to 1000bps, left over goes to treasury\n        require(_insurance + _reinsurance <= 10000, \"Invalid split\");\n        require(_insurance > 0, \"has not given an insurance split\");\n        require(_reinsurance > 0, \"has not given a reinsurance split\");\n        //sets insurance and reinsurance splits\n        premiumSplits = [_insurance, _reinsurance];\n    }\n\n    /**\n     *  @notice set exchange address to be used for token swaps\n     *  @param _exchange address of traderjoe contract\n     */\n    function setExchange(address _exchange) external onlyOwner {\n        exchange = _exchange;\n    }\n\n    function setExecutor(address _executor) external onlyOwner {\n        _setExecutor(_executor);\n    }\n\n    function setReinsurancePool(address _reinsurancePool) external onlyOwner {\n        _setReinsurancePool(_reinsurancePool);\n    }\n\n    function setInsurancePoolFactory(address _insurancePoolFactory)\n        external\n        onlyOwner\n    {\n        _setInsurancePoolFactory(_insurancePoolFactory);\n    }\n\n    /**\n     * @notice sets the insurance pool factory address\n     * @param _pool  address of the insurance pool\n     * @param _token address of token that a pool negotiates in\n     * @param _poolId id of the pool\n     */\n    function storePoolInformation(\n        address _pool,\n        address _token,\n        uint256 _poolId\n    ) external {\n        require(\n            msg.sender == owner() || msg.sender == insurancePoolFactory,\n            \"Only owner or insurancePoolFactory can set tokens\"\n        );\n        // maps token address to pool id\n        tokenByPoolId[_poolId] = _token;\n        // maps pool address to pool id\n        insurancePools[_poolId] = _pool;\n        // approve token swapping for internal funds management\n        _approvePoolToken(_token);\n    }\n\n    /**\n     * @notice approves exchange to swap tokens in control of policy center\n     * @param _token        address of the approved token\n     */\n    function approvePoolToken(address _token) external {\n        require(\n            msg.sender == owner() || msg.sender == insurancePoolFactory,\n            \"Only owner or insurancePoolFactory can set tokens\"\n        );\n        _approvePoolToken(_token);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Buy new cover for a given pool\n     * @param _poolId       pool id generated on Policy Center\n     * @param _coverAmount  amount of tokens to cover\n     * @param _length       lenght of cover in days\n     */\n    function buyCover(\n        uint256 _poolId,\n        uint256 _coverAmount,\n        uint256 _length\n    ) external poolExists(_poolId) {\n        require(_coverAmount > 0, \"Amount must be greater than 0\");\n        require(_length > 0, \"Length must be greater than 0\");\n        require(_poolId > 0, \"PoolId must be greater than 0\");\n\n        require(\n            IInsurancePool(insurancePools[_poolId]).maxCapacity() >=\n                _coverAmount + fundsByPoolId[_poolId],\n            \"exceeds max capacity\"\n        );\n\n        uint256 premium = _getCoverPrice(_poolId, _coverAmount, _length);\n\n        totalRewardsByPoolId[_poolId] += premium;\n\n        Cover storage cover = covers[_poolId][msg.sender];\n\n        cover.amount += _coverAmount;\n        // initial 7 days buffer so pool cannot be exploited\n        cover.buyDate = block.timestamp + 7 days;\n        cover.length = _length;\n\n        // updates pool distribution based on paid amount\n        IERC20(tokenByPoolId[_poolId]).transferFrom(\n            msg.sender,\n            address(this),\n            premium\n        );\n        emit CoverBought(msg.sender, _poolId, _length, _coverAmount, premium);\n\n        _splitPremium(_poolId, premium);\n    }\n\n    /**\n     * @notice Distribute those pending premiums\n     *         To save gas, we do not transfer premiums for every purchase\n     */\n    function distributePremium() external {}\n\n    /**\n     * @notice claim rewards from a given pool id\n     * @param _poolId pool id to claim rewards from\n     */\n    function claimReward(uint256 _poolId) public poolExists(_poolId) {\n        _claimReward(_poolId, msg.sender);\n    }\n\n    /**\n     * @notice Provide liquidity to a give pool id\n     *\n     * @param _poolId Pool id\n     * @param _amount Amount of liquidity to provide\n     */\n    function provideLiquidity(uint256 _poolId, uint256 _amount)\n        external\n        poolExists(_poolId)\n    {\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        // claim rewards. user debt is updated in _claimReward\n        _claimReward(_poolId, msg.sender);\n\n        // adds liquidity to insurance or reinsurance pool\n        liquidityByPoolId[_poolId] += _amount;\n\n        Liquidity storage liquidity = liquidities[_poolId][msg.sender];\n\n        if (_poolId > 0) {\n            // emits tokens to user from insurnace pool\n            IInsurancePool(insurancePools[_poolId]).provideLiquidity(\n                _amount,\n                msg.sender\n            );\n        } else {\n            // emits tokens to user from reinsurnace pool\n            IReinsurancePool(reinsurancePool).provideLiquidity(\n                _amount,\n                msg.sender\n            );\n        }\n        // upsates user provided amount and last claim\n        liquidity.amount += _amount;\n        liquidity.lastClaim = block.timestamp;\n\n        IERC20(shield).transferFrom(msg.sender, address(this), _amount);\n    }\n\n    /**\n     * @notice Remove liquidity to a give pool id\n     *\n     * @param _poolId Pool id\n     * @param _amount Amount of liquidity to provide\n     */\n    function removeLiquidity(uint256 _poolId, uint256 _amount)\n        external\n        poolExists(_poolId)\n    {\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        require(\n            _amount <= liquidities[_poolId][msg.sender].amount,\n            \"Amount must be less than provided liquidity\"\n        );\n        require(\n            _amount <= liquidityByPoolId[_poolId],\n            \"Amount must be less than liquidity\"\n        );\n        require(\n            block.timestamp >=\n                liquidities[_poolId][msg.sender].lastClaim + 604800,\n            \"cannot remove liquidity within 7 days of last claim\"\n        );\n\n        Liquidity storage liquidity = liquidities[_poolId][msg.sender];\n\n        // claim rewards for caller by pool id. user debt is updated in claim reward\n        _claimReward(_poolId, msg.sender);\n\n        // removes liquidity from insurance or reinsurance pool\n        liquidityByPoolId[_poolId] -= _amount;\n\n        if (_poolId > 0) {\n            // burns liquidity tokens in users account from insurance pool\n            IInsurancePool(insurancePools[_poolId]).removeLiquidity(\n                _amount,\n                msg.sender\n            );\n        } else {\n            // burns liquidity tokens in users account from reinsurance pool\n            IReinsurancePool(reinsurancePool).removeLiquidity(\n                _amount,\n                msg.sender\n            );\n        }\n\n        // new amount owned by caller\n        liquidity.amount -= _amount;\n        liquidity.lastClaim = block.timestamp;\n\n        IERC20(shield).transfer(msg.sender, _amount);\n    }\n\n    /**\n     * @notice claims liquidation payout given a pool id\n     *\n     * @param _poolId Pool id\n     */\n    function claimPayout(uint256 _poolId) public poolExists(_poolId) {\n        require(_poolId > 0, \"PoolId must be greater than 0\");\n\n        IInsurancePool pool = IInsurancePool(insurancePools[_poolId]);\n\n        Cover storage cover = covers[_poolId][msg.sender];\n        //the user can only claim a payout 7 days after the cover was bought\n\n        // exploit protection\n        require(cover.buyDate < block.timestamp, \"coverage is not yet active\");\n        require(pool.liquidated(), \"pool is not claimable\");\n        require(\n            pool.endLiquidationDate() >= block.timestamp,\n            \"claim period is over\"\n        );\n\n        // buy date + length + liquidation date - 5 days buffer\n        // intended to fullfil valid coverages accounting for voting period\n        require(\n            cover.buyDate + (cover.length * 1 days) >=\n                pool.endLiquidationDate() - 20 days,\n            \"coverage has expired\"\n        );\n\n        require(cover.amount > 0, \"no coverage to claim\");\n        // gets amount to give as payout\n        uint256 amount = calculatePayout(_poolId, msg.sender);\n\n        // coverage by user is removed\n        cover.amount = 0;\n        if (liquidityByPoolId[_poolId] >= amount) {\n            // Insurance doesn't need reinsurance\n            // Registers removal of funds from insurance pool\n            // if its enough to cover all funds\n            fundsByPoolId[_poolId] -= cover.amount;\n        } else {\n            // Insurance pool needs reinsurance\n            // registers removel of funds from insurance and reinsurance pools\n            // effectively reinsuring insurance pools\n            liquidityByPoolId[_poolId] -= amount;\n\n            // remove from reinsurance pool\n            liquidityByPoolId[0] -= (amount - liquidityByPoolId[_poolId]);\n        }\n        // transfer the totalSupply to user and then ask Reinsurance pool for the remainder\n        IERC20(tokenByPoolId[_poolId]).transfer(msg.sender, amount);\n        emit Payout(amount, msg.sender);\n    }\n\n    /**\n     * @notice rewards reporter when a reported insurance pool is liquidated with treasury\n     * callable by contract only\n     * @param _reporter address of the reporter\n     */\n    function rewardTreasuryToReporter(address _reporter) external {\n        require(msg.sender == executor, \"not requested by Executor\");\n\n        // 10% of treasury + 2000 DEG\n        uint256 reward = (treasury * 1000) / 10000;\n        treasury -= reward;\n\n        IDegisToken(deg).transfer(_reporter, reward);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice claims rewards from a given pool id\n     * @param _poolId   pool id to claim rewards from\n     * @param _provider address of the claimer\n     */\n    function _claimReward(uint256 _poolId, address _provider) internal {\n        if (_poolId > 0) {\n            require(\n                !IInsurancePool(insurancePools[_poolId]).liquidated(),\n                \"Pool has been liquidated, cannot claim stake\"\n            );\n            IInsurancePool(insurancePools[_poolId]).updateRewards();\n        } else {\n            require(\n                !IReinsurancePool(reinsurancePool).paused(),\n                \"a pool has been liquidated, unable to remove liquidity\"\n            );\n            IReinsurancePool(reinsurancePool).updateRewards();\n        }\n        // retrieve a user's liquidity from a pool\n        Liquidity storage liquidity = liquidities[_poolId][_provider];\n        IInsurancePool pool = IInsurancePool(insurancePools[_poolId]);\n\n        console.log(\"pool acc:\", pool.accumulatedRewardPerShare());\n        console.log(\"amount\", liquidity.amount);\n        console.log(\"Debt\", liquidity.userDebt);\n        // Calculate reward amount based on user's liquidity and acc reward per share.\n        uint256 reward = (liquidity.amount * pool.accumulatedRewardPerShare()) -\n            liquidity.userDebt;\n\n        console.log(\"funds\", fundsByPoolId[_poolId]);\n        fundsByPoolId[_poolId] -= reward;\n\n        liquidity.userDebt =\n            liquidity.amount *\n            pool.accumulatedRewardPerShare();\n\n        IERC20(tokenByPoolId[_poolId]).transfer(_provider, reward);\n\n        emit Reward(reward, _provider);\n    }\n\n    /**\n     * @notice swaps tokens for deg\n     *\n     * @param _amount       amount of liquidity to request\n     * @param _fromToken    token address to exchange from\n     * @param _toToken      token address to exchange to\n     */\n    function _swapTokens(\n        uint256 _amount,\n        address _fromToken,\n        address _toToken\n    ) internal returns (uint256 receives) {\n        address[] memory path = new address[](2);\n        path[0] = _fromToken;\n        path[1] = _toToken;\n\n        // exchange tokens for deg and return amount of deg received\n        receives = IExchange(exchange).swapExactTokensForTokens(\n            _amount,\n            ((_amount * 99) / 100),\n            path,\n            address(this),\n            block.timestamp + 1\n        );\n    }\n\n    /**\n     * @notice swaps tokens for deg\n     *\n     * @param _amount       Amount of liquidity to request\n     * @param _fromToken    Token address to exchange from\n     * @param _toToken      Token address to exchange to\n     */\n    function _swapForExactTokens(\n        uint256 _amount,\n        address _fromToken,\n        address _toToken\n    ) internal returns (uint256 receives) {\n        address[] memory array = new address[](1);\n        array[0] = _fromToken;\n\n        // exchange tokens for deg and return amount of deg received\n        receives = IExchange(exchange).swapTokensForExactTokens(\n            _amount,\n            ((_amount * 99) / 100),\n            array,\n            _toToken,\n            0\n        );\n    }\n\n    /**\n     * @notice splits received premium given a pool id\n     * @param _poolId pool id generated on Policy Center\n     */\n    function _splitPremium(uint256 _poolId, uint256 _amount)\n        internal\n        poolExists(_poolId)\n    {\n        require(_amount > 0, \"No funds to split\");\n        address fromToken = tokenByPoolId[_poolId];\n        uint256 totalSplit = _amount;\n\n        uint256 toInsurancePool = (totalSplit * premiumSplits[0]) / 10000;\n        uint256 toReinsurancePool = (totalSplit * premiumSplits[1]) / 10000;\n\n        // treasury receives left overs\n        uint256 toTreasury = totalSplit - toInsurancePool - toReinsurancePool;\n\n        // swap native for degis\n        uint256 treasuryReceives = _swapTokens(toTreasury, fromToken, deg);\n        uint256 reinsuranceReceives = _swapTokens(\n            toReinsurancePool,\n            fromToken,\n            deg\n        );\n\n        treasury += treasuryReceives;\n\n        fundsByPoolId[_poolId] += toInsurancePool;\n\n        // reinsurance pool is pool 0\n        fundsByPoolId[0] += reinsuranceReceives;\n\n        IInsurancePool(insurancePools[_poolId]).updateEmissionRate(\n            toInsurancePool\n        );\n        IReinsurancePool(reinsurancePool).updateEmissionRate(\n            reinsuranceReceives\n        );\n    }\n\n    function _approvePoolToken(address _token) internal {\n        require(exchange != address(0), \"Exchange address not set\");\n        // approve exchange to swap policy center tokens for deg\n        IERC20(_token).approve(exchange, type(uint256).max);\n    }\n\n    /**\n     * @notice Get cover price from insurance pool\n     */\n    function _getCoverPrice(\n        uint256 _poolId,\n        uint256 _coverAmount,\n        uint256 _length\n    ) internal view returns (uint256 price) {\n        price = IInsurancePool(insurancePools[_poolId]).coveragePrice(\n            _coverAmount,\n            _length\n        );\n    }\n}\n"
    },
    "src/mock/MockExchange.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.13;\n\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\ncontract Exchange {\n    string public name;\n\n    constructor() {\n        name = \"exchange\";\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut) {\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n        amountOut = getAmountOut(amountIn, amountOutMin, amountOutMin);\n        IERC20(path[1]).transfer(msg.sender, amountOut);\n    }\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amount) {\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountInMax);\n        amount = getAmountOut(amountInMax, amountOut, amountOut);\n        IERC20(path[1]).transfer(msg.sender, amountOut);\n    }\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure returns (uint256) {\n        return (amountIn * 99) / 100;\n    }\n}\n"
    },
    "src/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.13;\n\nimport \"lib/openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    constructor() Ownable() {}\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy)\n        public\n        view\n        virtual\n        returns (address)\n    {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\n            hex\"5c60da1b\"\n        );\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy)\n        public\n        view\n        virtual\n        returns (address)\n    {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\n            hex\"f851a440\"\n        );\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(\n        TransparentUpgradeableProxy proxy,\n        address newAdmin\n    ) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation)\n        public\n        virtual\n        onlyOwner\n    {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "src/mock/MockDEG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockDEG is ERC20 {\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n\n    uint8 public _decimals; //How many decimals to show.\n\n    constructor(\n        uint256 _initialAmount,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol\n    ) ERC20(_tokenName, _tokenSymbol) {\n        _mint(msg.sender, _initialAmount);\n\n        _decimals = _decimalUnits; // Amount of decimals for display purposes\n    }\n\n    function mintDegis(address _account, uint256 _amount) external {\n        _mint(_account, _amount);\n    }\n\n    function burnDegis(address _account, uint256 _amount) external {\n        _burn(_account, _amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031363539393235383335353336"
      }
    }
  }
}